{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://www.010101.cc","root":"/"},"pages":[{"title":"","date":"2021-11-08T15:58:59.009Z","updated":"2021-11-08T15:58:59.009Z","comments":true,"path":"index.html","permalink":"http://www.010101.cc/index.html","excerpt":"","text":"叫我021吧！ 请叫我021吧 Web Developer &amp; Designer Shenzhen, China × Toggle navigation Home Archives Categories Tags Repository Books Links About Board 欢迎交流与我分享您的经验! Archive November 20212 Recent Posts test 2021-11-08 Hello World 2021-11-08 test Nov 8 Comments Hello World Nov 8 Comments Theme by cofess base on pure. window.jQuery || document.write('') (function (window) { var INSIGHT_CONFIG = { TRANSLATION: { POSTS: 'Posts', PAGES: 'Pages', CATEGORIES: 'Categories', TAGS: 'Tags', UNTITLED: '(Untitled)', }, ROOT_URL: '/', CONTENT_URL: '/content.json', }; window.INSIGHT_CONFIG = INSIGHT_CONFIG; })(window);"},{"title":"标签","date":"2021-11-09T06:45:29.327Z","updated":"2021-11-09T06:45:29.327Z","comments":false,"path":"tags/index.html","permalink":"http://www.010101.cc/tags/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2021-11-10T11:41:34.587Z","updated":"2021-11-10T11:41:34.587Z","comments":false,"path":"about/index.html","permalink":"http://www.010101.cc/about/index.html","excerpt":"","text":"感谢访问，联系我&#x70;&#x6f;&#x6b;&#101;&#x72;&#x30;&#x33;&#50;&#53;&#x40;&#x6d;&#x65;&#x2e;&#x63;&#111;&#109;（麻烦注明来意）.我向您Salute!!! ：）"},{"title":"分类","date":"2021-11-09T06:49:57.349Z","updated":"2021-11-09T06:49:57.349Z","comments":false,"path":"categories/index.html","permalink":"http://www.010101.cc/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-09T06:50:41.947Z","updated":"2021-11-09T06:50:41.947Z","comments":true,"path":"links/index.html","permalink":"http://www.010101.cc/links/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM之Java编译器浅析","slug":"JVM之编译浅析","date":"2021-11-11T07:04:04.000Z","updated":"2021-11-11T07:13:08.483Z","comments":true,"path":"2021/11/11/JVM之编译浅析/","link":"","permalink":"http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/","excerpt":"","text":"Wirte by 021. Java编译器浅析 本地代码（native code） 是计算机编程（代码），编译用来运行一个特殊的处理器（如英特尔x86级的处理器）和它的特殊指令集，简称机器码. Win : exe Linux : elf 模式1 ： 即时编译JIT编译器-Just in time. 主要用于JVM将 **class热点代码 ** 编译为本地代码. 模式2： 解释器 byteCode intepreter 在程序运行过程中，JVM将字节码再转换成本地可执行的本地代码,边解释字节码边执行，故而称为解释器。 参数设置123默认： -Xmixed 混合模式-Xint 解释模式，启动块，执行稍微慢-XComp 编译模式，启动时间慢，需要编译 ​","categories":[{"name":"Java","slug":"Java","permalink":"http://www.010101.cc/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.010101.cc/tags/JVM/"}]},{"title":"JVM之GC垃圾回收器与算法深入浅出","slug":"JVM之GC垃圾回收浅析","date":"2021-11-11T07:04:04.000Z","updated":"2021-11-12T08:37:37.459Z","comments":true,"path":"2021/11/11/JVM之GC垃圾回收浅析/","link":"","permalink":"http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/","excerpt":"","text":"JVM之GC浅析Wirte by 021. 对象头 堆特性 Eden 存活对象少 S1 S2 Old 存活对象多 对象存活晋升过程 按年龄 12345对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。Paralle Scavenge 15CMS 6G1 15 动态年龄分配函数 12345678910111213141516uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123; //survivor_capacity是survivor空间的大小 size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100); size_t total = 0; uint age = 1; while (age &lt; table_size) &#123; total += sizes[age];//sizes数组是每个年龄段对象大小 if (total &gt; desired_survivor_size) break; age++; &#125; uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold; ...&#125;Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。 什么是垃圾？（对象引用详解） 什么是强引用Strong Reference？ 1Object o = new Object(); 特点 1只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。 什么情况下会被回收？ 12Object o = new Object();o = null; 什么是软引用SoftReference？ 特点 1234567891011121314151617SoftReference&lt;Student&gt;studentSoftReference=new SoftReference&lt;Student&gt;(new Student()); Student student = studentSoftReference.get(); System.out.println(student); SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;byte[]&gt;(new byte[1024*1024*10]); System.out.println(softReference.get()); System.gc(); System.out.println(softReference.get()); byte[] bytes = new byte[1024 * 1024 * 10]; System.out.println(softReference.get());//// 将内存调小 -Xmx20M ，输出结果：[B@11d7fff[B@11d7fffnull 什么时候会被回收？ 1当JVM内存不足，执行GC后，内存依然不足，会回收软引用. 什么是弱引用WeakReference？ 特点 123456789WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1]); System.out.println(weakReference.get()); System.gc(); System.out.println(weakReference.get()); //输出结果： [B@11d7fffnull 什么情况下会被回收？ 1只要触发GC就会被回收. 什么是虚引用PhantomReference？ 特点 1NIO中，就运用了虚引用管理堆外内存，用于堆外内存的释放. 看官方源码注释 ： 本大神硬核翻译！希望你能懂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; /** * Phantom reference objects, which are enqueued after the collector * determines that their referents may otherwise be reclaimed. Phantom * references are most often used for scheduling pre-mortem cleanup actions in * a more flexible way than is possible with the Java finalization mechanism. * 虚引用对象，在垃圾收集器决定这些引用可能被回收时入队，虚引用经常用于在“对象死亡后，对对象进行死亡讣告” 是一种可能比Java直接回收的更灵活一种方式. * &lt;p&gt; If the garbage collector determines at a certain point in time that the * referent of a phantom reference is &lt;a * href=&quot;package-summary.html#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that * time or at some later time it will enqueue the reference. * //此段没有太大的意义 * &lt;p&gt; In order to ensure that a reclaimable object remains so, the referent of * a phantom reference may not be retrieved: The &lt;code&gt;get&lt;/code&gt; method of a * phantom reference always returns &lt;code&gt;null&lt;/code&gt;. * // 为了保证 已确定回收对象 的规则， 虚引用不再返回该对象的引用. * &lt;p&gt; Unlike soft and weak references, phantom references are not * automatically cleared by the garbage collector as they are enqueued. An * object that is reachable via phantom references will remain so until all * such references are cleared or themselves become unreachable. * * @author Mark Reinhold * @since 1.2 */ //不像其他引用一样，在虚引用入队后不会自动被垃圾回收器清理, 一个可达对象被虚引用所引用后会一直保持在列队，直到这些引用被清理或者这些引用变得不可达. =================================/** * Reference queues, to which registered reference objects are appended by the * garbage collector after the appropriate reachability changes are detected. * * @author Mark Reinhold * @since 1.2 */ 当垃圾回收器在适合的时机检测到可达性发生改变时决定 将这些 引用 加入列队.public class ReferenceQueue&lt;T&gt; &#123; 什么情况下会被回收？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class A&#123; @Override protected void finalize() throws Throwable &#123; System.out.println(&quot;A对象 被回收了&quot;); &#125; protected void freeMem() throws Throwable &#123; System.out.println(&quot;执行堆外内存释放&quot;); &#125;&#125;class B&#123; @Override protected void finalize() throws Throwable &#123; System.out.println(&quot;B对象 被回收了&quot;); &#125;&#125;public class PerformanceTest &#123; final int a = 0; final int b =10; final static int c = 0; volatile int d = 0; volatile int e = 0; public static void main(String[] args) throws InterruptedException &#123; PerformanceTest p = new PerformanceTest(); //p.test(0,0); //打印当前对象内存分布 //System.out.println(VM.current().details()); //System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable()); //虚引用测试 p.phantomReferenceTest(); &#125; private void phantomReferenceTest() throws InterruptedException &#123; ReferenceQueue queue = new ReferenceQueue(); List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;(); //强引用 A a = new A(); B b = new B(); //虚引用 PhantomReference&lt;A&gt; reference = new PhantomReference&lt;A&gt;(new A(),queue); //弱引用 WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1024*1024*10]); System.out.println(&quot;强引用GC回收前强引用=====================&quot;+a); System.out.println(&quot;强引用GC回收前弱引用：=====================&quot;+weakReference.get()); //此线程触发GC 设置-Xmx20M new Thread(() -&gt; &#123; for (int i = 0; i &lt; 30;i++ ) &#123; bytes.add(new byte[1024 * 1024]); &#125; &#125;).start(); Thread.sleep(1000); System.out.println(&quot;强引用GC回收后弱引用：=====================&quot;+weakReference.get()); new Thread(() -&gt; &#123; while (true) &#123; Reference poll = queue.poll(); if (poll != null) &#123; System.out.println(&quot;虚引用被回收了：&quot; + poll); &#125; if (poll == null) &#123; System.out.println(&quot;内存中没有引虚拟引用了，被清理了&quot;); try &#123; new A().freeMem(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; return; &#125; &#125; &#125;).start(); System.out.println(&quot;强引用GC回收后强引用A:=====================&quot;+a); &#125;&#125;//输出结果: 执行结果有乱序，不影响，用序号标记解释1.强引用GC回收前强引用=====================com.mybrainsbox.performance.A@621be5d12.强引用GC回收前弱引用：=====================[B@573fd7453.A对象 被回收了4.强引用GC回收后弱引用：=====================null5.强引用GC回收后强引用A:=====================com.mybrainsbox.performance.A@621be5d16.虚引用被回收了：java.lang.ref.PhantomReference@6d39548b7.内存中没有引虚拟引用了，被清理了8.B对象 被回收了9.执行堆外内存释放10.A对象 被回收了====================================================3.A对象 被回收了 这一步输出对应 ： PhantomReference&lt;A&gt; reference = new PhantomReference&lt;A&gt;(new A(),queue);一旦触发GC, 被PhantomReference引用的对象都会被设置为弱引用，并加入虚引用列队.等待回收.所以这一步在GC触发时输出.6.虚引用被回收了：java.lang.ref.PhantomReference@6d39548b这一步是 虚引用列队在GC后拿到被虚引用引用的new A()最后的回执，所有的可达性检测决定可能要回收的对象都会被加入此列队，直到poll()出全部.7.内存中没有引虚拟引用了，被清理了;这一步是poll出了所有的虚引用的对象列队;8.B对象 被回收了10.A对象 被回收了8和10是方法出栈被回收的. 怎么样找到垃圾？ 引用计数器 1在对象头里，有数据位表示该对象有没有引用，当引用计数为0对象将被回收. 缺陷 ：循环引用 容易引起孤岛效应—- 即 ： A -&gt; B -&gt; C , 3个对象互相引用，计数不为0，但实际已经没有任何引用指向这三个对象. Root Searching 根可达算法 根路径 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区中的类静态属性引用的对象。 方法区中的常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）的引用的对象。 常见GC垃圾回收算法 标记 -&gt; 清除 特点 123451，标记过程：从GC root出发遍历所有对象，在可达对象头中的markeword进行标记. 2，清理过程：遍历堆中对象，判断对象头markword是否存活标记，进行回收. 缺陷 效率问题：需要2遍扫描，标记和清除都需要遍历，效率不高； 空间问题：标记清除后会产生大量不连续的内存水平，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。 适用堆区 Old 触发GC类型 Major GC/老年代GC 标记 -&gt; 复制 特点 123451，标记 : 将年轻代的空间一分为三，[Eden],[ s1 ] ,[ s2 ]，比例是：8：1：1 ，2，复制: 当使用 s1内存块 使用率达到阈值，s2空白，将存活对象复制到s2内存空间.3,清理 : 清理s1空间块. 通过这个方式避免了碎片化空间问题. 缺陷 效率问题：标记和清除都需要遍历，效率不高； 空间问题：内存空间浪费，最大10%， 适用堆区 Eden 触发GC类型 MinorGC/年轻代GC 标记 -&gt; 压缩（整理） 特点 12341，先标记2，压缩整理： 把可达对象往内存块偏移量折中的任意一端移动，达到空间整洁规整。 缺陷 效率问题：需要扫描2次，移动对象引用需要重新引用地址，，效率不如复制算法高效； 适用堆区 Old 触发GC类型 Major GC/老年代GC GC垃圾回收器（算法的实现）CMSSTW安全点1在JIT执行方式下，JIT编译的时候直接把Safepoint的检查代码加入了生成的本地代码。当JVM需要让Java线程进入Safepoint时，只需要设置一个标志位，让Java线程运行到Safepoint时主动检查这个标志位，如果标志被设置，那么线程停顿，如果没有被设置，那么继续执行。如HotSpot在x86中为轮询Safepoint会生成一条类似于test汇编指令。 什么时候触发GC l ​","categories":[{"name":"Java","slug":"Java","permalink":"http://www.010101.cc/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.010101.cc/tags/JVM/"}]},{"title":"JVM之Java对象内存分布","slug":"JVM之Java对象内存分布","date":"2021-11-11T07:04:04.000Z","updated":"2021-11-11T09:12:21.631Z","comments":true,"path":"2021/11/11/JVM之Java对象内存分布/","link":"","permalink":"http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/","excerpt":"","text":"Java对象内存分布Wirte by 021. 示例 对象全局图 ​ 头部markword","categories":[{"name":"Java","slug":"Java","permalink":"http://www.010101.cc/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.010101.cc/tags/JVM/"}]},{"title":"JVM之Java运行时数据区浅析---TODO","slug":"JVM之运行时数据区TODO","date":"2021-11-11T07:04:04.000Z","updated":"2021-11-11T10:19:31.986Z","comments":true,"path":"2021/11/11/JVM之运行时数据区TODO/","link":"","permalink":"http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/","excerpt":"","text":"JVM之运行时数据区 ————– TODOWirte by 021. 示例代码1234567891011121314151617181920212223242526272829public class PerformanceTest &#123; final int a = 0; final int b =10; final static int c = 0; volatile int d = 0; volatile int e = 0; public static void main(String[] args)&#123; int f = 0; PerformanceTest p = new PerformanceTest(); p.test(a,b); System.out.println(VM.current().details()); System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable()); &#125; private int test(int a , int b)&#123; System.out.println(this.getClass().getClassLoader()); System.out.println(Long.class.getClass().getClassLoader()); System.out.println(Integer.class.getClass().getClassLoader()); return a + b; &#125; &#125; Progarm Counter 程序计数器 执行代码行标记 JVM stack 方法栈 Local Variable Table 局部变量表 1234args[]int f = 0; Operand Stack 操作数栈 1 Dynamic Linking 静态连接 1当前线程在运行时与常量池符号的连接. 指向常量池的变量. 示例代码中：final static int c = 0，p.test(0,0);; Retuen Address 返回地址 1函数执行结果的值地址存入栈顶. p.test(a,b) = return a + b; 本地方法栈 Native 本地方法相关方法栈. 方法区 l Direct Memory JVM可以直接访问的内核空间内存，0拷贝。 堆 参数设置123默认： -Xmixed 混合模式-Xint 解释模式，启动块，执行稍微慢-XComp 编译模式，启动时间慢，需要编译 ​","categories":[{"name":"Java","slug":"Java","permalink":"http://www.010101.cc/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.010101.cc/tags/JVM/"}]},{"title":"数据结构Btree之Mysql自顶向下","slug":"数据结构Btree之Mysql自顶向下","date":"2021-11-11T07:04:04.000Z","updated":"2021-11-11T15:40:05.573Z","comments":true,"path":"2021/11/11/数据结构Btree之Mysql自顶向下/","link":"","permalink":"http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/","excerpt":"","text":"M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析Wirte by 021.","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"树结构","slug":"树结构","permalink":"http://www.010101.cc/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"}]},{"title":"内核之线程与进程的关系","slug":"E_Process","date":"2021-11-10T07:15:06.000Z","updated":"2021-11-10T12:33:50.091Z","comments":true,"path":"2021/11/10/E_Process/","link":"","permalink":"http://www.010101.cc/2021/11/10/E_Process/","excerpt":"","text":"线程与进程关系 进程是资源集合，提供cr3的值，cr3是页目录表的基址，cr3确定了，线程才能访问. 一个进程有多个线程，但至少有一个线程。 11，进程提供了空间上概念,进程提供了线程哪些空间地址可以访问的逻辑。 创建进程： 通过线程如何找到进程： 12345678910111213141516171819202122232425262728* thread -&gt; cr3页面 -&gt; _Kprocess 的指针假如线程执行：mov eax,dword ptr ds:[0x12345678]cpu的解析路径： 1，线程拿到当前进程的 cr3 值 Kprocess_directoryTableBase(+0x018) 2，通过cr3的寄存器页表目录定位物理页3,EThread结构体：&#123; 0x000 KThread 结构体 &#123; 0x034 _KAPC_STAT &#123; 0x10 ptr32 EPROCESS; 0x044 , cmp [esi, prt* process] #SWapContext时会比较 44 和 220 的值是否一样，不一样会造成进程空间切换，cr3切换，详情见进程挂靠 #44位置上提供是cr3的值，资源提供方的值 &#125; &#125; 0x220 ptr32 EPROCESS #当前线程所属进程，当前线程是谁创建的&#125;","categories":[{"name":"操作系统内核","slug":"操作系统内核","permalink":"http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"进程&线程","slug":"进程-线程","permalink":"http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}]},{"title":"高并发之CAS自顶向下","slug":"高并发之CAS自顶向下","date":"2021-11-10T07:15:06.000Z","updated":"2021-11-10T08:32:07.798Z","comments":true,"path":"2021/11/10/高并发之CAS自顶向下/","link":"","permalink":"http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/","excerpt":"","text":"高并发之CAS自顶向下Wirte by 021. 机器级代码 计算机系统使用了多种不同形式的抽象，可以通过一个简单的抽象模型来隐藏实现细节。对于机器级别的程序来说，有两点非常重要。 首先第一点，定义机器级别程序的格式和行为被称为 指令集体系结构或指令集架构(instruction set architecture)， ISA。ISA 定义了进程状态、指令的格式和每一个指令对状态的影响。大部分的指令集架构包括 ISA 用来描述进程的行为就好像是顺序执行的，一条指令执行结束后，另外一条指令再开始。处理器硬件的描述要更复杂，它可以同时并行执行许多指令，但是它采用了安全措施来确保整体行为与 ISA 规定的顺序一致。 第二点，机器级别对内存地址的描述就是 虚拟地址(virtual address)，它提供了一个内存模型来表示一个巨大的字节数组。 编译器在整个编译的过程中起到了至关重要的作用，把 C 语言转换为处理器执行的基本指令。汇编代码非常接近于机器代码，只不过与二进制机器代码相比，汇编代码的可读性更强，所以理解汇编是理解机器工作的第一步。 一些进程状态对机器可见，但是 C 语言程序员却看不到这些，包括 程序计数器(Program counter)，它存储下一条指令的地址，在 x86-64 架构中用 %rip 来表示。 程序执行时，PC 的初始值为程序第一条指令的地址，在顺序执行程序时， CPU 首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 并指向下一条要执行的指令。 比如下面一个例子。 这是一段数值进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。由于使用机器语言难以描述，所以这是经过翻译后的结果，实际上每个指令和数据都可能分布在不同的地址上，但为了方便说明，把组成一条指令的内存和数据放在了一个内存地址上。 整数寄存器文件(register file)包含 16 个命名的位置，用来存储 64 位的值。这些寄存器可以存储地址和整型数据。有些寄存器用于跟踪程序状态，而另一些寄存器用于保存临时数据，例如过程的参数和局部变量，以及函数要返回的值。这个 文件 是和磁盘文件无关的，它只是 CPU 内部的一块高速存储单元。有专用的寄存器，也有通用的寄存器用来存储操作数。 条件码寄存器 用来保存有关最近执行的算术或逻辑指令的状态信息。这些用于实现控件或数据流中的条件更改，例如实现 if 和 while 语句所需的条件更改。我们都学过高级语言，高级语言中的条件控制流程主要分为三种：顺序执行、条件分支、循环判断三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。 顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。 条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。 下面以条件分支为例来说明程序的执行过程（循环也很相似） 程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序+1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 if() 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。 一组 向量寄存器用来存储一个或者多个整数或者浮点数值，向量寄存器是对一维数据上进行操作。 机器指令只会执行非常简单的操作，例如将存放在寄存器的两个数进行相加，把数据从内存转移到寄存器中或者是条件分支转移到新的指令地址。编译器必须生成此类指令的序列，以实现程序构造，例如算术表达式求值，循环或过程调用和返回 认识汇编 我相信各位应该都知道汇编语言的出现背景吧，那就是二进制表示数据，太复杂太庞大了，为了解决这个问题，出现了汇编语言，汇编语言和机器指令的区别就在于表示方法上，汇编使用操作数来表示，机器指令使用二进制来表示，我之前多次提到机器码就是汇编，你也不能说我错，但是不准确。 但是汇编适合二进制代码存在转换关系的。 汇编代码需要经过 汇编器 编译后才产生二进制代码，这个二进制代码就是目标代码，然后由链接器将其连接起来运行。 汇编语言主要分为以下三类 汇编指令：它是一种机器码的助记符，它有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号，比如 +、-、*、/ 等，由编译器识别，没有对应的机器码 汇编语言的核心是汇编指令，而我们对汇编的探讨也是基于汇编指令展开的。 与汇编有关的硬件和概念 CPU CPU 是计算机的大脑，它也是整个计算机的核心，它也是执行汇编语言的硬件，CPU 的内部包含有寄存器，而寄存器是用于存储指令和数据的，汇编语言的本质也就是 CPU 内部操作数所执行的一系列计算。 内存 没有内存，计算机就像是一个没有记忆的人类，只会永无休止的重复性劳动。CPU 所需的指令和数据都由内存来提供，CPU 指令经由内存提供，经过一系列计算后再输出到内存。 磁盘 磁盘也是一种存储设备，它和内存的最大区别在于永久存储，程序需要在内存装载后才能运行，而提供给内存的程序都是由磁盘存储的。 总线 一般来说，内存内部会划分多个存储单元，存储单元用来存储指令和数据，就像是房子一样，存储单元就是房子的门牌号。而 CPU 与内存之间的交互是通过地址总线来进行的，总线从逻辑上分为三种 地址线 数据线 控制线 CPU 与存储器之间的读写主要经过以下几步 读操作步骤 CPU 通过地址线发出需要读取指令的位置 CPU 通过控制线发出读指令 内存把数据放在数据线上返回给 CPU 写操作步骤 CPU 通过地址线发出需要写出指令的位置 CPU 通过控制线发出写指令 CPU 把数据通过数据线写入内存 下面我们就来具体了解一下这三类总线 地址总线 通过我们上面的探讨，我们知道 CPU 通过地址总线来指定存储位置的，地址总线上能传送多少不同的信息，CPU 就可以对多少个存储单元进行寻址。 上图中 CPU 和内存中间信息交换通过了 10 条地址总线，每一条线能够传递的数据都是 0 或 1 ，所以上图一次 CPU 和内存传递的数据是 2 的十次方。 所以，如果 CPU 有 N 条地址总线，那么可以说这个地址总线的宽度是 N 。这样 CPU 可以寻找 2 的 N 次方个内存单元。 数据总线 CPU 与内存或其他部件之间的数据传送是由数据总线来完成的。数据总线的宽度决定了 CPU 和外界的数据传输速度。8 根数据总线可以一次传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可以传输两个字节，32 根数据总线可以一次传输四个字节。。。。。。 控制总线 CPU 与其他部件之间的控制是通过 控制总线 来完成的。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部部件的控制能力。 一次内存的读取过程 内存结构 内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图 图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，**+5V** 表示1，****0V 表示 0。 我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = 1024个地址。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。 如果我们使用的是 512 MB 的内存，这就相当于是 512000（512 * 1000） 个内存 IC。当然，一台计算机不太可能有这么多个内存 IC ，然而，通常情况下，一个内存 IC 会有更多的引脚，也就能存储更多数据。 内存读取过程 下面是一次内存的读取过程。 来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的： 首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 A0 - A9 来指定数据的存储场所，然后再把数据的值输入给 D0 - D7 的数据信号，并把 WR（write）的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据 读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。 图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。 CAS原子性操作之汇编“最轻量级的锁”,通常也叫”原子操作”,之所以加引号是因为他们在汇编级别并不是原子操作,是用多条指令完成的,这些操作大多都是利用CPU支持的汇编指令.在某些构架过时的CPU体系结构上,它们应该是用比较重量级的线程内锁实现的吧(我的猜测). 最常见的原子操作有Compare and Exchange,Self Increase/Decrease等等 80486 CPU****相关指令： LOCK:这是一个指令前缀，在所对应的指令操作期间使此指令的目标操作数指定的存储区域锁定，以得到保护。 XADD:先交换两个操作数的值，再进行算术加法操作。多处理器安全，在80486及以上CPU中支持。 CMPXCHG:比较交换指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上CPU中支持。 XCHG:交换两个操作数,其中至少有一个是寄存器寻址.其他寄存器和标志位不受影响. 80486以上都支持这四个操作,因此当今几乎100%CPU都支持这两个指令,也能由此用标准C和C++写出一系列几乎可以跨平台的”原子操作”函数和Lock-Free数据结构和算法. 64位平台也有一系列的相关指令,当然他们也有以上提到的指令,其下的64位原子操作函数应该和32位的分开(要问为什么?我现在告诉你恐怕你印象不深,接着看这一系列吧),而道理完全一样.因此,不存在跨CPU体系结构的问题) “原子操作”**函数:** 由以上提供的几个汇编指令,我们可以做出以下实现,这些都是最常用的原语. 比较后交换 long __stdcall CompareExchange(long volatile*Destination,long Exchange,long Comperand) { __asm { mov ecx, Destination; mov edx, Exchange; mov eax, Comperand; lock cmpxchg [ecx], edx; } } 交换 long __stdcall Exchange(long volatile* Target,long Value) { __asm { mov ecx, Target; mov edx, Value; label: lock cmpxchg [ecx], edx;//加 jnz short label; } } 自减 long __stdcall Decrement(long volatile* Addend) { __asm { mov ecx, Addend; mov eax, 0FFFFFFFFh;//-1 lock xadd [ecx], eax; //加-1 dec eax; } } 自增 long __stdcall Increment(long volatile* Addend) { __asm { mov ecx, Addend; mov eax, 1; lock xadd [ecx], eax; //加 inc eax; } } 相加后交换 long __stdcall ExchangeAdd(long volatile* Addend,long Value) { __asm { mov ecx, Addend; mov eax, Value; lock xadd [ecx], eax; } } 原子操作(2) - 泛型后的原子操作 32位的数据类型有4种,但是上面的只支持long,怎么办?手工hack?太土了,当然是C++的大规模杀伤性武器template了. 同时把几个不跨平台的地方抽出来用macro表示. 目前模板还没有得到concept的支持,所以只能用boost.type_traits低级的手动判断,要求只有32位的整数类型才能实例化这些函数. #include #include #define CALL_METHOD __stdcall #define VOLATILE volatile template&lt;typename **T**&gt; T CALL_METHOD compare_exchange32(T VOLATILE*Destination,T exchange32,T Comperand) { BOOST_STATIC_ASSERT(sizeof(T) == 4 &amp;&amp; boost::is_integral&lt;**T**&gt;::value); __asm { mov ecx, Destination; mov edx, exchange32; mov eax, Comperand; lock cmpxchg [ecx], edx; } } template&lt;typename **T**&gt; T CALL_METHOD exchange32(T VOLATILE* Target,T Value) { BOOST_STATIC_ASSERT(sizeof(T) == 4 &amp;&amp; boost::is_integral&lt;**T**&gt;::value); __asm { // mov ecx, Target; // mov edx, Value; //label: // lock cmpxchg [ecx], edx;//加 // jnz short label; mov ecx, Target; mov eax, Value; xchg [ecx],eax; } } template&lt;typename **T**&gt; T CALL_METHOD decrement32(T VOLATILE* Addend) { BOOST_STATIC_ASSERT(sizeof(T) == 4 &amp;&amp; boost::is_integral&lt;**T**&gt;::value); __asm { mov ecx, Addend; mov eax, 0FFFFFFFFh;//-1 lock xadd [ecx], eax; //加-1 dec eax; } } template&lt;typename **T**&gt; T CALL_METHOD increment32(T VOLATILE* Addend) { BOOST_STATIC_ASSERT(sizeof(T) == 4 &amp;&amp; boost::is_integral&lt;**T**&gt;::value); __asm { mov ecx, Addend; mov eax, 1; lock xadd [ecx], eax; //加 inc eax; } } template&lt;typename **T**&gt; T CALL_METHOD exchange_add32(T VOLATILE* Addend,T Value) { BOOST_STATIC_ASSERT(sizeof(T) == 4 &amp;&amp; boost::is_integral&lt;**T**&gt;::value); __asm { mov ecx, Addend; mov eax, Value; lock xadd [ecx], eax; } }","categories":[{"name":"操作系统内核","slug":"操作系统内核","permalink":"http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"并发原子锁","slug":"并发原子锁","permalink":"http://www.010101.cc/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"}]},{"title":"线程等待与唤醒之win32内核浅析","slug":"线程等待与唤醒","date":"2021-11-10T07:15:06.000Z","updated":"2021-11-10T12:36:55.347Z","comments":true,"path":"2021/11/10/线程等待与唤醒/","link":"","permalink":"http://www.010101.cc/2021/11/10/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92/","excerpt":"","text":"线程唤醒与等待等待对象 伪代码 解释 基于win32 等待对象 与 当前线程 ，被等待对象的关系. 12345678910111213141516171819202122232425262728//被等待对象1int Thread &#123; int a = 0; return a++;&#125;//被等待对象2int Thread1 &#123; int a = 0; return a++;&#125;//当前主线程 void main(...)&#123; //被等待对象 int a Thead.t1.start; int a1 = Thead1.t1.start; 解析 -&gt; 等待对象 waitingforSinglObject(arr[t1,t2],xx); 只有等待： 等待对象中的被等待对象t1和t2执行完后，当前main线程才能继续执行. printf(...);&#125; 逻辑步骤-TODO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859WaitForSingleObject调用内核函数NtWaitForObject,NtWaitForObject 调用ObReferenceObjectByHandle,通过当前线程对象句柄找到&#x27;等待对象结构体&#x27;的首地址将结构体首地址传递给 KeWaitSingleObjectKeWaitSingleObject 步骤：1，准备等待块._wait_block; 默认初始4个等待块 ..... 这块内核比较复杂黑盒,todo被等待对象：必须具备_DISPATCHER_HEADER属性的对象，_DISPATCHER_HEADER结构体&#123; ... ... +0x004 SingleStat; 信号状态 &gt; 0; +0x008 WaitListHead; 所有等待块双向链表地址. &#125;内部处理逻辑伪代码:while(1)&#123; if(符合条件) // 1,符合超时条件， 等待对象的信号量 &gt; 0; &#123; 1，修改等待对象的singleStat; 2,退出循环 &#125; else &#123; if(不符合条件) // 超时并且被等待对象 !&gt;0; &#123; if(第一次执行) &#123; &#125; &#125; &#125; // 将waitingblockList 位置清0; //释放_kwait_block等待块内存.&#125;","categories":[{"name":"操作系统内核","slug":"操作系统内核","permalink":"http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"进程&线程","slug":"进程-线程","permalink":"http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}]},{"title":"高并发之硬件MESI缓存一致性协议与CPU屏障浅析","slug":"高并发之硬件缓存一致性与CPU屏障浅析","date":"2021-11-10T07:15:06.000Z","updated":"2021-11-11T08:32:18.875Z","comments":true,"path":"2021/11/10/高并发之硬件缓存一致性与CPU屏障浅析/","link":"","permalink":"http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%A1%AC%E4%BB%B6%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8ECPU%E5%B1%8F%E9%9A%9C%E6%B5%85%E6%9E%90/","excerpt":"","text":"高并发之硬件MESI缓存一致性协议与CPU屏障​ Wirte by 021. MESI缓存一致性协议 cache line是cache与内存数据交换的最小单位，根据操作系统一般是32byte或64byte。在MESI协议中，状态可以是M、E、S、I，地址则是cache line中映射的内存地址，数据则是从内存中读取的数据。 状态介绍 MESI协议将cache line的状态分成modify、exclusive、shared、invalid，分别是修改、独占、共享和失效。 modify：当前CPU cache拥有最新数据（最新的cache line），其他CPU拥有失效数据（cache line的状态是invalid），虽然当前CPU中的数据和主存是不一致的，但是以当前CPU的数据为准； exclusive：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的； shared：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致； invalid：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的； 对于invalid而言，在MESI协议中采取的是写失效（write invalidate）。 cache操作 MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），每个核心的缓存控制器通过监听也知道其他CPU中cache的操作（remote read和remote write），今儿再确定自己cache中共享数据的状态是否需要调整。 local read（LR）：读本地cache中的数据； local write（LW）：将数据写到本地cache； remote read（RR）：其他核心发生read； remote write（RW）：其他核心发生write； CPU内存保证 通常情况下，在代码被正常编译成机器码后，在汇编代码级别不加lock 原子指令情况下，代码也会产生乱序，编译器会优化代码，调整执行顺序，如果需要执行强代码一致性需要加上CPU内存屏蔽代码; final int a =0 这行代码在编译器编译成机器码时会加内存屏障，防止重排序. 12345678910#TODOsfence :ifence :mfence :","categories":[{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://www.010101.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"并发原子锁","slug":"并发原子锁","permalink":"http://www.010101.cc/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"}]},{"title":"win32 之 PE文件结构解读","slug":"win32之PE文件","date":"2021-11-10T06:44:58.000Z","updated":"2021-11-10T06:48:40.804Z","comments":true,"path":"2021/11/10/win32之PE文件/","link":"","permalink":"http://www.010101.cc/2021/11/10/win32%E4%B9%8BPE%E6%96%87%E4%BB%B6/","excerpt":"","text":"PE文件结构 Windows : PE (Portable Excuteable) 文件结构 Linux : ELF(Executable and linking formate) 文件结构 PE 文件特征和格式 执行二进制文件转16进制后，前2个字节是MZ, 3C位置值，再往下找3C位置的字节值会显示PE. 可判定为PE. PE文件结构排列DOS + PE文件头 + 字表 + 字节数 dos文件头 MZ头 ：64byte + 20byte PE_header + 节表section_header 40byte + option_header 224byte节数据 内存拉升： PE文件在硬盘中200倍拉升， 在内存中1000倍拉升，空间扩充.","categories":[{"name":"操作系统内核","slug":"操作系统内核","permalink":"http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"PE可执行文件","slug":"PE可执行文件","permalink":"http://www.010101.cc/tags/PE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"}]},{"title":"线程切换之内核E_thead浅析","slug":"E_Thread","date":"2021-11-10T06:44:58.000Z","updated":"2021-11-10T08:13:32.529Z","comments":true,"path":"2021/11/10/E_Thread/","link":"","permalink":"http://www.010101.cc/2021/11/10/E_Thread/","excerpt":"","text":"Wirte by 021. E_Thread 线程结构体 123456789101112131415161718192021结构体&#123; 线程名称 线程状态 堆栈起始地址 线程堆栈界限 （终止地址） 线程当前位置 ESP 线程函数参数 线程函数地址&#125;线程结构体数组0 --- 当前线程 ，main1 --- 创建的新线程 线程状态不同存储 123456正在运行线程 --- kpcr等待线程 --- 等待链表就绪/调度线程 --- 32个链表 线程的生命周期 创建 — 初始化线程堆栈 123456789101112131415161，结构体初始化赋值2，执行体，函数，参数，赋值3，创建堆栈，申请堆栈 stackpage , 0x80000 大小，4，堆栈初始化，起始地址、5，设定堆栈边界值（终止地址）6， 入栈7, kernelStack 栈顶 赋值，esp 赋值。kernelStack = 入栈对象 （1-6） 线程调度 12345 线程切换 SwapContext 线程不是被动切换，而是主动切换。 意思是，无论是时间片到了的被动切换，还是线程IO阻塞主动出让执行权，都需要当前线程调用切换线程函数. 线程没有使用TSS保存寄存器，而是使用堆栈. 线程切换过程就是堆栈切换过程. 在线程切换过程中，会判断2个线程是否属于同一个进程，如果不是，就切换cr3页面，也就是进程空间也切换了. ​ TheadSwap 1234567参数 ： 1，当前线程(esp)地址， 2，将要被切换线程(edi)地址步骤： 1，保存当前线的栈顶，上图的push操作. 2，将当前线程（esp）地址，存储到KernelStack中 --- mov [esi kernelStack] ,esp 3，将内核中 将要被切换edi线程 的地址，交换到当前位置 --- mov esp, [edi kernelStack] 主动切换 1取出当前CPU kpcr正在执行的线程放到edi中 线程中断 时钟中断 线程中断条件 1231.时间片到期2，备用线程（KPCR.PrcbData.nextThread）3，主动调用切换切换线程函数，KiswapThread CPU时间片 123451，KPROCESS.ThreadQuantum 值是当前进程设置的时间片值2，_KTHREAD.ThreadQuantum 会读取 KPROCESS.ThreadQuantum的值，在线程初始化的时候在win32里面初始为6,每次中断会调用KeupdateRuntime函数会将当前线程_KTHREAD.ThreadQuantum - 3，如果减到0，则将KPCR.PrcbData.QuantumEnd 位 置为 非0，表示当前线程时间片到期. Tss 内核堆栈 12345initStack 栈底kernelStack 栈顶stackLimte 边界TSS.esp0得到当前线程0环堆栈，线程在切换的时候保证0环线程堆栈的唯一和有序性. 异常中断 1INT N， 页面异常 如何永久占用CPU? 1满足 不调用API , 并且不会出现异常，并调用cli指令，屏蔽时间中断，CPU就会忽略时钟片中断. 线程优先级 线程调度链表 1234532个线程调度双向链表。KiFindReadyThread 查找方式： 先找 31 ... 30 .. 29, 优先查找高级别的。32位:0 1 0 1 0 0 0 0 ... 0 ， 31位上为1，证明当前有优先级的线程需要处理。当调度链表中没有任何需要调度执行的任务时，cpu会执行idelThread.","categories":[{"name":"操作系统内核","slug":"操作系统内核","permalink":"http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"进程&线程","slug":"进程-线程","permalink":"http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}]},{"title":"CPU内核模块之KPCR","slug":"博客模板KPCR","date":"2021-11-10T06:44:58.000Z","updated":"2021-11-10T06:49:08.943Z","comments":true,"path":"2021/11/10/博客模板KPCR/","link":"","permalink":"http://www.010101.cc/2021/11/10/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BFKPCR/","excerpt":"","text":"github 访问慢，而其他网页正常.Mac 修改hosts文件12345678910111213141516171819202122232425262728293031Step 1. cd /etc/Step 2. sudo vi hosts# 粘贴140.82.112.4 github.com140.82.113.3 gist.github.com185.199.108.153 assets-cdn.github.com199.232.68.133 raw.githubusercontent.com199.232.68.133 gist.githubusercontent.com199.232.68.133 cloud.githubusercontent.com151.101.192.133 camo.githubusercontent.com199.232.68.133 avatars0.githubusercontent.com199.232.68.133 avatars1.githubusercontent.com199.232.68.133 avatars2.githubusercontent.com199.232.68.133 avatars3.githubusercontent.com199.232.68.133 avatars4.githubusercontent.com199.232.68.133 avatars5.githubusercontent.com199.232.68.133 avatars6.githubusercontent.com199.232.68.133 avatars7.githubusercontent.com199.232.68.133 avatars8.githubusercontent.com","categories":[{"name":"测试分类","slug":"测试分类","permalink":"http://www.010101.cc/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"http://www.010101.cc/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]},{"title":"JVM之Java类加载与自定义加载热更新","slug":"JVM之classLoader浅析","date":"2021-11-10T06:44:58.000Z","updated":"2021-11-11T07:41:22.126Z","comments":true,"path":"2021/11/10/JVM之classLoader浅析/","link":"","permalink":"http://www.010101.cc/2021/11/10/JVM%E4%B9%8BclassLoader%E6%B5%85%E6%9E%90/","excerpt":"","text":"Java类加载器浅析.java 文件生命周期1.java -&gt; javac编译 -&gt; Jvm加载classloader -&gt; Jvm连接[验证，准备，解析] -&gt; 准备初始化（常量变量等内存分配过程）-&gt; GC 类加载器 双亲委派含义与功能简单分析 123456781，Bootstrap ClassLoader 启动类加载器 主要负责加载Java核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。2，Extention ClassLoader 标准扩展类加载器 主要负责加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。3，Application ClassLoader 应用类加载器 主要负责加载当前应用的classpath下的所有类4，User ClassLoader 用户自定义类加载器 用户自定义的类加载器,可加载指定路径的class文件上面是Java中提供的4类加载器，每个加载器负责不同层次的class文件加载功能。 双亲委派的含义 123456 双亲委派是java为了保护程序稳定性，防止字节码重复加载，或者加载不安全的class文件的一种机制，机制规范了Java中四种加载器的加载class的范围. 当一个java收到一个类加载请求的时候，不会立刻执行当前类的加载函数，而是将加载任务抛给父类加载器，父类的加载器不是继承的，而是引用父类的加载器，从而达到加载扫描的作用，如果父类已经加载了该类，当前加载函数不会重复加载，负责将由父类加载。 当使用 类.class.getClassloader的时候返回null的时候，表明已经是顶层加载器， 否则返回的就是父类加载器地址. 双亲委派的功能 防止重复加载 防止加载不安全的class文件，比如用户自定义Long类然后加载进去，此时顶层加载器Bootstrap ClassLoader已经加载过一遍了，此时父加载器为空，所以自定义的Long类不会被加载，从而达到保证安全性的效果. ​ 自定义classLoader, 重写findClass方法 定义加载路径 defind 解释 二进制 转换 class. findClass 找到自定义的class 转换 class 为目标类. 扩展 可以加密class文件，更安全 ClassLoader加载过程源码 12345678910111213141516171819202122232425262728293031323334353637383940414243protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); // 当父类没有加载，自定义加载函数 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 热更新： 摘抄一段网上示例的代码,实现了，文件更改后，类的卸载和重新加载","categories":[{"name":"Java","slug":"Java","permalink":"http://www.010101.cc/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.010101.cc/tags/JVM/"}]},{"title":"github访问慢，而其他网页正常解决","slug":"github 访问慢，而其他网页正常","date":"2021-11-08T14:04:58.000Z","updated":"2021-11-10T06:54:04.831Z","comments":true,"path":"2021/11/08/github 访问慢，而其他网页正常/","link":"","permalink":"http://www.010101.cc/2021/11/08/github%20%E8%AE%BF%E9%97%AE%E6%85%A2%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%BD%91%E9%A1%B5%E6%AD%A3%E5%B8%B8/","excerpt":"","text":"github 访问慢，而其他网页正常.Mac 修改hosts文件123456789101112131415161718192021222324Step 1. cd /etc/Step 2. sudo vi hosts# 粘贴140.82.112.4 github.com140.82.113.3 gist.github.com185.199.108.153 assets-cdn.github.com199.232.68.133 raw.githubusercontent.com199.232.68.133 gist.githubusercontent.com199.232.68.133 cloud.githubusercontent.com151.101.192.133 camo.githubusercontent.com199.232.68.133 avatars0.githubusercontent.com199.232.68.133 avatars1.githubusercontent.com199.232.68.133 avatars2.githubusercontent.com199.232.68.133 avatars3.githubusercontent.com199.232.68.133 avatars4.githubusercontent.com199.232.68.133 avatars5.githubusercontent.com199.232.68.133 avatars6.githubusercontent.com199.232.68.133 avatars7.githubusercontent.com199.232.68.133 avatars8.githubusercontent.com","categories":[],"tags":[{"name":"常见问题解决","slug":"常见问题解决","permalink":"http://www.010101.cc/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}]},{"title":"免主机，免备案，从0到1教你搭建个人博客(hexo + github page)！","slug":"github+hexo","date":"2021-11-08T14:04:58.000Z","updated":"2021-11-09T04:46:22.987Z","comments":true,"path":"2021/11/08/github+hexo/","link":"","permalink":"http://www.010101.cc/2021/11/08/github+hexo/","excerpt":"","text":"原理简介：1.github page 提供服务和博客文档云端托管2.hexo提供博客页面模板引擎（负责加载md文档并引用渲染到博客主页）3.md编辑器负责本地编辑博客内容4.git客户端负责push文档到github托管.5.github page 负责显示推送的最新内容环境准备以Mac机器为操作环境, 安装步骤本篇不作讲解.NodeJs12node -vv12.13.1 Hexo12345678910111213141516171819202122hexo versionINFO Validating confighexo: 5.4.0hexo-cli: 4.3.0os: darwin 20.6.0 11.6node: 12.13.1v8: 7.7.299.13-node.16uv: 1.33.1zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 72nghttp2: 1.39.2napi: 5llhttp: 1.1.4http_parser: 2.8.0openssl: 1.1.1dcldr: 35.1icu: 64.2tz: 2019cunicode: 12.1 Git客户端12git --versiongit version 2.23.0 MarkDown 编辑器1博主安装的是 typora. 操作部署步骤1. 总流程步骤123456789101112131415161718191,新建博客文档文件夹 ,博主是在桌面 /desktopmkdir blog2,初始化bloghexo init blog3, 编译环境hexo g4, 本地查看效果hexo s5, 部署githubhexo d6, 清除本地缓存hexo clean 2. hexo配置文件环境介绍123456789101112# hexo 配置文件，负责博客主题样式加载引导/blog/_config.yml# themes 博客主题文件夹 负责存储主题文件/blog/themes# public 此文件是对外开放的博客文件，也是推送github的文件/blog/public# 资源文件夹 ，负责你写的博客内容给主页加载的md部分，也可以CNAME放在其中这样Push不会被覆盖/blog/source ​","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://www.010101.cc/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://www.010101.cc/categories/Java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"操作系统内核","slug":"操作系统内核","permalink":"http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"},{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://www.010101.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"},{"name":"测试分类","slug":"测试分类","permalink":"http://www.010101.cc/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.010101.cc/tags/JVM/"},{"name":"树结构","slug":"树结构","permalink":"http://www.010101.cc/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"},{"name":"进程&线程","slug":"进程-线程","permalink":"http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"并发原子锁","slug":"并发原子锁","permalink":"http://www.010101.cc/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"},{"name":"PE可执行文件","slug":"PE可执行文件","permalink":"http://www.010101.cc/tags/PE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"},{"name":"测试标签","slug":"测试标签","permalink":"http://www.010101.cc/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"},{"name":"常见问题解决","slug":"常见问题解决","permalink":"http://www.010101.cc/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"工具使用","slug":"工具使用","permalink":"http://www.010101.cc/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]}