<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.010101.cc/atom.xml" rel="self"/>
  
  <link href="http://www.010101.cc/"/>
  <updated>2021-11-19T19:25:54.161Z</updated>
  <id>http://www.010101.cc/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MacBook Pro intel日常使用问题记录</title>
    <link href="http://www.010101.cc/2021/11/20/MBP%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.010101.cc/2021/11/20/MBP%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-19T19:12:21.000Z</published>
    <updated>2021-11-19T19:25:54.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MacBook-Pro-蓝牙模块修复"><a href="#MacBook-Pro-蓝牙模块修复" class="headerlink" title="MacBook Pro 蓝牙模块修复"></a>MacBook Pro 蓝牙模块修复</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwl2cvhuagj30gw0migmt.jpg" alt="截屏2021-11-20 上午3.20.25"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul><li><p>按住键盘 ⌥ Option + ⇧ Shift 的同时，点击菜单栏中的 Bluetooth图标</p></li><li><p>在弹出的下拉菜单中选择「还原蓝牙模块」</p></li><li><p>确认继续操作.</p></li></ul><h2 id="MacBook-Pro-快捷键"><a href="#MacBook-Pro-快捷键" class="headerlink" title="MacBook Pro 快捷键"></a>MacBook Pro 快捷键</h2><h4 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h4><ul><li>Shift＋Command＋3 / Shift＋Command＋4</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MacBook-Pro-蓝牙模块修复&quot;&gt;&lt;a href=&quot;#MacBook-Pro-蓝牙模块修复&quot; class=&quot;headerlink&quot; title=&quot;MacBook Pro 蓝牙模块修复&quot;&gt;&lt;/a&gt;MacBook Pro 蓝牙模块修复&lt;/h2&gt;&lt;p&gt;Wirte </summary>
      
    
    
    
    <category term="工具使用" scheme="http://www.010101.cc/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具使用问题" scheme="http://www.010101.cc/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础之麻辣香锅</title>
    <link href="http://www.010101.cc/2021/11/20/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%BA%BB%E8%BE%A3%E9%A6%99%E9%94%85/"/>
    <id>http://www.010101.cc/2021/11/20/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%BA%BB%E8%BE%A3%E9%A6%99%E9%94%85/</id>
    <published>2021-11-19T19:08:02.000Z</published>
    <updated>2021-11-20T09:30:25.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言基础之麻辣香锅"><a href="#C语言基础之麻辣香锅" class="headerlink" title="C语言基础之麻辣香锅"></a>C语言基础之麻辣香锅</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="C代码示例"><a href="#C代码示例" class="headerlink" title="C代码示例"></a>C代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  Assembly</span><br><span class="line">//</span><br><span class="line">//  Created by 021 on 2021/11/14.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//int myOperation(int a, int b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    //整型</span><br><span class="line">    //-128 --- signed --- 0 --- unsigned --- 127；</span><br><span class="line">    char c = &#x27;a&#x27;; //1byet 0xff</span><br><span class="line">    short s = 0xffff; // 2byte 0xffff</span><br><span class="line">    int i = 0xffffffff; //4byte</span><br><span class="line">    long l = 0xffffffff; //4byte</span><br><span class="line">    printf(&quot;char : %c\n %d\n&quot;,c,c);</span><br><span class="line">    printf(&quot;short : %c\n %d\n&quot;,s,s);</span><br><span class="line">    printf(&quot;int i 无符号: %u\n int i 有符号: %d\n&quot;,i,i);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     *符号表示 , 编译器只关注数值存储，取数时有无符号有区别；默认有符号；</span><br><span class="line">     *大部分计算机只存补码， 符号位将影响取值和判断.</span><br><span class="line">     */</span><br><span class="line">    signed char sc = -1; // 1111 1111 0xff;  0000 0001 %u = 4294967295</span><br><span class="line">    unsigned char usc = -1; // 补码+1 = 1111 1111 , 0xff</span><br><span class="line">    unsigned char usc1 = -2; // 0000 0010 -&gt; 1111 1101 + 1 -&gt; 1111 1110 -&gt; 0xfe;</span><br><span class="line">    printf(&quot;sc有符号=%d,转换成无符号=%u\n&quot;,sc,(unsigned char)sc);</span><br><span class="line">    printf(&quot;sc 无符号数（扩展错误数值） ： %u\n&quot;,sc); //此时取值可能进行了扩展 ,%u = 4294967295</span><br><span class="line">    //有无符号之间转换</span><br><span class="line">    printf(&quot;无符号usc=%u,无符号转有符号usc=%d\n&quot;,usc,(char)usc);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *数据宽度扩展：低位为数据位， 高位为符号位</span><br><span class="line">     */</span><br><span class="line">     //将有符号8位char类型放入32位int类型，</span><br><span class="line">     int i1 = sc; // 1111 1111 -&gt; 0xffffff + 1111 1111 = 0xffffffff;</span><br><span class="line">    printf(&quot;有符号sc数据扩展int=%u,无符号转有符号=%d\n&quot;,i1,(int)i1);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     *数据宽度溢出</span><br><span class="line">     *溢出的值为正的：实际值为：溢出后的值 - 该类型能表示的立即数</span><br><span class="line">     *溢出的值为负的：实际值为：溢出后的值 + 该类型能表示的立即数</span><br><span class="line">     *其中-0的原码是：   1000 0000 补码是：1 0000 0000 = 128的由来，有点无厘头</span><br><span class="line">     */</span><br><span class="line">    //默认有符号，0xff的数据区间：有符号最小值：1111 1111 = -0x7f=-127; 最大值：0111 1111 = 0x7f =127;</span><br><span class="line">    char sc1 = 256; //将256存入 -127 — 127数据宽度区间 发生溢出</span><br><span class="line">    printf(&quot;数据宽度溢出sc1=%u\n&quot;,sc1); //256- 1111 1111 = 0；</span><br><span class="line">    char sc2 = -258;</span><br><span class="line">    printf(&quot;数据宽度溢出sc2=%d\n&quot;,sc2); //-257 + 1111 1111 = -2；</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *浮点类型</span><br><span class="line">     *float    1位（符号位）    8位（整数位）    23位（尾数位）</span><br><span class="line">     *double    1位（符号位）    11位（整数位）    52位（尾数位）</span><br><span class="line">     */</span><br><span class="line">    float f = 11.11f; // 0xffffffff;</span><br><span class="line">    double d = 22.22; // 0xffffffff ffffffff;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwllggtsu9j30u0074weu.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwllgk36qbj30u006jq3a.jpg" alt="img"></p><h3 id="精度概要"><a href="#精度概要" class="headerlink" title="精度概要"></a>精度概要</h3><ul><li><p><strong>对于float型浮点数，尾数部分23位，换算成十进制就是2^23=8388608，所以十进制精度只有6 ~ 7位；</strong></p></li><li><p><strong>对于double型浮点数，尾数部分52位，换算成十进制就是2^52 = 4503599627370496，所以十进制精度只有15 ~ 16位</strong></p></li></ul><pre><code>* **前景概要与演练**</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwlmoqt3m2j30xm0htmyh.jpg" alt="截屏2021-11-20 下午3.01.21"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 求十进制浮点数 ，求转换 12.34</span><br><span class="line">1 * 10¹ + 2*1（10零次方） + 3 * 1/10（10的负一次方）+ 4 * 1/10*10(10的负二次方)</span><br><span class="line">浮点数的规范后： 1.234 * 10¹ ; 指数为1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 二进制浮点转十进制 ，求转换 1100.11</span><br><span class="line">1 * 2*2*2（三次方） + 1 * 2*2(二次方) + 0 * 2(一次方) + 0 * 1(2的0次方) + 1 * 1/2¹ + 1 * 1/2*2(二次方)</span><br><span class="line">=  8 + 4 + 0 + 0 + 1/2 + 1/4</span><br><span class="line">=  12.75</span><br><span class="line">浮点数的规范后： 2.475 * 10¹; 指数为1;</span><br><span class="line"></span><br><span class="line">求 1010.01 的十进制，二进制浮点数规范后= 1.01001 * 2*2*2 指数: 3</span><br><span class="line">1 * 2*2*2 + 0 * 2*2 + 1 * 2 + 0 * 2(零次方) + 0 * 1/2¹ + 1 * 1/2²</span><br><span class="line">= 8 + 0 + 2 + 0 + 1/2 + 1/4</span><br><span class="line">= 10.75 </span><br><span class="line">10进制浮点数的规范后： 1.075 * 10¹; 指数为1;</span><br><span class="line"></span><br><span class="line">求 10101.01 的十进制，二进制浮点数规范后= 1.010101 * 2*2*2*2 指数: 4</span><br><span class="line">1 * 2*2*2*2 + 0 * 2*2*2 + 1 * 2*2 + 0 * 2 + 1 * 1（2的零次方）+ 0 * 1/2 + 1 * /2*2</span><br><span class="line">= 16 + 0 + 4 + 0 + 1 + 0 + 1/4</span><br><span class="line">= 21.25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="浮点数二进制存储表示"><a href="#浮点数二进制存储表示" class="headerlink" title="浮点数二进制存储表示"></a>浮点数二进制存储表示</h4><ul><li><p><strong>1，确定符号位</strong></p></li><li><p><strong>2，确定指数偏移量</strong></p></li><li><p><strong>3，对齐小数位并并0</strong></p></li></ul><h5 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h5><ul><li><p>0 正</p></li><li><p>1 负</p></li></ul><h5 id="指数位"><a href="#指数位" class="headerlink" title="指数位"></a>指数位</h5><ul><li><strong>按照127+指数偏移量得出二进制，填充进指数位，填充8位</strong></li></ul><h5 id="小数位"><a href="#小数位" class="headerlink" title="小数位"></a>小数位</h5><ul><li><strong>去掉 浮点规范后的 整数位，低位补0，补齐23位</strong></li></ul><ul><li><p><strong>那我们来测试一下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">简单点以5结尾的小数；</span><br><span class="line"></span><br><span class="line">求 123.25 的内存存储</span><br><span class="line"></span><br><span class="line">1. 首先求出二进制数（小规律，先求数据宽度区间最大数和最小数，然后依次取最大数填充，这样就不用计算器了）</span><br><span class="line">123 = 100 + 20 + 3 =   1 1  1 1  1 1 1 1  =  01??  +  ?1(确定最大最小数) </span><br><span class="line"> 128 64 32  16 8 4 2 1</span><br><span class="line"> </span><br><span class="line">= 64 + 3 ，还差56，继续填充 = 01 1(32) 1(16) 1(8)011 = 0111 1011; 最终整数部分;</span><br><span class="line"></span><br><span class="line">小数部分：结果01</span><br><span class="line">推出:</span><br><span class="line">0.25 * 2 ; 0</span><br><span class="line">0.50 * 2 ; 1</span><br><span class="line"></span><br><span class="line">整合: 0111 1011.01 , 浮点数规范 ： 1.11 1011 01 指数为8; （错误）</span><br><span class="line">整合: 0111 1011.01 , 浮点数规范 ： 1.111011 01 指数为6; (正确)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2,定义符号位：</span><br><span class="line">正数 = 0；</span><br><span class="line"></span><br><span class="line">3，定义指数位:</span><br><span class="line">127 + 8 = 135 = 1000 0111（错误）</span><br><span class="line">127 + 6 = 133 = 1000 0101 (正确)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4,定义尾数部分 ，去掉整数部分，低位补齐0，23位； 1.11101101 = 1110 1101；</span><br><span class="line"></span><br><span class="line">5，整合：</span><br><span class="line">0 + 1000 0111 + 1110 1101 = 0100 0011 1111 0110 1000 0000 0000 0000 = 0x43f68000; （错误）</span><br><span class="line">//纠错</span><br><span class="line">0 + 1000 0101 + 1110 1101 = 0100 0010 1111 0110 1000 0000 0000 0000 = 0x42f68000;（正确）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结果 和 程序运行有误差 ... 0x42F68000 这个才是正确的，找一下问题：</span><br><span class="line">整合: 0111 1011.01 , 浮点数规范 ： 1.11 1011 01 指数为8; （错误） 这里位移脑子抽了，计算失误. 还是计算机好...</span><br><span class="line"></span><br><span class="line">//到此 结果正确，</span><br><span class="line">0 + 1000 0101 + 1110 1101 = 0100 0010 1111 0110 1000 0000 0000 0000 = 0x42f68000;（正确）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="Switch算法"><a href="#Switch算法" class="headerlink" title="Switch算法"></a>Switch算法</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言基础之麻辣香锅&quot;&gt;&lt;a href=&quot;#C语言基础之麻辣香锅&quot; class=&quot;headerlink&quot; title=&quot;C语言基础之麻辣香锅&quot;&gt;&lt;/a&gt;C语言基础之麻辣香锅&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i m</summary>
      
    
    
    
    <category term="C语言" scheme="http://www.010101.cc/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://www.010101.cc/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>epoll之redis自顶向下</title>
    <link href="http://www.010101.cc/2021/11/17/epoll%E4%B9%8Bredis%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/17/epoll%E4%B9%8Bredis%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-17T04:16:39.000Z</published>
    <updated>2021-11-17T06:24:08.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Epoll-之-Redis-自行向下"><a href="#Epoll-之-Redis-自行向下" class="headerlink" title="Epoll 之 Redis 自行向下"></a>Epoll 之 Redis 自行向下</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwi12adr5aj30e808zgm0.jpg" alt="LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL | Byte_Liu&#39;s Blog"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwi0zuuv27j30gt0cbwf3.jpg" alt="Redis系统架构- 知乎"></p><h3 id="IO-进化史"><a href="#IO-进化史" class="headerlink" title="IO 进化史"></a>IO 进化史</h3><h4 id="BIO阻塞IO"><a href="#BIO阻塞IO" class="headerlink" title="BIO阻塞IO"></a>BIO阻塞IO</h4><ul><li><strong>Socket阻塞伪代码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//有1000个客户端读文件描述符的需求</span><br><span class="line">files waitRead = read(fd)*1000;</span><br><span class="line"></span><br><span class="line">1, file = read(waitRead[0]);</span><br><span class="line"></span><br><span class="line">2, if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">//do work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//单线程阻塞， 只能使用多线程处理, 每一条线程处理一个文件描述符的读取系统调用</span><br><span class="line"></span><br><span class="line">new Thread(</span><br><span class="line"></span><br><span class="line">files waitRead = read(fd)*1000;</span><br><span class="line"></span><br><span class="line">1, file = read(waitRead[0]);</span><br><span class="line"></span><br><span class="line">2, if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">//do work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">).start();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="NIO同步非阻塞"><a href="#NIO同步非阻塞" class="headerlink" title="NIO同步非阻塞"></a>NIO同步非阻塞</h4><ul><li>同步非阻塞伪代码模拟**</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//有1000个读文件描述符的需求</span><br><span class="line">read(int fd) * 1000;</span><br><span class="line"></span><br><span class="line">for(;;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(1000 * fd)        // 用户空间 系统调用轮询1000次， </span><br><span class="line">&#123;</span><br><span class="line">file = read(fd1~fd1000);   //轮询读取每一个fd文件描述符，不管数据有没有准备好</span><br><span class="line"></span><br><span class="line">if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">// do work....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Select（多路复用）"><a href="#Select（多路复用）" class="headerlink" title="Select（多路复用）"></a>Select（多路复用）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//有1000个读文件描述符的需求</span><br><span class="line">read(int fd) * 1000;</span><br><span class="line"></span><br><span class="line">//select 系统调用函数， 一次性传输多个文件描述符传输给内核，返回准备好的文件描述;</span><br><span class="line">select(fd*1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file fds = select(fd*1000);    // 系统调用，内核返回准备好的文件的描述符</span><br><span class="line">for( 0;fds; )         // 用户空间遍历内核返回的全部文件描述符，</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(fd.readAble)              //检测文件可读状态</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">file = read(fd);        </span><br><span class="line">if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">// do work....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul><li><p><strong>模拟内核 和 用户 共享空间逻辑</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模拟原始内存空间：</span><br><span class="line"></span><br><span class="line">0xffffffff ------------用户空间-------------0x80000000 ------------内核空间------------ 0x00000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模拟共享空间：   //用户与内核 映射 同一块物理空间</span><br><span class="line"></span><br><span class="line">0xffffffff ---------用户空间---------[0x80000000 ---共享空间--- 0x700000000 ]------内核空间----- 0x00000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 共享空间容器</span><br><span class="line">1，红黑树 - 等待读取的文件描述符 ,btree;</span><br><span class="line">2，链表 - 准备好的文件描述符  , readyLinkList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">btree.add(epoll.creat(fd));   // 将待读取的文件描述符 放入共享空间的红黑树.</span><br><span class="line"></span><br><span class="line">file = read(readyLinkList(fd));    //读取 共享空间 链表容器 已准备好的文件描述符；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="redis-单进程-单线程-为什么快？"><a href="#redis-单进程-单线程-为什么快？" class="headerlink" title="redis 单进程 单线程 为什么快？"></a>redis 单进程 单线程 为什么快？</h4><ul><li><strong>如何保证顺序性？</strong><ul><li><strong>每个连接</strong></li><li></li></ul></li></ul><ul><li><strong>sendfile 零拷贝</strong></li><li></li></ul><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Epoll-之-Redis-自行向下&quot;&gt;&lt;a href=&quot;#Epoll-之-Redis-自行向下&quot; class=&quot;headerlink&quot; title=&quot;Epoll 之 Redis 自行向下&quot;&gt;&lt;/a&gt;Epoll 之 Redis 自行向下&lt;/h2&gt;&lt;p&gt;Wirte </summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="Redis" scheme="http://www.010101.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>WIN32之保护模式</title>
    <link href="http://www.010101.cc/2021/11/15/WIN32%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.010101.cc/2021/11/15/WIN32%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-15T11:42:37.000Z</published>
    <updated>2021-11-16T03:40:44.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java编译器浅析"><a href="#Java编译器浅析" class="headerlink" title="Java编译器浅析"></a>Java编译器浅析</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><h3 id="段-寄存器"><a href="#段-寄存器" class="headerlink" title="段 寄存器"></a>段 寄存器</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwguaroxt1j30co0daaao.jpg" alt="汇编-8086内部寄存器+对段寄存器使用的约定- 二十一点关机- 博客园"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwg2x5gwpjj30ww0hkab1.jpg" alt="image-20211115195319374"></p><ul><li>Selector</li><li>Attribute</li><li>Base</li><li>Limit</li></ul><h4 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h4><h4 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h4><h4 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h4><h4 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h4><h4 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h4><h4 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h4><h4 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h4><h4 id="TR"><a href="#TR" class="headerlink" title="TR"></a>TR</h4><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java编译器浅析&quot;&gt;&lt;a href=&quot;#Java编译器浅析&quot; class=&quot;headerlink&quot; title=&quot;Java编译器浅析&quot;&gt;&lt;/a&gt;Java编译器浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messe</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编基础</title>
    <link href="http://www.010101.cc/2021/11/14/%E6%B1%87%E7%BC%96%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.010101.cc/2021/11/14/%E6%B1%87%E7%BC%96%E4%B9%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-11-14T02:25:43.000Z</published>
    <updated>2021-11-15T09:27:12.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><ul><li> <strong>提供三种容器寄存器 ： 8 ， 16 ， 32.</strong></li></ul><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><ul><li><strong>提供4中容器寄存器 ：     8 ，16 ，32 ，64.</strong></li></ul><h4 id="通用寄存器32位"><a href="#通用寄存器32位" class="headerlink" title="通用寄存器32位"></a>通用寄存器32位</h4><ul><li><p><strong>用户自定义使用寄存器</strong></p></li><li><p><strong>数据宽度为32位 多余的丢弃</strong></p><ul><li><p>EAX </p><ul><li><strong>返回值容器</strong></li></ul></li><li><p>ECX</p><ul><li><strong>REP执行计数器</strong></li></ul></li><li><p>EDX</p></li><li><p>EBX</p></li><li><p><strong>ESP</strong></p><ul><li><strong>栈指针寄存器,栈内存起始位置到ESP指针位置为已使用内存</strong></li></ul></li><li><p><strong>EBP</strong></p><ul><li><strong>栈底</strong></li></ul></li><li><p><strong>ESI</strong></p><ul><li><strong>movs 使用</strong></li></ul></li><li><p><strong>EDI</strong></p><ul><li><strong>movs 使用</strong></li></ul></li><li><p><strong>EFL</strong></p><ul><li>内存地址高低方向位</li></ul></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwei5fapk8j30v70syads.jpg" alt="image-20211114110903790"></p><h4 id="非通用寄存器"><a href="#非通用寄存器" class="headerlink" title="非通用寄存器"></a>非通用寄存器</h4><h4 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h4><ul><li><strong>cpu下次执行时会找EIP存的值</strong></li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li><p><strong>mov</strong></p><ul><li><strong>操作数数据宽度需要相同</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov eax,1 ;  将1存进eax寄存器。</span><br><span class="line">mov ecx,1 ;  将1存进ecx寄存器。</span><br><span class="line">mov eax,ecx ;  将ecx存进eax寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> x64模拟器：</span><br><span class="line">%rax 作为函数返回值使用。</span><br><span class="line">%rsp 栈指针寄存器，指向栈顶</span><br><span class="line">%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。</span><br><span class="line">%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</span><br><span class="line">%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>add 加法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add eax,ecx; 将ecx 与 eax 相加 存进eax寄存器;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>sub 减法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub eax,ecx; 将ecx 与 eax 相减 存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p><strong>AND 与运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND eax,ecx; 将ecx 与 eax 与运算 存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p><strong>or 或运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">or eax,ecx; 将ecx 与 eax 与或算 存进eax寄存器;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>xor 异或运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor eax,ecx; 将ecx 与 eax 与异或算 存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p><strong>NOT 非运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not eax, 将eax取反 ,存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p>**movs 从内存到内存 **</p><ul><li><strong>每复制一次 内存地址自增长当前数据宽度位</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Movs byte ptr es:[edi] , byte ptr ds:[esi]</span><br><span class="line"></span><br><span class="line">Movs byte ptr es:[0x00000000] , byte ptr ds:[0x00000001]</span><br><span class="line"></span><br><span class="line">ELF</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>stos 将AI/AX/EAX的值存储到[EDI]指定的内存单元</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">STOS WORD PTR ES:[edi]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>REP 重复执行 ，依赖ecx 寄存器的计数器 10进制，每次执行ecx值减一</strong></li></ul><p>​    </p><ul><li><p><strong>JMP 寄存器/立即数/内存</strong></p><ul><li><strong>修改EIP的值</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jmp dword ptr ds:[eax];  将eax的地址值，赋给EIP,cpu下次执行的将是eax里面的指令.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>CALL</strong></p><ul><li><p><strong>修改EIP值，再将ESP-4,并将栈顶值压入在ESP-4的地址中</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwewjs1s1uj31400u0q70.jpg" alt="Untitled 1"></p></li></ul></li><li><p><strong>RET</strong></p><ul><li><p><strong>1，将当前栈顶的值放进EIP中</strong></p></li><li><p><strong>2，将当前ESP指针值+4</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwewjw62v7j31400u0tcq.jpg" alt="Untitled 2"></p></li></ul></li></ul><h4 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h4><ul><li><p><strong>0x0000000</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据宽度：32位.</span><br></pre></td></tr></table></figure></li><li><p><strong>内存基本单元= 1byte = 8bit</strong></p></li></ul><h3 id="往内存中写数据"><a href="#往内存中写数据" class="headerlink" title="往内存中写数据"></a>往内存中写数据</h3><ul><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov byte ptr ds:[0x00000000] ,1</strong></p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov word ptr ds:[0x00000000] ,1 ; 单字宽度</strong>  </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov Dword ptr ds:[0x00000000] ,1; 双字宽度</strong> </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov Dword ptr ds:[0x00000000] ,eax; 将寄存器写入内存</strong> </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov eax, Dword ptr ds:[0x00000000] ; 将内存写入寄存器</strong> </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov eax, Dword ptr ds:[ecx+4] ; 将ecx内存地址+4的位置值写入寄存器</strong> </p></li></ul><h3 id="存储模式"><a href="#存储模式" class="headerlink" title="存储模式"></a>存储模式</h3><ul><li><p><strong>小端模式 x86</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据低位在低位，数据高位在高位.</span><br><span class="line"></span><br><span class="line">mov word ptr ds:[0x00000000],0x1a2c ,  0x00000000[1a], 0x00000001[2c]. </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>大端模式 arm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据低位在高位，数据高位在低位.</span><br><span class="line"></span><br><span class="line">mov word ptr ds:[0x00000000],0x1a2c ,  0x00000000[2c], 0x00000001[1a]. </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><ul><li><p><strong>PUSH压栈</strong></p><ul><li><strong>push指令将数据压入栈中，并移动栈针ESP ,（eps - 数据宽度）</strong></li></ul></li><li><p><strong>pop弹栈</strong></p><ul><li><p><strong>pop指令将数据弹出栈外，并移动栈针ESP ,（eps + 数据宽度)</strong></p></li><li><p><strong>pop eax; 将栈顶的值存入eax中，esp指针 + eax值的数据宽度</strong></p></li></ul></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><strong>JMP调用函数（通常不用）</strong></li></ul><h4 id="CALL-调用函数"><a href="#CALL-调用函数" class="headerlink" title="CALL()调用函数**"></a>CALL()调用函数**</h4><ul><li><strong>基本函数调用流程</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">求 10 + 7 = ？</span><br><span class="line"></span><br><span class="line">10 = 0000 1010 = 0x0a;  7 = 0000 0111 = 0x07;</span><br><span class="line"></span><br><span class="line">模拟入参：</span><br><span class="line"></span><br><span class="line">初始地址 esp : 0x00000128</span><br><span class="line">        ecx : 0x0000012c</span><br><span class="line">        edx : 0x00000131</span><br><span class="line">0x00000135  : null;      </span><br><span class="line">0x00000139   mov ecx 0x0a;</span><br><span class="line">0x0000013D   mov edx ox07;</span><br><span class="line">   //加</span><br><span class="line">0x00000142   add ecx ,edx;</span><br><span class="line"> //移动返回值</span><br><span class="line">0x00000146    mov eax, ecx;</span><br><span class="line"></span><br><span class="line">0x0000014a    ret;</span><br><span class="line"></span><br><span class="line">执行调用 call 0x00000139;  首先将 jmp eip ,esp; 然后 mov esp-4, esp; 再执行0x00000139位置;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数执行 139 13d 142 系列函数之后到达146 ret返回点，ret首先 jmp eip ,esp; 然后 mov esp+4 ,esp; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>堆栈函数与平衡</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">求 1 + 2 + 3 + 4 = ？</span><br><span class="line"></span><br><span class="line">0x0000 0117 ; push 4;</span><br><span class="line">0x0000 011b ; push 3;</span><br><span class="line">0x0000 0120 ; push 2;</span><br><span class="line">0x0000 0124 ; push 1;</span><br><span class="line">0x0000 0128 ; add eax, dword ptr ds:[esp+10], 由于压入4个立即数，堆栈地址增加了16，所以将第一个数与eax相加.</span><br><span class="line">............  add eax, dword ptr ds:[esp+0c],</span><br><span class="line">............  add eax, dword ptr ds:[esp+08],</span><br><span class="line">............  add eax, dword ptr ds:[esp+04],</span><br><span class="line">............  ret;</span><br><span class="line"></span><br><span class="line">call 0x0000 0117;</span><br><span class="line"></span><br><span class="line">============================================================================================</span><br><span class="line"></span><br><span class="line">堆栈平衡： </span><br><span class="line">在调用函数中 应该保证函数调用前后，堆栈的一致性不发生变化;</span><br><span class="line">在ret之前 应该保证堆栈指针esp 是call函数压入的esp地址;</span><br><span class="line"></span><br><span class="line">0x0000 0117 ; add eax, dword ptr ds:[0x0000 011b]</span><br><span class="line">0x0000 011b ; push 3;      ------ 此时esp已经发生变化 返回时指向esp的地址和堆栈已经发生变化，再次执行就会出错</span><br><span class="line">0x0000 0120 ; push 2;</span><br><span class="line">0x0000 0124 ; push 1;     </span><br><span class="line">0x0000 0128 ; ret;     ------ ret指令 ：将esp值放到eip，然后将esp的值+4;</span><br><span class="line"></span><br><span class="line">怎么平衡？</span><br><span class="line"></span><br><span class="line">外平栈</span><br><span class="line">call 0x0000 0117; add esp , 0x0c; 将esp复位;</span><br><span class="line"></span><br><span class="line">内平栈</span><br><span class="line">0x0000 0128 ; ret 0x0c;  在函数内部将esp复位;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ESP栈顶寻址"><a href="#ESP栈顶寻址" class="headerlink" title="ESP栈顶寻址"></a>ESP栈顶寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">求 1 + 2 + 3 + 4 = ？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//调用函数 </span><br><span class="line">0x0000 0113 : call 0x0000 0117; 压栈后栈顶指针esp;</span><br><span class="line"></span><br><span class="line">//执行压栈</span><br><span class="line">0x0000 0117 ; push 4;    </span><br><span class="line">0x0000 011b ; push 3;</span><br><span class="line">0x0000 0120 ; push 2;</span><br><span class="line">0x0000 0124 ; push 1;</span><br><span class="line"></span><br><span class="line">//执行相加</span><br><span class="line">0x0000 0128 : add eax , dword ptr ss:[esp+14] ; 执行加第一个数 1；</span><br><span class="line">0x0000 012c : add eax , dword ptr ss:[esp+10] ; 执行加第2个数 2；</span><br><span class="line">0x0000 0130 : add eax , dword ptr ss:[esp+c] ; 执行加第3个数 3；</span><br><span class="line">0x0000 0134 : add eax , dword ptr ss:[esp+8] ; 执行加第4个数 4；</span><br><span class="line">// 平栈  弹出/修正esp位置</span><br><span class="line">0x0000 0130 : pop 1 ;</span><br><span class="line"></span><br><span class="line">pop 1 ~ 4;</span><br><span class="line"></span><br><span class="line">0x0000 0134 : ret;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="EBP栈底寻址"><a href="#EBP栈底寻址" class="headerlink" title="EBP栈底寻址"></a>EBP栈底寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">求 1+2 = ？</span><br><span class="line"></span><br><span class="line">整体步骤，</span><br><span class="line">1： 将参数压栈</span><br><span class="line">2： 调用函数, 2.1 备份esp到ebp, 2.2 开辟新空间， 2.3 复位esp, 2.4弹出备份ebp; 2.5平栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始堆栈：</span><br><span class="line">esp : 0x0000 0120;</span><br><span class="line">ebp : 0x0000 011c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1. 参数压栈</span><br><span class="line">push 2;  esp : 0x0000 0118;   eip :  0x0000 0001;</span><br><span class="line">push 1;  esp : 0x0000 011c;    eip : 0x0000 0002;</span><br><span class="line"></span><br><span class="line">//2. 调用函数</span><br><span class="line">call  0x0000 0005;    esp : 0x0000 0114;   （ eip : 0x0000 0004; 指向下一条指令)</span><br><span class="line">// 下一条的指令;</span><br><span class="line">mov eax,1;eip : 0x0000 0004;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==============================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数：</span><br><span class="line">1，备份栈底ebp</span><br><span class="line">push ebp;  esp : 0x0000 0110;     eip : 0x0000 0005;</span><br><span class="line"></span><br><span class="line">2，记录起始ebp的值</span><br><span class="line">mov ebp,esp; esp : 0x0000 0110; ebp : 0x0000 0110;      eip : 0x0000 0006;</span><br><span class="line"></span><br><span class="line">3，开辟新空间 开辟16个字节</span><br><span class="line">sub esp,10;   esp : 0x0000 0100;                     eip : 0x0000 0007;</span><br><span class="line"></span><br><span class="line">4,执行加操作</span><br><span class="line">add eax ,dword ptr ss:[ebp+c]                         eip : 0x0000 0008;</span><br><span class="line">add eax ,dword ptr ss:[ebp+8] </span><br><span class="line"></span><br><span class="line">5,复位堆栈</span><br><span class="line">mov esp,ebp;     esp : 0x0000 0110; </span><br><span class="line"></span><br><span class="line">pop ebp;   esp : 0x0000 0114; </span><br><span class="line"></span><br><span class="line">ret c;      esp : 0x0000 0120;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JCC指令集"><a href="#JCC指令集" class="headerlink" title="JCC指令集"></a>JCC指令集</h3><ul><li><strong>JCC指令根据标志寄存器值的标志位来修改EIP的，从而实现执行跳转</strong></li></ul><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwfyghrzp2j30jf09djrt.jpg" alt="标志寄存器（EFLAGS） - 程序员大本营"></p><ul><li><strong>运算相关指令都会影响标志寄存器</strong></li></ul><table><thead><tr><th>JCC指令</th><th>中文含义</th><th>英文原意</th><th>检查符号位</th><th>典型C应用</th></tr></thead><tbody><tr><td><code>JZ/JE</code></td><td>若为0则跳转；若相等则跳转</td><td>jump if zero;jump if equal</td><td><code>ZF=1</code></td><td><code>if (i == j);if (i == 0);</code></td></tr><tr><td><code>JNZ/JNE</code></td><td>若不为0则跳转；若不相等则跳转</td><td>jump if not zero;jump if not equal</td><td><code>ZF=0</code></td><td><code>if (i != j);if (i != 0);</code></td></tr><tr><td><code>JS</code></td><td>若为负则跳转</td><td>jump if sign</td><td><code>SF=1</code></td><td><code>if (i &lt; 0);</code></td></tr><tr><td><code>JNS</code></td><td>若为正则跳转</td><td>jump if not sign</td><td><code>SF=0</code></td><td><code>if (i &gt; 0);</code></td></tr><tr><td><code>JP/JPE</code></td><td>若1出现次数为偶数则跳转</td><td>jump if Parity (Even)</td><td><code>PF=1</code></td><td><code>(null)</code></td></tr><tr><td><code>JNP/JPO</code></td><td>若1出现次数为奇数则跳转</td><td>jump if not parity (odd)</td><td><code>PF=0</code></td><td><code>(null)</code></td></tr><tr><td><code>JO</code></td><td>若溢出则跳转</td><td>jump if overflow</td><td><code>OF=1</code></td><td><code>(null)</code></td></tr><tr><td><code>JNO</code></td><td>若无溢出则跳转</td><td>jump if not overflow</td><td><code>OF=0</code></td><td><code>(null)</code></td></tr><tr><td><code>JC/JB/JNAE</code></td><td>若进位则跳转；若低于则跳转；若不高于等于则跳转</td><td>jump if carry;jump if below;jump if not above equal</td><td><code>CF=1</code></td><td><code>if (i &lt; j);</code></td></tr><tr><td><code>JNC/JNB/JAE</code></td><td>若无进位则跳转；若不低于则跳转；若高于等于则跳转；</td><td>jump if not carry;jump if not below;jump if above equal</td><td><code>CF=0</code></td><td><code>if (i &gt;= j);</code></td></tr><tr><td><code>JBE/JNA</code></td><td>若低于等于则跳转；若不高于则跳转</td><td>jump if below equal;jump if not above</td><td><code>ZF=1或CF=1</code></td><td><code>if (i &lt;= j);</code></td></tr><tr><td><code>JNBE/JA</code></td><td>若不低于等于则跳转；若高于则跳转</td><td>jump if not below equal;jump if above</td><td><code>ZF=0或CF=0</code></td><td><code>if (i &gt; j);</code></td></tr><tr><td><code>JL/JNGE</code></td><td>若小于则跳转；若不大于等于则跳转</td><td>jump if less;jump if not greater equal jump</td><td><code>SF != OF</code></td><td><code>if (si &lt; sj);</code></td></tr><tr><td><code>JNL/JGE</code></td><td>若不小于则跳转；若大于等于则跳转；</td><td>jump if not less;jump if greater equal</td><td><code>SF = OF</code></td><td><code>if (si &gt;= sj);</code></td></tr><tr><td><code>JLE/JNG</code></td><td>若小于等于则跳转；若不大于则跳转</td><td>jump if less equal;jump if not greater</td><td><code>ZF != OF 或 ZF=1</code></td><td><code>if (si &lt;= sj);</code></td></tr><tr><td><code>JNLE/JG</code></td><td>若不小于等于则跳转；若大于则跳转</td><td>jump if not less equal;jump if greater</td><td><code>SF=0F 且 ZF=0</code></td><td><code>if(si&gt;sj)</code></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;汇编基础&quot;&gt;&lt;a href=&quot;#汇编基础&quot; class=&quot;headerlink&quot; title=&quot;汇编基础&quot;&gt;&lt;/a&gt;汇编基础&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messed up ! : )&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="Assembly" scheme="http://www.010101.cc/categories/Assembly/"/>
    
    
    <category term="汇编" scheme="http://www.010101.cc/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础之内存分布</title>
    <link href="http://www.010101.cc/2021/11/14/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83---TODO/"/>
    <id>http://www.010101.cc/2021/11/14/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83---TODO/</id>
    <published>2021-11-14T02:25:43.000Z</published>
    <updated>2021-11-18T16:46:36.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言之内存分布简单分析"><a href="#C语言之内存分布简单分析" class="headerlink" title="C语言之内存分布简单分析"></a>C语言之内存分布简单分析</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="C源码-脑图模拟汇编Win32"><a href="#C源码-脑图模拟汇编Win32" class="headerlink" title="C源码 | 脑图模拟汇编Win32"></a>C源码 | 脑图模拟汇编Win32</h3><ul><li><strong>win32汇编设计上还是有很多不合理，造成了很多资源浪费，比如断点C的填充，在AT&amp;T的汇编上得到了改良</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//减函数</span><br><span class="line">int sub(int c)&#123;</span><br><span class="line">    return c-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 加函数</span><br><span class="line">int add(int a , int b)&#123;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    //函数嵌入</span><br><span class="line">    c = sub(c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//main函数</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    // insert code here...</span><br><span class="line">    int a = 20;</span><br><span class="line">    int b = 10;</span><br><span class="line">    int c = add(a,b);</span><br><span class="line">    //int a = 7;</span><br><span class="line">    //putchar(a);</span><br><span class="line">    //printf(&quot;Hello, World! %d \n&quot;,c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">================================模拟汇编堆栈====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始堆栈：</span><br><span class="line"></span><br><span class="line">esp   0x0000 02ff;</span><br><span class="line">ebp   0x0000 0208;</span><br><span class="line">eip   0x0005 0001;</span><br><span class="line"></span><br><span class="line">//预留三个参数寄存器</span><br><span class="line"></span><br><span class="line">esi ....</span><br><span class="line">edi ....</span><br><span class="line">ebx ....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">============================ main start =====================</span><br><span class="line"></span><br><span class="line">// 1. 提栈</span><br><span class="line">0x0005 0001 ------------   push ebp; |  esp  0x0000 01fb; ebp   0x0000 0208[0x0000 0208]; </span><br><span class="line">0x0005 0002 ------------   mov ebp, esp; |  esp  0x0000 01fb; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line">0x0005 0003 ------------   sub esp, 0x20; |  esp  0x0000 01db; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line"></span><br><span class="line">// 2. 压栈 - 编译环境不一样，编译器优化汇编 可能有一些差异，整体逻辑是不变的, </span><br><span class="line">//   有的环境是直接取寄存器的值，有的直接压值，这里选择压值, </span><br><span class="line">//   win32 压在缓冲区外，AT&amp;T 压在缓冲区内: push 0x14 , ebp - 0x04;</span><br><span class="line">0x0005 0004 ------------   push 0x14; |  esp  0x0000 01d7; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line">0x0005 0005 ------------   push 0x0a; |  esp  0x0000 01d3; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line"></span><br><span class="line">// 3. 函数调用</span><br><span class="line">0x0005 0006 ------------   call 0x0005 000b; |  esp  0x0000 01cf[0x0005 0007]; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line">// 此时 eax = 29; esp  esp  0x0000 01cf; ebp   0x0000 01fb[0x0000 0208]; eax = 29;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 4.恢复堆栈</span><br><span class="line">0x0005 0007 ------------   mov esp, ebp; |  esp  0x0000 01fb; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0008 ------------   pop ebp; |  esp  0x0000 01ff; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line"></span><br><span class="line">//由于没有选择寄存器传值，压入的两个参数此时不用处理，平栈的方式很多种，这里似乎可以直接平.</span><br><span class="line">//0x0005 0009 ------------   add esp,0x20; |  esp  0x0000 01fb; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line"></span><br><span class="line">0x0005 0009 ------------   ret; |  esp  0x0000 01ff; ebp   0x0000 0208; </span><br><span class="line"></span><br><span class="line">=================================== main end ===============================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 加函数</span><br><span class="line">============================ add start ===================== esp  0x0000 01cf</span><br><span class="line"></span><br><span class="line">0x0005 000b ------------   push ebp - 0x0c ,eax ; |  esp  esp  0x0000 01cb; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 000b ------------   mov ebp, esp ;|  esp  esp  0x0000 01cb; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line"></span><br><span class="line">// 加</span><br><span class="line">0x0005 000c ------------   mov eax , ebp - 0x08; |    esp  0x0000 01cb; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line">0x0005 000d ------------   add eax , ebp - 0x04; |    esp  0x0000 01cb; eax = 30;</span><br><span class="line"></span><br><span class="line">//压参数 </span><br><span class="line">0x0005 000e ------------   push ebp - 0x0c , eax; |  esp  0x0000 01c7; eax = 30;</span><br><span class="line">0x0005 000f ----   call 0x0005 0013 |  esp  esp  0x0000 01c3[0x0005 0000]; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 恢复堆栈</span><br><span class="line">0x0005 0000 ------------   pop ebp ; |  esp  esp  0x0000 01c7; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0011 ------------   add esp,0x08 ; |  esp  0x0000 01cf; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line">0x0005 0012 ------------   ret ; |  esp  0x0000 01f9; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line"></span><br><span class="line">=================================add end====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 减函数</span><br><span class="line">============================ sub start =====================</span><br><span class="line">// win32汇编并没有使用寄存器传参，此处eax应该使用寄存器，或者EBP寻址;</span><br><span class="line">0x0005 0013 ------------   sub ebp - 0x0c , 0x01;  |  esp  0x0000 01c3; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0014 ------------   mov eax , ebp - 0x0c;   |  esp  0x0000 01c3; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0015 ------------   ret;   |  esp  0x0000 01c3; ebp   0x0000 01fb[0x0000 0208]; eax = 29;</span><br><span class="line"></span><br><span class="line">============================ sub end =====================</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言之内存分布简单分析&quot;&gt;&lt;a href=&quot;#C语言之内存分布简单分析&quot; class=&quot;headerlink&quot; title=&quot;C语言之内存分布简单分析&quot;&gt;&lt;/a&gt;C语言之内存分布简单分析&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a messag</summary>
      
    
    
    
    <category term="C语言" scheme="http://www.010101.cc/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://www.010101.cc/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编之趣味计算机</title>
    <link href="http://www.010101.cc/2021/11/13/%E6%B1%87%E7%BC%96%E8%B6%A3%E5%91%B3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>http://www.010101.cc/2021/11/13/%E6%B1%87%E7%BC%96%E8%B6%A3%E5%91%B3%E8%AE%A1%E7%AE%97%E6%9C%BA/</id>
    <published>2021-11-13T07:56:26.000Z</published>
    <updated>2021-11-15T07:55:07.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="汇编之有趣的计算机"><a href="#汇编之有趣的计算机" class="headerlink" title="汇编之有趣的计算机"></a>汇编之有趣的计算机</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="汇编的加减乘除："><a href="#汇编的加减乘除：" class="headerlink" title="汇编的加减乘除："></a>汇编的加减乘除：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  汇编语言                 编译器                    机器语言   </span><br><span class="line"></span><br><span class="line">加      INC EAX                  ---&gt;                  0100 0000  </span><br><span class="line"></span><br><span class="line">减      DEC EAX                    ---&gt;                  0100 1000</span><br><span class="line"></span><br><span class="line">乘      MUL EAX         ---&gt;                  1111 0111 1110 0000</span><br><span class="line"></span><br><span class="line">除      DIV EAX                    ---&gt;                  1111 0111 1111 0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进制换算"><a href="#进制换算" class="headerlink" title="进制换算"></a>进制换算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 </span><br><span class="line"></span><br><span class="line">0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15</span><br><span class="line"></span><br><span class="line">0    1    2    3    4    5    6    7    8    9    A    B    C    D     E   F</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">hex : 6d  7f 008c e3 246</span><br><span class="line"></span><br><span class="line">hex to bin</span><br><span class="line">6 + d = 0110 1101, 7 + f = 0111 1111, 8 + c =0000 0000 1000 1100, e + 3 = 1110 0011, 2 + 4 + 6 = 0010 0100 0110.</span><br></pre></td></tr></table></figure><h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><ul><li><strong>超过数据宽度将被丢弃</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">位 bit: 0，最大值 1.</span><br><span class="line"></span><br><span class="line">字节 byte: 0000 0000 , 最大值 1111 1111 ， 0 - ff. 0xff.</span><br><span class="line"></span><br><span class="line">字word: 0000 0000 0000 0000 ,最大值 1111 1111 1111 1111 , 0 - ffff, 0xffff.</span><br><span class="line"></span><br><span class="line">双字doubleWord: 0000 0000 0000 0000 0000 0000 0000 0000 0000 , 最大值 0xffffffff.</span><br><span class="line"></span><br><span class="line">数据宽度测试：</span><br><span class="line">char a = 0x1ff, 存入数据是ff 舍弃了1，因为宽度不够.</span><br><span class="line"></span><br><span class="line">Xcode 进入debug 模式， 在右边控制台或者内存值, 输出：</span><br><span class="line"></span><br><span class="line">x/1xb 0x7ffeefbff3df ， 取1个字节的值，用16进制表示，表示单字节</span><br><span class="line">0x7ffeefbff3df: 0xff  只存了ff。</span><br><span class="line"></span><br><span class="line">x/nfu &lt;addr&gt; </span><br><span class="line"></span><br><span class="line">n，表示要显示的内存单元的个数</span><br><span class="line">f，表示显示方式, 可取如下值：</span><br><span class="line">x 按十六进制格式显示变量</span><br><span class="line">d 按十进制格式显示变量</span><br><span class="line">u 按十进制格式显示无符号整型</span><br><span class="line">o 按八进制格式显示变量</span><br><span class="line">t 按二进制格式显示变量</span><br><span class="line">a 按十六进制格式显示变量</span><br><span class="line">i 指令地址格式</span><br><span class="line">c 按字符格式显示变量</span><br><span class="line">f 按浮点数格式显示变量</span><br><span class="line"></span><br><span class="line">u，表示一个地址单元的长度：</span><br><span class="line">b 表示单字节</span><br><span class="line">h 表示双字节</span><br><span class="line">w 表示四字节</span><br><span class="line">g 表示八字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/16xb self</span><br><span class="line">会显示 self 指针地址内容，16 个字节，16 进制。</span><br><span class="line">x/8cb 0x7fc359a03040</span><br><span class="line">会显示地址 0x7fc359a03040 地址的内容，8 个字节，按字符格式显示。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="有符号-与-无符号"><a href="#有符号-与-无符号" class="headerlink" title="有符号 与 无符号"></a>有符号 与 无符号</h3><ul><li><p><strong>有符号数与无符号数正数显示结果一样，负数结果不一样</strong></p></li><li><p>有符号</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无符号 0000 0001 就是 0000 0001, </span><br></pre></td></tr></table></figure><ul><li>无符号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">测试： 1 ， 0x01,</span><br><span class="line">最高位 0， 是正数.</span><br><span class="line">0000 0001    </span><br><span class="line"></span><br><span class="line">最高位 1，是负数.</span><br><span class="line">1000 0001  , 0x81</span><br><span class="line"></span><br><span class="line">int x = 0x81000000; </span><br><span class="line">printf(&quot;有符号表示 %u\n&quot;,x);</span><br><span class="line">printf(&quot;无符号表示 %d\n&quot;,x);</span><br><span class="line">有符号表示 2164260864</span><br><span class="line">无符号表示 -2130706432</span><br></pre></td></tr></table></figure><h3 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><ul><li><strong>正数存储用原码反码补码都一样</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最高位是符号位，其余位为数值的绝对值. </span><br><span class="line">1 的原码 0000 0001 </span><br></pre></td></tr></table></figure><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><ul><li><strong>正数的反码原码相同，负数符号位1，其余位取反</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">原码： 1000 0001</span><br><span class="line">反码:  1111 1110  , 最高位不变.</span><br></pre></td></tr></table></figure><h4 id="补码-！！！负数存储！！！"><a href="#补码-！！！负数存储！！！" class="headerlink" title="补码 -！！！负数存储！！！"></a>补码 -！！！负数存储！！！</h4><ul><li><p><strong>负数补码存储，符号位不变，正数不变，其余位反码加1，</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">正码</span><br><span class="line">1 , 0000 0001.</span><br><span class="line">反码</span><br><span class="line">-1, 1111,1110.</span><br><span class="line">反码</span><br><span class="line">-1, 1111 1111.</span><br><span class="line"></span><br><span class="line">测试： 求 1，-1 在内存中的16进制值;</span><br><span class="line"></span><br><span class="line">1: 正数无需关心，直接转16进制 = 0x01.</span><br><span class="line"></span><br><span class="line">-1: 反码+1， 原码 1000 0001 ， 反码 ，1111 1110 ， 补码+1 , 1111 1111, 得出内存值 0xff.</span><br><span class="line"></span><br><span class="line">cha x = -1;</span><br><span class="line">输出:</span><br><span class="line">x/1xb 0x7ffeefbff3df</span><br><span class="line">0x7ffeefbff3df: 0xff</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><ul><li>**同位为1，结果才是1，否则是0. **</li><li><strong>并且（当2个开关都闭合灯才亮）</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdq50bglcj30e4089t8n.jpg" alt="image-20211113185951722"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试：C: 1 &amp; 2 ，  assembly: and</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">结果 : 0000 0000; 结果为0；</span><br></pre></td></tr></table></figure><h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><ul><li><strong>同位只要有1，就是1</strong></li><li><strong>或者 (两个开关只要一个开关闭合灯就能亮)</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdq732jodj30fj08vq2y.jpg" alt="image-20211113190157102"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试: C: 1 | 2 , assembly : or</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">结果为： 0000 0011; 结果为3；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><ul><li><strong>同位相反才为1，否则为0</strong></li><li><strong>不一样的时候才为1</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwfw171yf7j30fi09tdfv.jpg" alt="image-20211113191238456"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">测试: C: 1 ^ 2 , assembly : xor</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">结果为： 0000 0011; 结果为3；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h4><ul><li><strong>同位交换,单数运算</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试: 1 ，C: ~ , assembly : not</span><br><span class="line">0000 0001</span><br><span class="line"></span><br><span class="line">结果为： 1111 1110；</span><br></pre></td></tr></table></figure><h4 id="左移运算"><a href="#左移运算" class="headerlink" title="左移运算"></a>左移运算</h4><ul><li><strong>各二进制位全部向左移动若干位，高位丢弃，地位补0</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C：&lt;&lt; , assembly : shl</span><br><span class="line"></span><br><span class="line">测试 ： 1，左移1位，</span><br><span class="line">0000 0001 ,结果： 0000 0010； = 2.</span><br><span class="line">左移2；</span><br><span class="line">0000 0001, 结果： 0000 0100； = 4.</span><br><span class="line"></span><br><span class="line">char c = 1 &lt;&lt; 2;</span><br><span class="line">输出为：4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="右移运算"><a href="#右移运算" class="headerlink" title="右移运算"></a>右移运算</h4><ul><li><strong>各二进制位向右移动若干位，无符号高位补0或者有符号高位补1，低位丢弃</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C：&gt;&gt; , assembly : shr</span><br><span class="line"></span><br><span class="line">测试 ： 1，</span><br><span class="line"></span><br><span class="line">右移1位，</span><br><span class="line">0000 0001 ,结果： 0000 0000； = 0.</span><br><span class="line">右移2；</span><br><span class="line">0000 0001, 结果： 0000 0000； = 0.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补符号： 高位补1</span><br><span class="line">C：&gt;&gt; , assembly : sar</span><br><span class="line">测试数： 10；右移2位；</span><br><span class="line">0000 1100; 结果： 1000 0011； 负数存的是反码+1， 1111 1101， 内存值= 0xfd;</span><br><span class="line"></span><br><span class="line">1000 1010 -&gt; 1111 0110 补码值 ：0xf6 右移-&gt; 1111 1101; fd</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="+  - * /"></a>+  - * /</h3><h4 id="-2"><a href="#-2" class="headerlink" title="+"></a>+</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">求 10 + 7 = ？</span><br><span class="line">//混搭伪代码</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 7;</span><br><span class="line"></span><br><span class="line">funcAdd(a,b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//转换</span><br><span class="line">0000 1010 </span><br><span class="line">0000 0111 </span><br><span class="line">//第一步先异或</span><br><span class="line">int tmp = funXor(a,b) funXor(a,b); = 0000 1101</span><br><span class="line">//第二步判断是否有进位</span><br><span class="line">int shlTemp = funcCmp(a,b); 0000 0010； 有进位</span><br><span class="line"></span><br><span class="line">//判断是否有进位 ,</span><br><span class="line">if(shlTemp!=0)</span><br><span class="line">&#123;</span><br><span class="line">//有进位需要位移,位移后的值.</span><br><span class="line">int shlTempValue = funcSHL(shlTemp,1); 0000 0100;</span><br><span class="line"></span><br><span class="line">//将第一次的结果与进位的结果异或 ,第一次递归调用</span><br><span class="line">funcAdd(tmp,shlTempValue);</span><br><span class="line">//第二次异或; </span><br><span class="line">0000 1101</span><br><span class="line">0000 0100</span><br><span class="line">    = tmp = 0000 1001;   </span><br><span class="line">第二次与运算对比，有进位;shlTemp = 0000 0100 </span><br><span class="line">shlTempValue = funcSHL(shlTemp ,1) = 0000 1000;</span><br><span class="line"></span><br><span class="line">//第二次递归调用funcAdd(tmp, shlTempValue); </span><br><span class="line">0000 1001</span><br><span class="line">0000 1000</span><br><span class="line">//第三次异或运算</span><br><span class="line">tem = 0000 0001</span><br><span class="line">//第三次对比 与 运算</span><br><span class="line">shlTemp =0000 1000;</span><br><span class="line">//有进位，第三次位移</span><br><span class="line">shlTempValue = 0001 0000；</span><br><span class="line"></span><br><span class="line">//第三次次递归调用funcAdd(tmp, shlTempValue)</span><br><span class="line">//第四次异或</span><br><span class="line">0000 0001</span><br><span class="line">0001 0000</span><br><span class="line">tem = 0001 0001 = 17;</span><br><span class="line">//第四次与运算，判断是否有进位</span><br><span class="line">//第四次无进位，判断执行完毕，执行后面代码</span><br><span class="line">&#125;</span><br><span class="line">returun tem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与运算</span><br><span class="line">funcCmp(a,b)</span><br><span class="line">&#123;</span><br><span class="line"> 0000 1010 </span><br><span class="line"> &amp;</span><br><span class="line"> 0000 0111  </span><br><span class="line"> </span><br><span class="line">return a&amp;b = 0000 0010;   如果非0，作为返回值继续异或</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左移1位</span><br><span class="line">funcSHL(int a,int offset)&#123;</span><br><span class="line">  a = 0000 0010;</span><br><span class="line">offset = 1;</span><br><span class="line">return a &lt;&lt; 1 = 0000 0100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异或运算</span><br><span class="line">funXor(a,b)</span><br><span class="line">&#123;</span><br><span class="line">a = 0000 1010 </span><br><span class="line">b = 0000 0111 </span><br><span class="line">// 假设没进位</span><br><span class="line">return a^b; 0000 1101;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="－"><a href="#－" class="headerlink" title="－"></a>－</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">求 10 - 7 = ？</span><br><span class="line"></span><br><span class="line">减法就是加法 ， 10-7 = 1 + （-7）;</span><br><span class="line"> </span><br><span class="line">-7 是补码存储，求补码：</span><br><span class="line">正码： 0000 0111; 反码： 1111 1000；补码=反码+1= 1111 1001； 内存=0xf9;</span><br><span class="line"></span><br><span class="line">//混搭伪代码</span><br><span class="line">int a = 10;</span><br><span class="line">int b = -7;</span><br><span class="line">funcAdd(a,b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//转换</span><br><span class="line">0000 1010 </span><br><span class="line">1111 1001 </span><br><span class="line">//第一步先异或</span><br><span class="line">int tmp = funXor(a,b) funXor(a,b); = 1111 0011</span><br><span class="line">//第二步判断是否有进位</span><br><span class="line">int shlTemp = funcCmp(a,b); 0000 1000； 有进位</span><br><span class="line"></span><br><span class="line">//判断是否有进位 ,</span><br><span class="line">if(shlTemp!=0)</span><br><span class="line">&#123;</span><br><span class="line">//有进位需要位移,位移后的值.</span><br><span class="line">int shlTempValue = funcSHL(shlTemp,1); 0001 0000;</span><br><span class="line"></span><br><span class="line">//将第一次的结果与进位的结果异或 ,第一次递归调用</span><br><span class="line">funcAdd(tmp,shlTempValue);</span><br><span class="line">//第二次异或; </span><br><span class="line">1111 0011</span><br><span class="line">0001 0000</span><br><span class="line">    = tmp = 1110 0011;   </span><br><span class="line">第二次与运算对比，有进位;shlTemp = 0001 0000 </span><br><span class="line">shlTempValue = funcSHL(shlTemp ,1) = 0010 0000;</span><br><span class="line"></span><br><span class="line">--------------n次递归-----------------</span><br><span class="line">求 10 - 7 = 10 + （-7） </span><br><span class="line">0000 1010 </span><br><span class="line">1111 1001 </span><br><span class="line">异或 tmp = 1111 0011</span><br><span class="line">进位： 0000 1000</span><br><span class="line">进位后的值 shlTempValue = funcSHL(000 1000 ,1) = 0001 0000</span><br><span class="line">-------------------------------------</span><br><span class="line">1111 0011</span><br><span class="line">0001 0000</span><br><span class="line">异或 tmp = 1110 0011</span><br><span class="line">进位： 0001 0000</span><br><span class="line">进位后的值 shlTempValue = funcSHL(0001 0000 ,1) = 0010 0000</span><br><span class="line">---------------------------------------</span><br><span class="line">1110 0011</span><br><span class="line">0010 0000</span><br><span class="line">tmp = 1100 0011</span><br><span class="line">shlTempValue = funcSHL(0010 0000 ,1) = 0100 0000</span><br><span class="line">-------------------------------</span><br><span class="line">0100 0000</span><br><span class="line">1100 0011</span><br><span class="line">tmp = 1000 0011</span><br><span class="line">shlTempValue = funcSHL(0100 0000 ,1) = 1000 0000</span><br><span class="line">---------------------------------</span><br><span class="line">1000 0000</span><br><span class="line">1000 0011</span><br><span class="line">tmp = 1000 0011;</span><br><span class="line">shlTempValue = funcSHL(0100 0000 ,1) = 0001 0000 0000</span><br><span class="line">0001 0000 0000</span><br><span class="line">0000 0000 0011</span><br><span class="line">0001 0000 0011  ？？？？？？WTF  此时结果产生了溢出； 篇幅原因 就不展开讲了</span><br><span class="line">-------------------------------------</span><br><span class="line">tem = 0001 0000 0011 ;</span><br><span class="line">//第四次与运算，判断是否有进位</span><br><span class="line">//第四次无进位，判断执行完毕，执行后面代码</span><br><span class="line">&#125;</span><br><span class="line">returun tem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与运算</span><br><span class="line">funcCmp(a,b)</span><br><span class="line">&#123;</span><br><span class="line"> 0000 1010 </span><br><span class="line"> &amp;</span><br><span class="line"> 0000 0111  </span><br><span class="line"> </span><br><span class="line">return a&amp;b = 0000 0010;   如果非0，作为返回值继续异或</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左移1位</span><br><span class="line">funcSHL(int a,int offset)&#123;</span><br><span class="line">  a = 0000 0010;</span><br><span class="line">offset = 1;</span><br><span class="line">return a &lt;&lt; 1 = 0000 0100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//异或运算</span><br><span class="line">funXor(a,b)</span><br><span class="line">&#123;</span><br><span class="line">a = 0000 1010 </span><br><span class="line">b = 0000 0111 </span><br><span class="line">// 假设没进位</span><br><span class="line">return a^b; 0000 1101;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-3"><a href="#-3" class="headerlink" title="*"></a>*</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">求 10 * 7 = ？ </span><br><span class="line">解： 7 个 10 相加; </span><br><span class="line">int a = 10;</span><br><span class="line">int b = 7;</span><br><span class="line"></span><br><span class="line">for (int i =0; i &lt; 7 ; i++ )&#123;</span><br><span class="line">funcAdd(a,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-4"><a href="#-4" class="headerlink" title="/"></a>/</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">求 10 * 7 = ？ </span><br><span class="line">解： 7 个 10 相加; </span><br><span class="line">int a = 10;</span><br><span class="line">int b = 7;</span><br><span class="line"></span><br><span class="line">for (int i =0; i &lt; 7 ; i++ )&#123;</span><br><span class="line">//转换补码负数</span><br><span class="line">b = 1111 1001; </span><br><span class="line">funcAdd(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;汇编之有趣的计算机&quot;&gt;&lt;a href=&quot;#汇编之有趣的计算机&quot; class=&quot;headerlink&quot; title=&quot;汇编之有趣的计算机&quot;&gt;&lt;/a&gt;汇编之有趣的计算机&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messe</summary>
      
    
    
    
    <category term="Assembly" scheme="http://www.010101.cc/categories/Assembly/"/>
    
    
    <category term="汇编" scheme="http://www.010101.cc/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC Stop The World &amp; SafePoint</title>
    <link href="http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%20Stop%20The%20World%20&amp;%20SafePoint/"/>
    <id>http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%20Stop%20The%20World%20&amp;%20SafePoint/</id>
    <published>2021-11-13T05:08:57.000Z</published>
    <updated>2021-11-13T07:06:33.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC-Stop-The-World-amp-SafePoint浅析"><a href="#GC-Stop-The-World-amp-SafePoint浅析" class="headerlink" title="GC Stop The World &amp; SafePoint浅析"></a>GC Stop The World &amp; SafePoint浅析</h2><p>Wirte by 021.  Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdj0ch0g1j30k00f00tt.jpg" alt="Portable Unobtrusive Garbage Collection for Multiprocessor Systems Damien"></p><h4 id="1-在哪里停止-Where-is-SafePoint？"><a href="#1-在哪里停止-Where-is-SafePoint？" class="headerlink" title="1. 在哪里停止 Where is SafePoint？"></a>1. 在哪里停止 Where is SafePoint？</h4><ul><li><strong>什么是安全点SafePoint？</strong></li></ul><ul><li><strong>安全点的实现</strong></li></ul><h4 id="2-什么时候停-When-is-the-Stop-the-world-happend"><a href="#2-什么时候停-When-is-the-Stop-the-world-happend" class="headerlink" title="2. 什么时候停 When is the Stop the world happend?"></a>2. 什么时候停 When is the Stop the world happend?</h4><h4 id="3-停下来做什么-after-Stop-The-World"><a href="#3-停下来做什么-after-Stop-The-World" class="headerlink" title="3. 停下来做什么 after Stop The World?"></a>3. 停下来做什么 after Stop The World?</h4><h4 id="上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90"><a href="#上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90" class="headerlink" title="上一篇 ：GC垃圾回收原理浅析：https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"></a>上一篇 ：GC垃圾回收原理浅析：<a href="https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/">https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GC-Stop-The-World-amp-SafePoint浅析&quot;&gt;&lt;a href=&quot;#GC-Stop-The-World-amp-SafePoint浅析&quot; class=&quot;headerlink&quot; title=&quot;GC Stop The World &amp;amp; Sa</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC调优方法论</title>
    <link href="http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2021-11-13T05:08:57.000Z</published>
    <updated>2021-11-13T05:56:33.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC调优方法论"><a href="#JVM之GC调优方法论" class="headerlink" title="JVM之GC调优方法论"></a>JVM之GC调优方法论</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd42l4mej319j0jt762.jpg" alt="image-20210320093842591"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwceol0aqkj30fy091aa8.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfra35t1j30xe0d5775.jpg" alt="image-20211112161507515"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd4ba2k2j30k006yjrz.jpg" alt="img"></p><h4 id="1-GC调优目标："><a href="#1-GC调优目标：" class="headerlink" title="1. GC调优目标："></a>1. GC调优目标：</h4><h5 id="高吞吐型："><a href="#高吞吐型：" class="headerlink" title="高吞吐型："></a>高吞吐型：</h5><p>​            * </p><h5 id="快速响应型："><a href="#快速响应型：" class="headerlink" title="快速响应型："></a>快速响应型：</h5><h4 id="上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90"><a href="#上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90" class="headerlink" title="上一篇 ：GC垃圾回收原理浅析：https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"></a>上一篇 ：GC垃圾回收原理浅析：<a href="https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/">https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC调优方法论&quot;&gt;&lt;a href=&quot;#JVM之GC调优方法论&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC调优方法论&quot;&gt;&lt;/a&gt;JVM之GC调优方法论&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java编译器浅析</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-13T07:21:02.195Z</updated>
    
    <content type="html"><![CDATA[<p>Wirte by 021.</p><h2 id="Java编译器浅析"><a href="#Java编译器浅析" class="headerlink" title="Java编译器浅析"></a>Java编译器浅析</h2><ul><li><p><strong>本地代码（native code）</strong> 是计算机编程（代码），编译用来运行一个特殊的处理器（如英特尔x86级的处理器）和它的特殊指令集，简称机器码.</p><ul><li><p>Win : exe</p></li><li><p>Linux : elf</p></li></ul></li></ul><h4 id="模式1-：-即时编译JIT编译器-Just-in-time"><a href="#模式1-：-即时编译JIT编译器-Just-in-time" class="headerlink" title="模式1 ： 即时编译JIT编译器-Just in time."></a>模式1 ： 即时编译JIT编译器-Just in time.</h4><ul><li>主要用于JVM将 **class热点代码 ** 编译为本地代码.</li></ul><h4 id="模式2：-解释器-byteCode-intepreter"><a href="#模式2：-解释器-byteCode-intepreter" class="headerlink" title="模式2： 解释器 byteCode intepreter"></a>模式2： 解释器 byteCode intepreter</h4><ul><li>在程序运行过程中，JVM将字节码再转换成本地可执行的本地代码,边解释字节码边执行，故而称为解释器。</li></ul><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认： -Xmixed 混合模式</span><br><span class="line">-Xint 解释模式，启动块，执行稍微慢</span><br><span class="line">-XComp 编译模式，启动时间慢，需要编译</span><br></pre></td></tr></table></figure><h4 id="编译器-—-TODO"><a href="#编译器-—-TODO" class="headerlink" title="编译器 — TODO"></a>编译器 — TODO</h4><ul><li> <strong>C1</strong></li><li> <strong>C2</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h2 id=&quot;Java编译器浅析&quot;&gt;&lt;a href=&quot;#Java编译器浅析&quot; class=&quot;headerlink&quot; title=&quot;Java编译器浅析&quot;&gt;&lt;/a&gt;Java编译器浅析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地代码</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC垃圾回收器与算法深入浅出</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-15T10:01:27.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC浅析"><a href="#JVM之GC浅析" class="headerlink" title="JVM之GC浅析"></a>JVM之GC浅析</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd42l4mej319j0jt762.jpg" alt="image-20210320093842591"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwceol0aqkj30fy091aa8.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwfzkk2861j30u00q7ju1.jpg" alt="img"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd4ba2k2j30k006yjrz.jpg" alt="img"></p><h4 id="堆特性"><a href="#堆特性" class="headerlink" title="堆特性"></a>堆特性</h4><ul><li>Eden <ul><li>存活对象少</li></ul></li><li>S1</li><li>S2</li><li>Old<ul><li>存活对象多</li></ul></li></ul><h4 id="对象存活晋升过程"><a href="#对象存活晋升过程" class="headerlink" title="对象存活晋升过程"></a>对象存活晋升过程</h4><ul><li>按年龄</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。</span><br><span class="line"></span><br><span class="line">Paralle Scavenge 15</span><br><span class="line">CMS 6</span><br><span class="line">G1 15</span><br></pre></td></tr></table></figure><ul><li>动态年龄分配函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line">//survivor_capacity是survivor空间的大小</span><br><span class="line">  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);</span><br><span class="line">  size_t total = 0;</span><br><span class="line">  uint age = 1;</span><br><span class="line">  while (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];//sizes数组是每个年龄段对象大小</span><br><span class="line">    if (total &gt; desired_survivor_size) break;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="什么是垃圾？（对象引用详解）"><a href="#什么是垃圾？（对象引用详解）" class="headerlink" title="什么是垃圾？（对象引用详解）"></a>什么是垃圾？（对象引用详解）</h4><ul><li><p><strong>什么是强引用Strong Reference？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。</span><br></pre></td></tr></table></figure></li><li><p><strong>什么情况下会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">o = null;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>什么是软引用SoftReference？</strong></p><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Student&gt;studentSoftReference=new SoftReference&lt;Student&gt;(new Student());</span><br><span class="line">        Student student = studentSoftReference.get();</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        </span><br><span class="line"> SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;byte[]&gt;(new byte[1024*1024*10]);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        byte[] bytes = new byte[1024 * 1024 * 10];</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">//// 将内存调小 -Xmx20M ，输出结果：</span><br><span class="line"></span><br><span class="line">[B@11d7fff</span><br><span class="line">[B@11d7fff</span><br><span class="line">null</span><br></pre></td></tr></table></figure></li><li><p><strong>什么时候会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当JVM内存不足，执行GC后，内存依然不足，会回收软引用.</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>什么是弱引用WeakReference？</strong></p><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1]);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        </span><br><span class="line">//输出结果：        </span><br><span class="line">[B@11d7fff</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>什么情况下会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要触发GC就会被回收.</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>什么是虚引用PhantomReference？</strong></p><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NIO中，就运用了虚引用管理堆外内存，用于堆外内存的释放.</span><br></pre></td></tr></table></figure><ul><li><p>看官方源码注释 ： 本大神硬核翻译！希望你能懂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Phantom reference objects, which are enqueued after the collector</span><br><span class="line"> * determines that their referents may otherwise be reclaimed.  Phantom</span><br><span class="line"> * references are most often used for scheduling pre-mortem cleanup actions in</span><br><span class="line"> * a more flexible way than is possible with the Java finalization mechanism.</span><br><span class="line"> *</span><br><span class="line"> </span><br><span class="line">虚引用对象，在垃圾收集器决定这些引用可能被回收时入队，</span><br><span class="line">虚引用经常用于在“对象死亡后，对对象进行死亡讣告” </span><br><span class="line">是一种可能比Java直接回收的更灵活一种方式.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> * &lt;p&gt; If the garbage collector determines at a certain point in time that the</span><br><span class="line"> * referent of a phantom reference is &lt;a</span><br><span class="line"> * href=&quot;package-summary.html#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that</span><br><span class="line"> * time or at some later time it will enqueue the reference.</span><br><span class="line"> *</span><br><span class="line"> //此段没有太大的意义</span><br><span class="line"> </span><br><span class="line"> * &lt;p&gt; In order to ensure that a reclaimable object remains so, the referent of</span><br><span class="line"> * a phantom reference may not be retrieved: The &lt;code&gt;get&lt;/code&gt; method of a</span><br><span class="line"> * phantom reference always returns &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line"> *</span><br><span class="line"> // 为了保证 已确定回收对象 的规则， 虚引用不再返回该对象的引用.</span><br><span class="line"> </span><br><span class="line"> * &lt;p&gt; Unlike soft and weak references, phantom references are not</span><br><span class="line"> * automatically cleared by the garbage collector as they are enqueued.  An</span><br><span class="line"> * object that is reachable via phantom references will remain so until all</span><br><span class="line"> * such references are cleared or themselves become unreachable.</span><br><span class="line"> *</span><br><span class="line"> * @author   Mark Reinhold</span><br><span class="line"> * @since    1.2</span><br><span class="line"> */</span><br><span class="line"> //不像其他引用一样，在虚引用入队后不会自动被垃圾回收器清理,</span><br><span class="line"> 一个可达对象被虚引用所引用后会一直保持在列队，直到这些引用被清理或者这些引用变得不可达.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> =================================</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Reference queues, to which registered reference objects are appended by the</span><br><span class="line"> * garbage collector after the appropriate reachability changes are detected.</span><br><span class="line"> *</span><br><span class="line"> * @author   Mark Reinhold</span><br><span class="line"> * @since    1.2</span><br><span class="line"> */</span><br><span class="line"> 当垃圾回收器在适合的时机检测到可达性发生改变时决定 将这些 引用 加入列队.</span><br><span class="line"></span><br><span class="line">public class ReferenceQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>什么情况下会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;A对象 被回收了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void freeMem() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行堆外内存释放&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;B对象 被回收了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    final  int a = 0;</span><br><span class="line">    final int b =10;</span><br><span class="line">    final static int c = 0;</span><br><span class="line">    volatile int d = 0;</span><br><span class="line">    volatile int e = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        PerformanceTest p = new PerformanceTest();</span><br><span class="line">        //p.test(0,0);</span><br><span class="line">        //打印当前对象内存分布</span><br><span class="line">        //System.out.println(VM.current().details());</span><br><span class="line">        //System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable());</span><br><span class="line">        //虚引用测试</span><br><span class="line">        p.phantomReferenceTest();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void phantomReferenceTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class="line">        //强引用</span><br><span class="line">        A a = new A();</span><br><span class="line">        B b = new B();</span><br><span class="line">        //虚引用</span><br><span class="line">        PhantomReference&lt;A&gt; reference = new PhantomReference&lt;A&gt;(new A(),queue);</span><br><span class="line">        //弱引用</span><br><span class="line">        WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1024*1024*10]);</span><br><span class="line">        System.out.println(&quot;强引用GC回收前强引用=====================&quot;+a);</span><br><span class="line">        System.out.println(&quot;强引用GC回收前弱引用：=====================&quot;+weakReference.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //此线程触发GC 设置-Xmx20M</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 30;i++ ) &#123;</span><br><span class="line">                bytes.add(new byte[1024 * 1024]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;强引用GC回收后弱引用：=====================&quot;+weakReference.get());</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Reference poll = queue.poll();</span><br><span class="line">                if (poll != null) &#123;</span><br><span class="line">                    System.out.println(&quot;虚引用被回收了：&quot; + poll);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll == null) &#123;</span><br><span class="line">                    System.out.println(&quot;内存中没有引虚拟引用了，被清理了&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        new A().freeMem();</span><br><span class="line">                    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                        throwable.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;强引用GC回收后强引用A:=====================&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出结果:     执行结果有乱序，不影响，用序号标记解释</span><br><span class="line"></span><br><span class="line">1.强引用GC回收前强引用=====================com.mybrainsbox.performance.A@621be5d1</span><br><span class="line">2.强引用GC回收前弱引用：=====================[B@573fd745</span><br><span class="line">3.A对象 被回收了</span><br><span class="line">4.强引用GC回收后弱引用：=====================null</span><br><span class="line">5.强引用GC回收后强引用A:=====================com.mybrainsbox.performance.A@621be5d1</span><br><span class="line">6.虚引用被回收了：java.lang.ref.PhantomReference@6d39548b</span><br><span class="line">7.内存中没有引虚拟引用了，被清理了</span><br><span class="line">8.B对象 被回收了</span><br><span class="line">9.执行堆外内存释放</span><br><span class="line">10.A对象 被回收了</span><br><span class="line">====================================================</span><br><span class="line"></span><br><span class="line">3.A对象 被回收了  这一步输出对应 ：         </span><br><span class="line">PhantomReference&lt;A&gt; reference = new PhantomReference&lt;A&gt;(new A(),queue);</span><br><span class="line">一旦触发GC, 被PhantomReference引用的对象都会被设置为弱引用，并加入虚引用列队.等待回收.</span><br><span class="line">所以这一步在GC触发时输出.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.虚引用被回收了：java.lang.ref.PhantomReference@6d39548b</span><br><span class="line">这一步是 虚引用列队在GC后拿到被虚引用引用的new A()最后的回执，所有的可达性检测决定可能要回收的对象都会被加入此列队，直到poll()出全部.</span><br><span class="line"></span><br><span class="line">7.内存中没有引虚拟引用了，被清理了;</span><br><span class="line">这一步是poll出了所有的虚引用的对象列队;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.B对象 被回收了</span><br><span class="line">10.A对象 被回收了</span><br><span class="line">8和10是方法出栈被回收的.</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="怎么样找到垃圾？"><a href="#怎么样找到垃圾？" class="headerlink" title="怎么样找到垃圾？"></a>怎么样找到垃圾？</h4><ul><li><p><strong>引用计数器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在对象头里，有数据位表示该对象有没有引用，当引用计数为0对象将被回收.</span><br></pre></td></tr></table></figure><ul><li>缺陷 ：<strong>循环引用</strong>  容易引起孤岛效应—- 即 ： A -&gt; B -&gt; C , 3个对象互相引用，计数不为0，但实际已经没有任何引用指向这三个对象.</li></ul></li></ul><ul><li><strong>Root Searching 根可达算法</strong>  <ul><li><strong>根路径</strong><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li></ul></li></ul></li></ul><h4 id="常见GC垃圾回收算法"><a href="#常见GC垃圾回收算法" class="headerlink" title="常见GC垃圾回收算法"></a>常见GC垃圾回收算法</h4><ul><li><p>标记  -&gt; 清除</p><ul><li><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，标记过程：</span><br><span class="line">从GC root出发遍历所有对象，在可达对象头中的markeword进行标记. </span><br><span class="line"></span><br><span class="line">2，清理过程：遍历堆中对象，判断对象头markword是否存活标记，进行回收.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>缺陷</p><ul><li><p>效率问题：需要2遍扫描，标记和清除都需要遍历，效率不高；</p></li><li><p>空间问题：标记清除后会产生大量不连续的内存水平，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。</p></li></ul></li><li><p>适用堆区</p><ul><li>Old</li></ul></li><li><p>触发GC类型</p><ul><li>Major GC/老年代GC</li></ul></li></ul></li></ul><ul><li><p>标记 -&gt; 复制</p><ul><li><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，标记 : 将年轻代的空间一分为三，[Eden],[ s1 ] ,[ s2 ]，比例是：8：1：1 ，</span><br><span class="line"></span><br><span class="line">2，复制: 当使用 s1内存块 使用率达到阈值，s2空白，将存活对象复制到s2内存空间.</span><br><span class="line"></span><br><span class="line">3,清理 : 清理s1空间块. 通过这个方式避免了碎片化空间问题.</span><br></pre></td></tr></table></figure></li><li><p>缺陷</p><ul><li>效率问题：标记和清除都需要遍历，效率不高；</li><li>空间问题：内存空间浪费，最大10%，</li></ul></li><li><p>适用堆区</p><ul><li>Eden</li></ul></li><li><p>触发GC类型</p><ul><li>MinorGC/年轻代GC</li></ul></li></ul></li><li><p>标记 -&gt; 压缩（整理）</p><ul><li><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，先标记</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2，压缩整理： 把可达对象往内存块偏移量折中的任意一端移动，达到空间整洁规整。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>缺陷</p><ul><li>效率问题：需要扫描2次，移动对象引用需要重新引用地址，，效率不如复制算法高效；</li></ul></li><li><p>适用堆区</p><ul><li> Old</li></ul></li></ul><ul><li>触发GC类型<ul><li>Major GC/老年代GC</li></ul></li></ul></li></ul><h4 id="GC垃圾回收器（算法的实现）"><a href="#GC垃圾回收器（算法的实现）" class="headerlink" title="GC垃圾回收器（算法的实现）"></a>GC垃圾回收器（算法的实现）</h4><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><h4 id="STW安全点"><a href="#STW安全点" class="headerlink" title="STW安全点"></a>STW安全点</h4><ul><li>编译器提前编译好安全区域标志位，通过对象oopmap映射，GC通过opmap表来判断线程是否到达对象安全点.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">HotSpot 用的就是映射表，这个表叫 OopMap。</span><br><span class="line"></span><br><span class="line">在 HotSpot 中，对象的类型信息里会记录自己的 OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据，而在解释器中执行的方法可以通过解释器里的功能自动生成出 OopMap 出来给 GC 用。</span><br><span class="line"></span><br><span class="line">被 JIT 编译过的方法，也会在特定的位置生成 OopMap，记录了执行到该方法的某条指令时栈上和寄存器里哪些位置是引用。</span><br><span class="line"></span><br><span class="line">这些特定的位置主要在：</span><br><span class="line"></span><br><span class="line">循环的末尾（非 counted 循环）</span><br><span class="line"></span><br><span class="line">方法临返回前 / 调用方法的call指令后</span><br><span class="line"></span><br><span class="line">可能抛异常的位置</span><br><span class="line"></span><br><span class="line">这些位置就叫作安全点(safepoint)。</span><br><span class="line"></span><br><span class="line">那为什么要选择这些位置插入呢？因为如果对每条指令都记录一个 OopMap 的话空间开销就过大了，因此就选择这些个关键位置来记录即可。</span><br><span class="line"></span><br><span class="line">所以在 HotSpot 中 GC 不是在任何位置都能进入的，只能在安全点进入。</span><br><span class="line"></span><br><span class="line">至此我们知晓了可以在类加载时计算得到对象类型中的 OopMap，解释器生成的 OopMap 和 JIT 生成的 OopMap ，所以 GC 的时候已经有充足的条件来准确判断对象类型。</span><br><span class="line"></span><br><span class="line">因此称为准确式 GC。</span><br><span class="line"></span><br><span class="line">其实还有个 JNI 调用，它们既不在解释器执行，也不会经过 JIT 编译生成，所以会缺少 OopMap。</span><br><span class="line"></span><br><span class="line">在 HotSpot 是通过句柄包装来解决准确性问题的，像 JNI 的入参和返回值引用都通过句柄包装起来，也就是通过句柄再访问真正的对象。</span><br><span class="line"></span><br><span class="line">这样在 GC 的时候就不用扫描 JNI 的栈帧，直接扫描句柄表就知道 JNI 引用了 GC 堆中哪些对象了。</span><br><span class="line"></span><br><span class="line">安全点</span><br><span class="line"></span><br><span class="line">我们已经提到了安全点，安全点当然不是只给记录 OopMap 用的，因为 GC 需要一个一致性快照，所以应用线程需要暂停，而暂停点的选择就是安全点。</span><br><span class="line"></span><br><span class="line">我们来捋一遍思路。首先给个 GC 名词，在垃圾收集场景下将应用程序称为 mutator 。</span><br><span class="line"></span><br><span class="line">一个能被 mutator 访问的对象就是活着的，也就是说 mutator 的上下文包含了可以访问存活对象的数据。</span><br><span class="line"></span><br><span class="line">这个上下文其实指的就是栈、寄存器等上面的数据，对于 GC 而言它只关心栈上、寄存器等哪个位置是引用，因为它只需要关注引用。</span><br><span class="line"></span><br><span class="line">但是上下文在 mutator 运行过程中是一直在变化的，所以 GC 需要获取一个一致性上下文快照来枚举所有的根对象。</span><br><span class="line"></span><br><span class="line">而快照的获取需要停止 mutator 所有线程，不然就得不到一致的数据，导致一些活着对象丢失，这里说的一致性其实就像事务的一致性。</span><br><span class="line"></span><br><span class="line">而 mutator 所有线程中这些有机会成为暂停位置的点就叫 safepoint 即安全点。</span><br><span class="line"></span><br><span class="line">openjdk 官网对安全点的定义是：</span><br><span class="line"></span><br><span class="line">A point during program execution at which all GC roots are known and all heap object contents are consistent. From a global point of view, all threads must block at a safepoint before the GC can run.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在JIT执行方式下，JIT编译的时候直接把Safepoint的检查代码加入了生成的本地代码。当JVM需要让Java线程进入Safepoint时，只需要设置一个标志位，让Java线程运行到Safepoint时主动检查这个标志位，如果标志被设置，那么线程停顿，如果没有被设置，那么继续执行。如HotSpot在x86中为轮询Safepoint会生成一条类似于test汇编指令。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcgefrhokj31g20u0ahv.jpg" alt="image-20211112163726225"></p><h4 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h4><ul><li>l</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC浅析&quot;&gt;&lt;a href=&quot;#JVM之GC浅析&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC浅析&quot;&gt;&lt;/a&gt;JVM之GC浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.si</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java对象内存分布</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T09:12:21.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java对象内存分布"><a href="#Java对象内存分布" class="headerlink" title="Java对象内存分布"></a>Java对象内存分布</h2><p>Wirte by 021.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbbdazz1gj30va0u0gpj.jpg" alt="image-20211111165741691"></p><ul><li><strong>对象全局图</strong></li></ul><p>​    <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbataffm6j30k00ct74n.jpg" alt="img"></p><ul><li><p><strong>头部markword</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbaul5a3lj30k006yjrz.jpg" alt="img"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java对象内存分布&quot;&gt;&lt;a href=&quot;#Java对象内存分布&quot; class=&quot;headerlink&quot; title=&quot;Java对象内存分布&quot;&gt;&lt;/a&gt;Java对象内存分布&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java运行时数据区浅析---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T10:19:31.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之运行时数据区-————–-TODO"><a href="#JVM之运行时数据区-————–-TODO" class="headerlink" title="JVM之运行时数据区 ————–   TODO"></a>JVM之运行时数据区 ————–   TODO</h2><p>Wirte by 021.</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbc2zlq9nj31060n5jvn.jpg" alt="image-20211111172223120"></h4><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    final  int a = 0;</span><br><span class="line">    final int b =10;</span><br><span class="line">    final static int c = 0;</span><br><span class="line">    volatile int d = 0;</span><br><span class="line">    volatile int e = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line">        PerformanceTest p = new PerformanceTest();</span><br><span class="line">        p.test(a,b);</span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">        System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int test(int a , int b)&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(this.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Long.class.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Integer.class.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Progarm-Counter-程序计数器"><a href="#Progarm-Counter-程序计数器" class="headerlink" title="Progarm Counter 程序计数器"></a>Progarm Counter 程序计数器</h4><ul><li>执行代码行标记</li></ul><h4 id="JVM-stack-方法栈"><a href="#JVM-stack-方法栈" class="headerlink" title="JVM stack 方法栈"></a>JVM stack 方法栈</h4><ul><li><p>Local Variable Table 局部变量表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args[]</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Operand Stack 操作数栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>Dynamic Linking 静态连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前线程在运行时与常量池符号的连接. 指向常量池的变量.  示例代码中：final static int c = 0，p.test(0,0);;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Retuen Address 返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数执行结果的值地址存入栈顶. p.test(a,b) = return a + b;</span><br></pre></td></tr></table></figure></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul><li>Native  本地方法相关方法栈.</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>l</li></ul><h4 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h4><ul><li>JVM可以直接访问的内核空间内存，0拷贝。</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li></li></ul><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认： -Xmixed 混合模式</span><br><span class="line">-Xint 解释模式，启动块，执行稍微慢</span><br><span class="line">-XComp 编译模式，启动时间慢，需要编译</span><br></pre></td></tr></table></figure><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之运行时数据区-————–-TODO&quot;&gt;&lt;a href=&quot;#JVM之运行时数据区-————–-TODO&quot; class=&quot;headerlink&quot; title=&quot;JVM之运行时数据区 ————–   TODO&quot;&gt;&lt;/a&gt;JVM之运行时数据区 ————–   TO</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Btree之Mysql自顶向下</title>
    <link href="http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T15:40:05.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析"><a href="#M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析" class="headerlink" title="M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析"></a>M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbmoyywxmj30xp0j0gnc.jpg" alt="B+ Tree structure with buckets (Begginer question) - Database  Administrators Stack Exchange"></p><div class="row">    <embed src="./数据结构Btree之Mysql自顶向下.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析&quot;&gt;&lt;a href=&quot;#M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析&quot; class=&quot;h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树结构" scheme="http://www.010101.cc/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC垃圾回收器浅析</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-18T06:12:11.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC垃圾回收器浅析"><a href="#JVM之GC垃圾回收器浅析" class="headerlink" title="JVM之GC垃圾回收器浅析"></a>JVM之GC垃圾回收器浅析</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd42l4mej319j0jt762.jpg" alt="image-20210320093842591"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwceol0aqkj30fy091aa8.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfra35t1j30xe0d5775.jpg" alt="image-20211112161507515"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd4ba2k2j30k006yjrz.jpg" alt="img"></p><h4 id="GC垃圾回收器的目标"><a href="#GC垃圾回收器的目标" class="headerlink" title="GC垃圾回收器的目标"></a>GC垃圾回收器的目标</h4><ul><li><strong>减少GC停顿时间</strong></li><li><strong>避免程序崩溃</strong></li><li><strong>优化JVM内存空间</strong></li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul><li><strong>基于 标记-清除 算法</strong></li><li><strong>适用于老年代</strong></li></ul><ul><li><p><strong>回收过程</strong></p><ul><li><strong>初始标记 STW</strong></li><li><strong>并发标记</strong></li><li><strong>重新标记 STW</strong></li><li><strong>并发清除</strong></li></ul></li><li><p><strong>缺陷</strong></p><ul><li><p><strong>2次STW</strong></p></li><li><p><strong>内存碎片化</strong></p></li></ul></li></ul><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul><li><p><strong>回收过程</strong></p><ul><li><strong>初始标记 STW</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记(重新标记) STW</strong></li><li>并发计算回收STW**</li></ul></li></ul><ul><li><p><strong>核心算法</strong></p><ul><li><p><strong>RememberSet</strong></p></li><li><p><strong>卡表 CardTable</strong></p></li></ul></li></ul><h3 id="王者ZGC"><a href="#王者ZGC" class="headerlink" title="王者ZGC"></a>王者ZGC</h3><ul><li><p><strong>回收过程</strong></p><ul><li><p><strong>初始标记 STW</strong></p></li><li><p><strong>并发标记</strong></p></li><li><p><strong>并发转移STW</strong></p></li></ul></li><li><p><strong>核心算法</strong></p><ul><li><p><strong>标记对象指针</strong></p><ul><li><strong>暂时可以理解为在64位内存地址中取三个标志位映射对象的同一块物理内存地址，标记对象的标记过程，重新定位过程，等GC回收标志</strong></li></ul></li><li><p><strong>合理利用64位处理器架构 ，Numa架构</strong></p><ul><li><strong>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那其中一颗CPU上的12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。</strong></li></ul></li><li><p><strong>读屏障</strong></p><ul><li>因为在标记和移动过程中，GC线程和应用线程是并发执行的，所以存在这种情况：对象A内部的引用所指的对象B在标记或者移动状态，为了保证应用线程拿到的B对象是对的，那么在读取B的指针时会经过一个 “load barriers” 读屏障，这个屏障可以保证在执行GC时，数据读取的正确性。</li></ul></li><li><p><strong>Compacting 内存页压缩</strong></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC垃圾回收器浅析&quot;&gt;&lt;a href=&quot;#JVM之GC垃圾回收器浅析&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC垃圾回收器浅析&quot;&gt;&lt;/a&gt;JVM之GC垃圾回收器浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a me</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构RingBuffer之机械之美---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84RingBuffer%E4%B9%8B%E6%9C%BA%E6%A2%B0%E4%B9%8B%E7%BE%8E---TODO/"/>
    <id>http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84RingBuffer%E4%B9%8B%E6%9C%BA%E6%A2%B0%E4%B9%8B%E7%BE%8E---TODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-18T04:45:53.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构RingBuffer之机械之美"><a href="#数据结构RingBuffer之机械之美" class="headerlink" title="数据结构RingBuffer之机械之美"></a>数据结构RingBuffer之机械之美</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbmoyywxmj30xp0j0gnc.jpg" alt="B+ Tree structure with buckets (Begginer question) - Database  Administrators Stack Exchange"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构RingBuffer之机械之美&quot;&gt;&lt;a href=&quot;#数据结构RingBuffer之机械之美&quot; class=&quot;headerlink&quot; title=&quot;数据结构RingBuffer之机械之美&quot;&gt;&lt;/a&gt;数据结构RingBuffer之机械之美&lt;/h2&gt;&lt;p&gt;Wi</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="线性结构" scheme="http://www.010101.cc/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>经典设计之AQS与ConcurrentHashMap---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E4%B9%8BAQS%E4%B8%8EConcurrentHashMap---TODO/"/>
    <id>http://www.010101.cc/2021/11/11/%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E4%B9%8BAQS%E4%B8%8EConcurrentHashMap---TODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-18T04:47:09.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典设计之AQS与ConcurrentHashMap—TODO"><a href="#经典设计之AQS与ConcurrentHashMap—TODO" class="headerlink" title="经典设计之AQS与ConcurrentHashMap—TODO"></a>经典设计之AQS与ConcurrentHashMap—TODO</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbmoyywxmj30xp0j0gnc.jpg" alt="B+ Tree structure with buckets (Begginer question) - Database  Administrators Stack Exchange"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经典设计之AQS与ConcurrentHashMap—TODO&quot;&gt;&lt;a href=&quot;#经典设计之AQS与ConcurrentHashMap—TODO&quot; class=&quot;headerlink&quot; title=&quot;经典设计之AQS与ConcurrentHashMap—TOD</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="设计模式" scheme="http://www.010101.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>内核之线程与进程的关系</title>
    <link href="http://www.010101.cc/2021/11/10/E_Process/"/>
    <id>http://www.010101.cc/2021/11/10/E_Process/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-10T12:33:50.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程关系"><a href="#线程与进程关系" class="headerlink" title="线程与进程关系"></a>线程与进程关系</h2><ul><li><p>进程是资源集合，提供cr3的值，cr3是页目录表的基址，cr3确定了，线程才能访问.</p></li><li><p>一个进程有多个线程，但至少有一个线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，进程提供了空间上概念,进程提供了线程哪些空间地址可以访问的逻辑。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwab540zozj30pr0a8gmv.jpg" alt="image-20211110200416873"></p></li></ul><ul><li><p>创建进程：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwabd1vef8j30oy0dl75r.jpg" alt="image-20211110201154629"></p></li></ul><ul><li><p>通过线程如何找到进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* thread -&gt; cr3页面 -&gt; _Kprocess 的指针</span><br><span class="line"></span><br><span class="line">假如线程执行：</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr ds:[0x12345678]</span><br><span class="line"></span><br><span class="line">cpu的解析路径： </span><br><span class="line"></span><br><span class="line">1，线程拿到当前进程的 cr3 值 Kprocess_directoryTableBase(+0x018) </span><br><span class="line">2，通过cr3的寄存器页表目录定位物理页</span><br><span class="line"></span><br><span class="line">3,EThread结构体：</span><br><span class="line">&#123;</span><br><span class="line">0x000 KThread 结构体 </span><br><span class="line">&#123;</span><br><span class="line">  0x034  _KAPC_STAT</span><br><span class="line">  &#123;</span><br><span class="line">  0x10 ptr32 EPROCESS;</span><br><span class="line">  0x044 , cmp [esi, prt* process]  </span><br><span class="line">  #SWapContext时会比较 44 和 220 的值是否一样，不一样会造成进程空间切换，cr3切换，详情见进程挂靠</span><br><span class="line">  #44位置上提供是cr3的值，资源提供方的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">0x220 ptr32 EPROCESS #当前线程所属进程，当前线程是谁创建的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程与进程关系&quot;&gt;&lt;a href=&quot;#线程与进程关系&quot; class=&quot;headerlink&quot; title=&quot;线程与进程关系&quot;&gt;&lt;/a&gt;线程与进程关系&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程是资源集合，提供cr3的值，cr3是页目录表的基址，cr3确定了，线程才能访问</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="进程&amp;线程" scheme="http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>高并发之CAS自顶向下</title>
    <link href="http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-16T12:32:12.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发之CAS自顶向下"><a href="#高并发之CAS自顶向下" class="headerlink" title="高并发之CAS自顶向下"></a>高并发之CAS自顶向下</h2><p>Wirte by 021. </p><p><strong>机器级代码</strong></p><p>计算机系统使用了多种不同形式的抽象，可以通过一个简单的抽象模型来隐藏实现细节。对于机器级别的程序来说，有两点非常重要。</p><p>首先第一点，定义机器级别程序的格式和行为被称为 指令集体系结构或指令集架构(instruction set architecture)， ISA。ISA 定义了进程状态、指令的格式和每一个指令对状态的影响。大部分的指令集架构包括 ISA 用来描述进程的行为就好像是顺序执行的，一条指令执行结束后，另外一条指令再开始。处理器硬件的描述要更复杂，它可以同时并行执行许多指令，但是它采用了安全措施来确保整体行为与 ISA 规定的顺序一致。</p><p>第二点，机器级别对内存地址的描述就是 虚拟地址(virtual address)，它提供了一个内存模型来表示一个巨大的字节数组。</p><p>编译器在整个编译的过程中起到了至关重要的作用，把 C 语言转换为处理器执行的基本指令。汇编代码非常接近于机器代码，只不过与二进制机器代码相比，汇编代码的可读性更强，所以理解汇编是理解机器工作的第一步。</p><p>一些进程状态对机器可见，但是 C 语言程序员却看不到这些，包括</p><ul><li>程序计数器(Program counter)，它存储下一条指令的地址，在 x86-64 架构中用 %rip 来表示。</li></ul><p>程序执行时，PC 的初始值为程序第一条指令的地址，在顺序执行程序时， CPU 首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 并指向下一条要执行的指令。</p><p>比如下面一个例子。 </p><p>这是一段数值进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。由于使用机器语言难以描述，所以这是经过翻译后的结果，实际上每个指令和数据都可能分布在不同的地址上，但为了方便说明，把组成一条指令的内存和数据放在了一个内存地址上。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4t8tyh2j316i0tqgpf.jpg" alt="image-20211110162521277"></p><ul><li><p>整数寄存器文件(register file)包含 16 个命名的位置，用来存储 64 位的值。这些寄存器可以存储地址和整型数据。有些寄存器用于跟踪程序状态，而另一些寄存器用于保存临时数据，例如过程的参数和局部变量，以及函数要返回的值。这个 文件 是和磁盘文件无关的，它只是 CPU 内部的一块高速存储单元。有专用的寄存器，也有通用的寄存器用来存储操作数。</p></li><li><p>条件码寄存器 用来保存有关最近执行的算术或逻辑指令的状态信息。这些用于实现控件或数据流中的条件更改，例如实现 if 和 while 语句所需的条件更改。我们都学过高级语言，高级语言中的条件控制流程主要分为三种：顺序执行、条件分支、循环判断三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。</p></li><li><ul><li>顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。</li><li>条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。</li></ul></li></ul><p>下面以条件分支为例来说明程序的执行过程（循环也很相似）</p><p>程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序+1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 if() 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4w0dt81j317q0sogpd.jpg" alt="image-20211110162801553"></p><ul><li>一组 向量寄存器用来存储一个或者多个整数或者浮点数值，向量寄存器是对一维数据上进行操作。</li></ul><p>机器指令只会执行非常简单的操作，例如将存放在寄存器的两个数进行相加，把数据从内存转移到寄存器中或者是条件分支转移到新的指令地址。编译器必须生成此类指令的序列，以实现程序构造，例如算术表达式求值，循环或过程调用和返回</p><p><strong>认识汇编</strong></p><p>我相信各位应该都知道汇编语言的出现背景吧，那就是二进制表示数据，太复杂太庞大了，为了解决这个问题，出现了汇编语言，汇编语言和机器指令的区别就在于表示方法上，汇编使用操作数来表示，机器指令使用二进制来表示，我之前多次提到机器码就是汇编，你也不能说我错，但是不准确。</p><p>但是汇编适合二进制代码存在转换关系的。</p><p>汇编代码需要经过 汇编器 编译后才产生二进制代码，这个二进制代码就是目标代码，然后由链接器将其连接起来运行。</p><p>汇编语言主要分为以下三类</p><ul><li>汇编指令：它是一种机器码的助记符，它有对应的机器码</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号，比如 +、-、*、/ 等，由编译器识别，没有对应的机器码</li></ul><p>汇编语言的核心是汇编指令，而我们对汇编的探讨也是基于汇编指令展开的。</p><p><strong>与汇编有关的硬件和概念</strong></p><p><strong>CPU</strong></p><p>CPU 是计算机的大脑，它也是整个计算机的核心，它也是执行汇编语言的硬件，CPU 的内部包含有寄存器，而寄存器是用于存储指令和数据的，汇编语言的本质也就是 CPU 内部操作数所执行的一系列计算。</p><p><strong>内存</strong></p><p>没有内存，计算机就像是一个没有记忆的人类，只会永无休止的重复性劳动。CPU 所需的指令和数据都由内存来提供，CPU 指令经由内存提供，经过一系列计算后再输出到内存。</p><p><strong>磁盘</strong></p><p>磁盘也是一种存储设备，它和内存的最大区别在于永久存储，程序需要在内存装载后才能运行，而提供给内存的程序都是由磁盘存储的。</p><p><strong>总线</strong></p><p>一般来说，内存内部会划分多个存储单元，存储单元用来存储指令和数据，就像是房子一样，存储单元就是房子的门牌号。而 CPU 与内存之间的交互是通过地址总线来进行的，总线从逻辑上分为三种</p><ul><li>地址线</li><li>数据线</li><li>控制线</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4wdydrlj30ua0i8js4.jpg" alt="image-20211110162824440"></p><p>CPU 与存储器之间的读写主要经过以下几步</p><p><strong>读操作步骤</strong></p><ul><li>CPU 通过地址线发出需要读取指令的位置</li><li>CPU 通过控制线发出读指令</li><li>内存把数据放在数据线上返回给 CPU</li></ul><p><strong>写操作步骤</strong></p><ul><li>CPU 通过地址线发出需要写出指令的位置</li><li>CPU 通过控制线发出写指令</li><li>CPU 把数据通过数据线写入内存</li></ul><p>下面我们就来具体了解一下这三类总线</p><p><strong>地址总线</strong></p><p>通过我们上面的探讨，我们知道 CPU 通过地址总线来指定存储位置的，地址总线上能传送多少不同的信息，CPU 就可以对多少个存储单元进行寻址。</p><p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4ww372uj30zs0scmyo.jpg" alt="image-20211110162852156"></p><p>上图中 CPU 和内存中间信息交换通过了 10 条地址总线，每一条线能够传递的数据都是 0 或 1 ，所以上图一次 CPU 和内存传递的数据是 2 的十次方。</p><p>所以，如果 CPU 有 N 条地址总线，那么可以说这个地址总线的宽度是 N 。这样 CPU 可以寻找 2 的 N 次方个内存单元。</p><p><strong>数据总线</strong></p><p>CPU 与内存或其他部件之间的数据传送是由数据总线来完成的。数据总线的宽度决定了 CPU 和外界的数据传输速度。8 根数据总线可以一次传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可以传输两个字节，32 根数据总线可以一次传输四个字节。。。。。。</p><p><strong>控制总线</strong></p><p>CPU 与其他部件之间的控制是通过 控制总线 来完成的。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部部件的控制能力。</p><p><strong>一次内存的读取过程</strong></p><p><strong>内存结构</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4x4nwgvj31660u0gnz.jpg" alt="image-20211110162906306"></p><p>内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图</p><p>图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，**+5V** <strong>表示<strong><strong>1</strong></strong>，****0V</strong> <strong>表示</strong> <strong>0</strong>。</p><p>我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = 1024个地址。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。</p><p>如果我们使用的是 512 MB 的内存，这就相当于是 512000（512 * 1000） 个内存 IC。当然，一台计算机不太可能有这么多个内存 IC ，然而，通常情况下，一个内存 IC 会有更多的引脚，也就能存储更多数据。</p><p><strong>内存读取过程</strong></p><p>下面是一次内存的读取过程。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4xgmz6cj30zj0u041w.jpg" alt="image-20211110162922419"></p><p>来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：</p><ul><li><p>首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 A0 - A9 来指定数据的存储场所，然后再把数据的值输入给 D0 - D7 的数据信号，并把 WR（write）的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据</p></li><li><p>读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。</p></li><li><p>图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。</p></li></ul><h2 id="CAS原子性操作之汇编"><a href="#CAS原子性操作之汇编" class="headerlink" title="CAS原子性操作之汇编"></a>CAS原子性操作之汇编</h2><h3 id="自旋锁本质"><a href="#自旋锁本质" class="headerlink" title="自旋锁本质"></a>自旋锁本质</h3><ul><li><p><strong>模拟临界区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//设置全局变量</span><br><span class="line">flag = 0;</span><br><span class="line"></span><br><span class="line">Lab:</span><br><span class="line">mov eax,1; </span><br><span class="line">lock xadd [flag],eax;   //先交换 ，flag = 1,eax =0; 再相加 - flag = flag+eax = 1; eax =0; </span><br><span class="line">cmp eax,0;   // 对比eax 是否为0</span><br><span class="line">jz endLab    // cmp指令会影响 标志寄存器， jz根据标志寄存的值进行指令跳转.</span><br><span class="line">dec [flag]   // eax不为0，证明有未能拿到临界区令牌;</span><br><span class="line">//线程等待</span><br><span class="line">endLab:</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>自旋锁源码</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwh9jsumozj30u40aujt0.jpg" alt="image-20211116201638291"></p></li></ul><ul><li><p><strong>伪代码模拟自旋锁</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//取锁</span><br><span class="line">tryLock()&#123;</span><br><span class="line"></span><br><span class="line">boolean flag = lock getLock(); //原子操作, 检查锁，并设置标志位；</span><br><span class="line">if(!flag)&#123;</span><br><span class="line">waitiLock();</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自旋等待</span><br><span class="line">waitiLock()&#123;</span><br><span class="line">boolean flag = checkLock(); //检查锁状态 </span><br><span class="line">if(flag)&#123;</span><br><span class="line">tryLock();</span><br><span class="line">&#125;</span><br><span class="line">sleep(...);</span><br><span class="line">waitiLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>最常见的原子操作有Compare and Exchange,Self Increase/Decrease等等</strong></p><p><strong>8086汇编相关指令</strong> </p><ul><li><p>LOCK:这是一个指令前缀，在所对应的指令操作期间使此指令的目标操作数指定的存储区域锁定，以得到保护。</p></li><li><p>XADD:先交换两个操作数的值，再进行算术加法操作。多处理器安全，在80486及以上CPU中支持。</p></li><li><p>CMPXCHG:比较交换指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上CPU中支持。</p></li><li><p>XCHG:交换两个操作数,其中至少有一个是寄存器寻址.其他寄存器和标志位不受影响.</p></li></ul><p><strong>原子操作函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line">long __stdcall **CompareExchange**(long volatile***Destination**,long **Exchange**,long **Comperand**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Destination**;</span><br><span class="line"></span><br><span class="line">   **mov   edx**, **Exchange**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, **Comperand**;</span><br><span class="line"></span><br><span class="line">   **lock cmpxchg [ecx**], **edx**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">交换</span><br><span class="line"></span><br><span class="line">long __stdcall **Exchange**(long volatile* **Target**,long **Value**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Target**;</span><br><span class="line"></span><br><span class="line">   **mov   edx**, **Value**;</span><br><span class="line"></span><br><span class="line">**label**:</span><br><span class="line"></span><br><span class="line">   **lock cmpxchg [ecx**], **edx**;//加</span><br><span class="line"></span><br><span class="line">   **jnz**   short **label**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自减</span><br><span class="line"></span><br><span class="line">long __stdcall **Decrement**(long volatile* **Addend**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Addend**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, 0FFFFFFFFh;//-1</span><br><span class="line"></span><br><span class="line">   **lock xadd [ecx**], **eax**; //加-1</span><br><span class="line"></span><br><span class="line">   **dec   eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自增</span><br><span class="line"></span><br><span class="line">long __stdcall **Increment**(long volatile* **Addend**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Addend**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, 1;</span><br><span class="line"></span><br><span class="line">   **lock xadd [ecx**], **eax**; //加</span><br><span class="line"></span><br><span class="line">   **inc   eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相加后交换</span><br><span class="line"></span><br><span class="line">long __stdcall **ExchangeAdd**(long volatile* **Addend**,long **Value**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Addend**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, **Value**;</span><br><span class="line"></span><br><span class="line">   **lock xadd [ecx**], **eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">原子操作(2) - 泛型后的原子操作</span><br><span class="line"></span><br><span class="line">32位的数据类型有4种,但是上面的只支持long,怎么办?手工hack?太土了,当然是C++的大规模杀伤性武器template了.</span><br><span class="line"></span><br><span class="line">同时把几个不跨平台的地方抽出来用macro表示.</span><br><span class="line"></span><br><span class="line">目前模板还没有得到concept的支持,所以只能用boost.type_traits低级的手动判断,要求只有32位的整数类型才能实例化这些函数.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#include</span><br><span class="line"></span><br><span class="line">\#include</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#define **CALL_METHOD** __stdcall</span><br><span class="line"></span><br><span class="line">\#define **VOLATILE** volatile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename **T**&gt;</span><br><span class="line"></span><br><span class="line">**T CALL_METHOD compare_exchange32**(**T VOLATILE*****Destination**,**T exchange32**,**T Comperand**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  **BOOST_STATIC_ASSERT**(sizeof(**T**) == 4 &amp;&amp; **boost**::**is_integral**&lt;**T**&gt;::**value**);</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Destination**;</span><br><span class="line"></span><br><span class="line">   **mov   edx**, **exchange32**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, **Comperand**;</span><br><span class="line"></span><br><span class="line">   **lock cmpxchg [ecx**], **edx**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename **T**&gt;</span><br><span class="line"></span><br><span class="line">**T CALL_METHOD exchange32**(**T VOLATILE*** **Target**,**T Value**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  **BOOST_STATIC_ASSERT**(sizeof(**T**) == 4 &amp;&amp; **boost**::**is_integral**&lt;**T**&gt;::**value**);</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   //   mov  ecx, Target;</span><br><span class="line"></span><br><span class="line">   //   mov  edx, Value;   </span><br><span class="line"></span><br><span class="line">   //label:</span><br><span class="line"></span><br><span class="line">   //   lock  cmpxchg [ecx], edx;//加</span><br><span class="line"></span><br><span class="line">   //   jnz  short label;</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Target**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, **Value**;</span><br><span class="line"></span><br><span class="line">   **xchg [ecx**],**eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename **T**&gt;</span><br><span class="line"></span><br><span class="line">**T CALL_METHOD decrement32**(**T VOLATILE*** **Addend**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  **BOOST_STATIC_ASSERT**(sizeof(**T**) == 4 &amp;&amp; **boost**::**is_integral**&lt;**T**&gt;::**value**);</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Addend**;</span><br><span class="line"></span><br><span class="line">   **mov  eax**, 0FFFFFFFFh;//-1</span><br><span class="line"></span><br><span class="line">   **lock xadd [ecx**], **eax**; //加-1</span><br><span class="line"></span><br><span class="line">   **dec   eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename **T**&gt;</span><br><span class="line"></span><br><span class="line">**T CALL_METHOD increment32**(**T VOLATILE*** **Addend**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  **BOOST_STATIC_ASSERT**(sizeof(**T**) == 4 &amp;&amp; **boost**::**is_integral**&lt;**T**&gt;::**value**);</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Addend**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, 1;</span><br><span class="line"></span><br><span class="line">   **lock xadd [ecx**], **eax**; //加</span><br><span class="line"></span><br><span class="line">   **inc   eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename **T**&gt;</span><br><span class="line"></span><br><span class="line">**T CALL_METHOD exchange_add32**(**T VOLATILE*** **Addend**,**T Value**)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  **BOOST_STATIC_ASSERT**(sizeof(**T**) == 4 &amp;&amp; **boost**::**is_integral**&lt;**T**&gt;::**value**);</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line"></span><br><span class="line">  **&#123;**</span><br><span class="line"></span><br><span class="line">   **mov   ecx**, **Addend**;</span><br><span class="line"></span><br><span class="line">   **mov   eax**, **Value**;</span><br><span class="line"></span><br><span class="line">   **lock xadd [ecx**], **eax**;</span><br><span class="line"></span><br><span class="line">  **&#125;**</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高并发之CAS自顶向下&quot;&gt;&lt;a href=&quot;#高并发之CAS自顶向下&quot; class=&quot;headerlink&quot; title=&quot;高并发之CAS自顶向下&quot;&gt;&lt;/a&gt;高并发之CAS自顶向下&lt;/h2&gt;&lt;p&gt;Wirte by 021. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器级代</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="并发原子锁" scheme="http://www.010101.cc/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程等待与唤醒之win32内核浅析</title>
    <link href="http://www.010101.cc/2021/11/10/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92/"/>
    <id>http://www.010101.cc/2021/11/10/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-10T12:36:55.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程唤醒与等待"><a href="#线程唤醒与等待" class="headerlink" title="线程唤醒与等待"></a>线程唤醒与等待</h2><h4 id="等待对象"><a href="#等待对象" class="headerlink" title="等待对象"></a>等待对象</h4><ul><li>伪代码 解释 基于win32 等待对象 与 当前线程 ，被等待对象的关系.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//被等待对象1</span><br><span class="line">int Thread </span><br><span class="line">&#123;</span><br><span class="line">int a = 0;</span><br><span class="line">return a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被等待对象2</span><br><span class="line">int Thread1 </span><br><span class="line">&#123;</span><br><span class="line">int a = 0;</span><br><span class="line">return a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当前主线程 </span><br><span class="line">void main(...)</span><br><span class="line">&#123;</span><br><span class="line">//被等待对象</span><br><span class="line">int a Thead.t1.start;</span><br><span class="line">int a1 = Thead1.t1.start;</span><br><span class="line"></span><br><span class="line">解析 -&gt; 等待对象</span><br><span class="line">waitingforSinglObject(arr[t1,t2],xx);</span><br><span class="line"></span><br><span class="line">只有等待： 等待对象中的被等待对象t1和t2执行完后，当前main线程才能继续执行.</span><br><span class="line">printf(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="逻辑步骤-TODO"><a href="#逻辑步骤-TODO" class="headerlink" title="逻辑步骤-TODO"></a>逻辑步骤-TODO</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject调用内核函数NtWaitForObject,</span><br><span class="line"></span><br><span class="line">NtWaitForObject 调用ObReferenceObjectByHandle,通过当前线程对象句柄找到&#x27;等待对象结构体&#x27;的首地址</span><br><span class="line"></span><br><span class="line">将结构体首地址传递给 KeWaitSingleObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KeWaitSingleObject 步骤：</span><br><span class="line"></span><br><span class="line">1，准备等待块._wait_block; 默认初始4个等待块  </span><br><span class="line">..... 这块内核比较复杂黑盒,todo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">被等待对象：必须具备_DISPATCHER_HEADER属性的对象，</span><br><span class="line"></span><br><span class="line">_DISPATCHER_HEADER结构体</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">+0x004 SingleStat; 信号状态 &gt; 0;</span><br><span class="line">+0x008 WaitListHead; 所有等待块双向链表地址.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">内部处理逻辑伪代码:</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">if(符合条件) // 1,符合超时条件， 等待对象的信号量 &gt; 0;</span><br><span class="line">&#123;</span><br><span class="line">1，修改等待对象的singleStat;</span><br><span class="line">2,退出循环</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(不符合条件) // 超时并且被等待对象 !&gt;0;</span><br><span class="line">&#123;</span><br><span class="line">if(第一次执行)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 将waitingblockList 位置清0;</span><br><span class="line">//释放_kwait_block等待块内存.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程唤醒与等待&quot;&gt;&lt;a href=&quot;#线程唤醒与等待&quot; class=&quot;headerlink&quot; title=&quot;线程唤醒与等待&quot;&gt;&lt;/a&gt;线程唤醒与等待&lt;/h2&gt;&lt;h4 id=&quot;等待对象&quot;&gt;&lt;a href=&quot;#等待对象&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="进程&amp;线程" scheme="http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
