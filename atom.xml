<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.010101.cc/atom.xml" rel="self"/>
  
  <link href="http://www.010101.cc/"/>
  <updated>2021-11-11T07:13:08.483Z</updated>
  <id>http://www.010101.cc/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM之Java编译器浅析</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T07:13:08.483Z</updated>
    
    <content type="html"><![CDATA[<p>Wirte by 021.</p><h2 id="Java编译器浅析"><a href="#Java编译器浅析" class="headerlink" title="Java编译器浅析"></a>Java编译器浅析</h2><ul><li><p><strong>本地代码（native code）</strong> 是计算机编程（代码），编译用来运行一个特殊的处理器（如英特尔x86级的处理器）和它的特殊指令集，简称机器码.</p><ul><li><p>Win : exe</p></li><li><p>Linux : elf</p></li></ul></li></ul><h4 id="模式1-：-即时编译JIT编译器-Just-in-time"><a href="#模式1-：-即时编译JIT编译器-Just-in-time" class="headerlink" title="模式1 ： 即时编译JIT编译器-Just in time."></a>模式1 ： 即时编译JIT编译器-Just in time.</h4><ul><li>主要用于JVM将 **class热点代码 ** 编译为本地代码.</li></ul><h4 id="模式2：-解释器-byteCode-intepreter"><a href="#模式2：-解释器-byteCode-intepreter" class="headerlink" title="模式2： 解释器 byteCode intepreter"></a>模式2： 解释器 byteCode intepreter</h4><ul><li>在程序运行过程中，JVM将字节码再转换成本地可执行的本地代码,边解释字节码边执行，故而称为解释器。</li></ul><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认： -Xmixed 混合模式</span><br><span class="line">-Xint 解释模式，启动块，执行稍微慢</span><br><span class="line">-XComp 编译模式，启动时间慢，需要编译</span><br></pre></td></tr></table></figure><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h2 id=&quot;Java编译器浅析&quot;&gt;&lt;a href=&quot;#Java编译器浅析&quot; class=&quot;headerlink&quot; title=&quot;Java编译器浅析&quot;&gt;&lt;/a&gt;Java编译器浅析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地代码</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC垃圾回收器与算</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T10:30:03.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC浅析"><a href="#JVM之GC浅析" class="headerlink" title="JVM之GC浅析"></a>JVM之GC浅析</h2><p>Wirte by 021.</p><p><img src="http://www.goexploit.com/upload/2021/03/image-20210320093842591-9eba8ad6fd714b8585671d6ea604a2f5.png" alt="image-20210320093842591"></p><h4 id="常见GC算法"><a href="#常见GC算法" class="headerlink" title="常见GC算法"></a>常见GC算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    final  int a = 0;</span><br><span class="line">    final int b =10;</span><br><span class="line">    final static int c = 0;</span><br><span class="line">    volatile int d = 0;</span><br><span class="line">    volatile int e = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line">        PerformanceTest p = new PerformanceTest();</span><br><span class="line">        p.test(a,b);</span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">        System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int test(int a , int b)&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(this.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Long.class.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Integer.class.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="GC垃圾回收器（算法的实现）"><a href="#GC垃圾回收器（算法的实现）" class="headerlink" title="GC垃圾回收器（算法的实现）"></a>GC垃圾回收器（算法的实现）</h4><ul><li>执行代码行标记</li></ul><h4 id="JVM-stack-方法栈"><a href="#JVM-stack-方法栈" class="headerlink" title="JVM stack 方法栈"></a>JVM stack 方法栈</h4><ul><li></li></ul><h4 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h4><ul><li>Native  本地方法相关方法栈.</li></ul><h4 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h4><ul><li>l</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC浅析&quot;&gt;&lt;a href=&quot;#JVM之GC浅析&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC浅析&quot;&gt;&lt;/a&gt;JVM之GC浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.goex</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java对象内存分布</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T09:12:21.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java对象内存分布"><a href="#Java对象内存分布" class="headerlink" title="Java对象内存分布"></a>Java对象内存分布</h2><p>Wirte by 021.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbbdazz1gj30va0u0gpj.jpg" alt="image-20211111165741691"></p><ul><li><strong>对象全局图</strong></li></ul><p>​    <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbataffm6j30k00ct74n.jpg" alt="img"></p><ul><li><p><strong>头部markword</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbaul5a3lj30k006yjrz.jpg" alt="img"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java对象内存分布&quot;&gt;&lt;a href=&quot;#Java对象内存分布&quot; class=&quot;headerlink&quot; title=&quot;Java对象内存分布&quot;&gt;&lt;/a&gt;Java对象内存分布&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java运行时数据区浅析---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T10:19:31.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之运行时数据区-————–-TODO"><a href="#JVM之运行时数据区-————–-TODO" class="headerlink" title="JVM之运行时数据区 ————–   TODO"></a>JVM之运行时数据区 ————–   TODO</h2><p>Wirte by 021.</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbc2zlq9nj31060n5jvn.jpg" alt="image-20211111172223120"></h4><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    final  int a = 0;</span><br><span class="line">    final int b =10;</span><br><span class="line">    final static int c = 0;</span><br><span class="line">    volatile int d = 0;</span><br><span class="line">    volatile int e = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line">        PerformanceTest p = new PerformanceTest();</span><br><span class="line">        p.test(a,b);</span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">        System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int test(int a , int b)&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(this.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Long.class.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Integer.class.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Progarm-Counter-程序计数器"><a href="#Progarm-Counter-程序计数器" class="headerlink" title="Progarm Counter 程序计数器"></a>Progarm Counter 程序计数器</h4><ul><li>执行代码行标记</li></ul><h4 id="JVM-stack-方法栈"><a href="#JVM-stack-方法栈" class="headerlink" title="JVM stack 方法栈"></a>JVM stack 方法栈</h4><ul><li><p>Local Variable Table 局部变量表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args[]</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Operand Stack 操作数栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>Dynamic Linking 静态连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前线程在运行时与常量池符号的连接. 指向常量池的变量.  示例代码中：final static int c = 0，p.test(0,0);;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Retuen Address 返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数执行结果的值地址存入栈顶. p.test(a,b) = return a + b;</span><br></pre></td></tr></table></figure></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul><li>Native  本地方法相关方法栈.</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>l</li></ul><h4 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h4><ul><li>JVM可以直接访问的内核空间内存，0拷贝。</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li></li></ul><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认： -Xmixed 混合模式</span><br><span class="line">-Xint 解释模式，启动块，执行稍微慢</span><br><span class="line">-XComp 编译模式，启动时间慢，需要编译</span><br></pre></td></tr></table></figure><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之运行时数据区-————–-TODO&quot;&gt;&lt;a href=&quot;#JVM之运行时数据区-————–-TODO&quot; class=&quot;headerlink&quot; title=&quot;JVM之运行时数据区 ————–   TODO&quot;&gt;&lt;/a&gt;JVM之运行时数据区 ————–   TO</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Btree之Mysql自顶向下</title>
    <link href="http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T14:27:18.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析"><a href="#M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析" class="headerlink" title="M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析"></a>M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析</h2><p>Wirte by 021.</p><object data="/Users/jiankang/Documents/数据结构Btree之Mysql自顶向下.pdf" type="application/pdf" width="100%" height="100%">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析&quot;&gt;&lt;a href=&quot;#M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析&quot; class=&quot;h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树结构" scheme="http://www.010101.cc/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>内核之线程与进程的关系</title>
    <link href="http://www.010101.cc/2021/11/10/E_Process/"/>
    <id>http://www.010101.cc/2021/11/10/E_Process/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-10T12:33:50.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程关系"><a href="#线程与进程关系" class="headerlink" title="线程与进程关系"></a>线程与进程关系</h2><ul><li><p>进程是资源集合，提供cr3的值，cr3是页目录表的基址，cr3确定了，线程才能访问.</p></li><li><p>一个进程有多个线程，但至少有一个线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，进程提供了空间上概念,进程提供了线程哪些空间地址可以访问的逻辑。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwab540zozj30pr0a8gmv.jpg" alt="image-20211110200416873"></p></li></ul><ul><li><p>创建进程：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwabd1vef8j30oy0dl75r.jpg" alt="image-20211110201154629"></p></li></ul><ul><li><p>通过线程如何找到进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* thread -&gt; cr3页面 -&gt; _Kprocess 的指针</span><br><span class="line"></span><br><span class="line">假如线程执行：</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr ds:[0x12345678]</span><br><span class="line"></span><br><span class="line">cpu的解析路径： </span><br><span class="line"></span><br><span class="line">1，线程拿到当前进程的 cr3 值 Kprocess_directoryTableBase(+0x018) </span><br><span class="line">2，通过cr3的寄存器页表目录定位物理页</span><br><span class="line"></span><br><span class="line">3,EThread结构体：</span><br><span class="line">&#123;</span><br><span class="line">0x000 KThread 结构体 </span><br><span class="line">&#123;</span><br><span class="line">  0x034  _KAPC_STAT</span><br><span class="line">  &#123;</span><br><span class="line">  0x10 ptr32 EPROCESS;</span><br><span class="line">  0x044 , cmp [esi, prt* process]  </span><br><span class="line">  #SWapContext时会比较 44 和 220 的值是否一样，不一样会造成进程空间切换，cr3切换，详情见进程挂靠</span><br><span class="line">  #44位置上提供是cr3的值，资源提供方的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">0x220 ptr32 EPROCESS #当前线程所属进程，当前线程是谁创建的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程与进程关系&quot;&gt;&lt;a href=&quot;#线程与进程关系&quot; class=&quot;headerlink&quot; title=&quot;线程与进程关系&quot;&gt;&lt;/a&gt;线程与进程关系&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程是资源集合，提供cr3的值，cr3是页目录表的基址，cr3确定了，线程才能访问</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="进程&amp;线程" scheme="http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>高并发之CAS自顶向下</title>
    <link href="http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-10T08:32:07.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发之CAS自顶向下"><a href="#高并发之CAS自顶向下" class="headerlink" title="高并发之CAS自顶向下"></a>高并发之CAS自顶向下</h2><p>Wirte by 021. </p><p><strong>机器级代码</strong></p><p>计算机系统使用了多种不同形式的抽象，可以通过一个简单的抽象模型来隐藏实现细节。对于机器级别的程序来说，有两点非常重要。</p><p>首先第一点，定义机器级别程序的格式和行为被称为 指令集体系结构或指令集架构(instruction set architecture)， ISA。ISA 定义了进程状态、指令的格式和每一个指令对状态的影响。大部分的指令集架构包括 ISA 用来描述进程的行为就好像是顺序执行的，一条指令执行结束后，另外一条指令再开始。处理器硬件的描述要更复杂，它可以同时并行执行许多指令，但是它采用了安全措施来确保整体行为与 ISA 规定的顺序一致。</p><p>第二点，机器级别对内存地址的描述就是 虚拟地址(virtual address)，它提供了一个内存模型来表示一个巨大的字节数组。</p><p>编译器在整个编译的过程中起到了至关重要的作用，把 C 语言转换为处理器执行的基本指令。汇编代码非常接近于机器代码，只不过与二进制机器代码相比，汇编代码的可读性更强，所以理解汇编是理解机器工作的第一步。</p><p>一些进程状态对机器可见，但是 C 语言程序员却看不到这些，包括</p><ul><li>程序计数器(Program counter)，它存储下一条指令的地址，在 x86-64 架构中用 %rip 来表示。</li></ul><p>程序执行时，PC 的初始值为程序第一条指令的地址，在顺序执行程序时， CPU 首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 并指向下一条要执行的指令。</p><p>比如下面一个例子。 </p><p>这是一段数值进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。由于使用机器语言难以描述，所以这是经过翻译后的结果，实际上每个指令和数据都可能分布在不同的地址上，但为了方便说明，把组成一条指令的内存和数据放在了一个内存地址上。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4t8tyh2j316i0tqgpf.jpg" alt="image-20211110162521277"></p><ul><li><p>整数寄存器文件(register file)包含 16 个命名的位置，用来存储 64 位的值。这些寄存器可以存储地址和整型数据。有些寄存器用于跟踪程序状态，而另一些寄存器用于保存临时数据，例如过程的参数和局部变量，以及函数要返回的值。这个 文件 是和磁盘文件无关的，它只是 CPU 内部的一块高速存储单元。有专用的寄存器，也有通用的寄存器用来存储操作数。</p></li><li><p>条件码寄存器 用来保存有关最近执行的算术或逻辑指令的状态信息。这些用于实现控件或数据流中的条件更改，例如实现 if 和 while 语句所需的条件更改。我们都学过高级语言，高级语言中的条件控制流程主要分为三种：顺序执行、条件分支、循环判断三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。</p></li><li><ul><li>顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。</li><li>条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。</li></ul></li></ul><p>下面以条件分支为例来说明程序的执行过程（循环也很相似）</p><p>程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序+1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 if() 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4w0dt81j317q0sogpd.jpg" alt="image-20211110162801553"></p><ul><li>一组 向量寄存器用来存储一个或者多个整数或者浮点数值，向量寄存器是对一维数据上进行操作。</li></ul><p>机器指令只会执行非常简单的操作，例如将存放在寄存器的两个数进行相加，把数据从内存转移到寄存器中或者是条件分支转移到新的指令地址。编译器必须生成此类指令的序列，以实现程序构造，例如算术表达式求值，循环或过程调用和返回</p><p><strong>认识汇编</strong></p><p>我相信各位应该都知道汇编语言的出现背景吧，那就是二进制表示数据，太复杂太庞大了，为了解决这个问题，出现了汇编语言，汇编语言和机器指令的区别就在于表示方法上，汇编使用操作数来表示，机器指令使用二进制来表示，我之前多次提到机器码就是汇编，你也不能说我错，但是不准确。</p><p>但是汇编适合二进制代码存在转换关系的。</p><p>汇编代码需要经过 汇编器 编译后才产生二进制代码，这个二进制代码就是目标代码，然后由链接器将其连接起来运行。</p><p>汇编语言主要分为以下三类</p><ul><li>汇编指令：它是一种机器码的助记符，它有对应的机器码</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号，比如 +、-、*、/ 等，由编译器识别，没有对应的机器码</li></ul><p>汇编语言的核心是汇编指令，而我们对汇编的探讨也是基于汇编指令展开的。</p><p><strong>与汇编有关的硬件和概念</strong></p><p><strong>CPU</strong></p><p>CPU 是计算机的大脑，它也是整个计算机的核心，它也是执行汇编语言的硬件，CPU 的内部包含有寄存器，而寄存器是用于存储指令和数据的，汇编语言的本质也就是 CPU 内部操作数所执行的一系列计算。</p><p><strong>内存</strong></p><p>没有内存，计算机就像是一个没有记忆的人类，只会永无休止的重复性劳动。CPU 所需的指令和数据都由内存来提供，CPU 指令经由内存提供，经过一系列计算后再输出到内存。</p><p><strong>磁盘</strong></p><p>磁盘也是一种存储设备，它和内存的最大区别在于永久存储，程序需要在内存装载后才能运行，而提供给内存的程序都是由磁盘存储的。</p><p><strong>总线</strong></p><p>一般来说，内存内部会划分多个存储单元，存储单元用来存储指令和数据，就像是房子一样，存储单元就是房子的门牌号。而 CPU 与内存之间的交互是通过地址总线来进行的，总线从逻辑上分为三种</p><ul><li>地址线</li><li>数据线</li><li>控制线</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4wdydrlj30ua0i8js4.jpg" alt="image-20211110162824440"></p><p>CPU 与存储器之间的读写主要经过以下几步</p><p><strong>读操作步骤</strong></p><ul><li>CPU 通过地址线发出需要读取指令的位置</li><li>CPU 通过控制线发出读指令</li><li>内存把数据放在数据线上返回给 CPU</li></ul><p><strong>写操作步骤</strong></p><ul><li>CPU 通过地址线发出需要写出指令的位置</li><li>CPU 通过控制线发出写指令</li><li>CPU 把数据通过数据线写入内存</li></ul><p>下面我们就来具体了解一下这三类总线</p><p><strong>地址总线</strong></p><p>通过我们上面的探讨，我们知道 CPU 通过地址总线来指定存储位置的，地址总线上能传送多少不同的信息，CPU 就可以对多少个存储单元进行寻址。</p><p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4ww372uj30zs0scmyo.jpg" alt="image-20211110162852156"></p><p>上图中 CPU 和内存中间信息交换通过了 10 条地址总线，每一条线能够传递的数据都是 0 或 1 ，所以上图一次 CPU 和内存传递的数据是 2 的十次方。</p><p>所以，如果 CPU 有 N 条地址总线，那么可以说这个地址总线的宽度是 N 。这样 CPU 可以寻找 2 的 N 次方个内存单元。</p><p><strong>数据总线</strong></p><p>CPU 与内存或其他部件之间的数据传送是由数据总线来完成的。数据总线的宽度决定了 CPU 和外界的数据传输速度。8 根数据总线可以一次传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可以传输两个字节，32 根数据总线可以一次传输四个字节。。。。。。</p><p><strong>控制总线</strong></p><p>CPU 与其他部件之间的控制是通过 控制总线 来完成的。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部部件的控制能力。</p><p><strong>一次内存的读取过程</strong></p><p><strong>内存结构</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4x4nwgvj31660u0gnz.jpg" alt="image-20211110162906306"></p><p>内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图</p><p>图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，**+5V** <strong>表示<strong><strong>1</strong></strong>，****0V</strong> <strong>表示</strong> <strong>0</strong>。</p><p>我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = 1024个地址。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。</p><p>如果我们使用的是 512 MB 的内存，这就相当于是 512000（512 * 1000） 个内存 IC。当然，一台计算机不太可能有这么多个内存 IC ，然而，通常情况下，一个内存 IC 会有更多的引脚，也就能存储更多数据。</p><p><strong>内存读取过程</strong></p><p>下面是一次内存的读取过程。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa4xgmz6cj30zj0u041w.jpg" alt="image-20211110162922419"></p><p>来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：</p><ul><li><p>首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 A0 - A9 来指定数据的存储场所，然后再把数据的值输入给 D0 - D7 的数据信号，并把 WR（write）的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据</p></li><li><p>读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。</p></li><li><p>图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。</p></li></ul><h2 id="CAS原子性操作之汇编"><a href="#CAS原子性操作之汇编" class="headerlink" title="CAS原子性操作之汇编"></a>CAS原子性操作之汇编</h2><p>“最轻量级的锁”,通常也叫”原子操作”,之所以加引号是因为他们在汇编级别并不是原子操作,是用多条指令完成的,这些操作大多都是利用CPU支持的汇编指令.在某些构架过时的CPU体系结构上,它们应该是用比较重量级的线程内锁实现的吧(我的猜测).</p><p>最常见的原子操作有Compare and Exchange,Self Increase/Decrease等等</p><p><strong>80486 CPU****相关指令：</strong></p><p>LOCK:这是一个指令前缀，在所对应的指令操作期间使此指令的目标操作数指定的存储区域锁定，以得到保护。</p><p>XADD:先交换两个操作数的值，再进行算术加法操作。多处理器安全，在80486及以上CPU中支持。</p><p>CMPXCHG:比较交换指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上CPU中支持。</p><p>XCHG:交换两个操作数,其中至少有一个是寄存器寻址.其他寄存器和标志位不受影响.</p><p>80486以上都支持这四个操作,因此当今几乎100%CPU都支持这两个指令,也能由此用标准C和C++写出一系列几乎可以跨平台的”原子操作”函数和Lock-Free数据结构和算法.</p><p>64位平台也有一系列的相关指令,当然他们也有以上提到的指令,其下的64位原子操作函数应该和32位的分开(要问为什么?我现在告诉你恐怕你印象不深,接着看这一系列吧),而道理完全一样.因此,不存在跨CPU体系结构的问题)</p><p><strong>“<strong><strong>原子操作</strong></strong>”**<strong>函数</strong></strong>:**</p><p>由以上提供的几个汇编指令,我们可以做出以下实现,这些都是最常用的原语.</p><p>比较后交换</p><p>long __stdcall <strong>CompareExchange</strong>(long volatile*<strong>Destination</strong>,long <strong>Exchange</strong>,long <strong>Comperand</strong>)</p><p>{</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Destination</strong>;</p><p>   <strong>mov   edx</strong>, <strong>Exchange</strong>;</p><p>   <strong>mov   eax</strong>, <strong>Comperand</strong>;</p><p>   <strong>lock cmpxchg [ecx</strong>], <strong>edx</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>交换</p><p>long __stdcall <strong>Exchange</strong>(long volatile* <strong>Target</strong>,long <strong>Value</strong>)</p><p>{</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Target</strong>;</p><p>   <strong>mov   edx</strong>, <strong>Value</strong>;</p><p><strong>label</strong>:</p><p>   <strong>lock cmpxchg [ecx</strong>], <strong>edx</strong>;//加</p><p>   <strong>jnz</strong>   short <strong>label</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>自减</p><p>long __stdcall <strong>Decrement</strong>(long volatile* <strong>Addend</strong>)</p><p>{</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Addend</strong>;</p><p>   <strong>mov   eax</strong>, 0FFFFFFFFh;//-1</p><p>   <strong>lock xadd [ecx</strong>], <strong>eax</strong>; //加-1</p><p>   <strong>dec   eax</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>自增</p><p>long __stdcall <strong>Increment</strong>(long volatile* <strong>Addend</strong>)</p><p>{</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Addend</strong>;</p><p>   <strong>mov   eax</strong>, 1;</p><p>   <strong>lock xadd [ecx</strong>], <strong>eax</strong>; //加</p><p>   <strong>inc   eax</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>相加后交换</p><p>long __stdcall <strong>ExchangeAdd</strong>(long volatile* <strong>Addend</strong>,long <strong>Value</strong>)</p><p>{</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Addend</strong>;</p><p>   <strong>mov   eax</strong>, <strong>Value</strong>;</p><p>   <strong>lock xadd [ecx</strong>], <strong>eax</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>原子操作(2) - 泛型后的原子操作</p><p>32位的数据类型有4种,但是上面的只支持long,怎么办?手工hack?太土了,当然是C++的大规模杀伤性武器template了.</p><p>同时把几个不跨平台的地方抽出来用macro表示.</p><p>目前模板还没有得到concept的支持,所以只能用boost.type_traits低级的手动判断,要求只有32位的整数类型才能实例化这些函数.</p><p>#include</p><p>#include</p><p>#define <strong>CALL_METHOD</strong> __stdcall</p><p>#define <strong>VOLATILE</strong> volatile</p><p>template&lt;typename **T**&gt;</p><p><strong>T CALL_METHOD compare_exchange32</strong>(<strong>T VOLATILE</strong>*<strong>Destination</strong>,<strong>T exchange32</strong>,<strong>T Comperand</strong>)</p><p>{</p><p>  <strong>BOOST_STATIC_ASSERT</strong>(sizeof(<strong>T</strong>) == 4 &amp;&amp; <strong>boost</strong>::<strong>is_integral</strong>&lt;**T**&gt;::<strong>value</strong>);</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Destination</strong>;</p><p>   <strong>mov   edx</strong>, <strong>exchange32</strong>;</p><p>   <strong>mov   eax</strong>, <strong>Comperand</strong>;</p><p>   <strong>lock cmpxchg [ecx</strong>], <strong>edx</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>template&lt;typename **T**&gt;</p><p><strong>T CALL_METHOD exchange32</strong>(<strong>T VOLATILE</strong>* <strong>Target</strong>,<strong>T Value</strong>)</p><p>{</p><p>  <strong>BOOST_STATIC_ASSERT</strong>(sizeof(<strong>T</strong>) == 4 &amp;&amp; <strong>boost</strong>::<strong>is_integral</strong>&lt;**T**&gt;::<strong>value</strong>);</p><p>  __asm</p><p>  <strong>{</strong></p><p>   //   mov  ecx, Target;</p><p>   //   mov  edx, Value;   </p><p>   //label:</p><p>   //   lock  cmpxchg [ecx], edx;//加</p><p>   //   jnz  short label;</p><p>   <strong>mov   ecx</strong>, <strong>Target</strong>;</p><p>   <strong>mov   eax</strong>, <strong>Value</strong>;</p><p>   <strong>xchg [ecx</strong>],<strong>eax</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>template&lt;typename **T**&gt;</p><p><strong>T CALL_METHOD decrement32</strong>(<strong>T VOLATILE</strong>* <strong>Addend</strong>)</p><p>{</p><p>  <strong>BOOST_STATIC_ASSERT</strong>(sizeof(<strong>T</strong>) == 4 &amp;&amp; <strong>boost</strong>::<strong>is_integral</strong>&lt;**T**&gt;::<strong>value</strong>);</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Addend</strong>;</p><p>   <strong>mov  eax</strong>, 0FFFFFFFFh;//-1</p><p>   <strong>lock xadd [ecx</strong>], <strong>eax</strong>; //加-1</p><p>   <strong>dec   eax</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>template&lt;typename **T**&gt;</p><p><strong>T CALL_METHOD increment32</strong>(<strong>T VOLATILE</strong>* <strong>Addend</strong>)</p><p>{</p><p>  <strong>BOOST_STATIC_ASSERT</strong>(sizeof(<strong>T</strong>) == 4 &amp;&amp; <strong>boost</strong>::<strong>is_integral</strong>&lt;**T**&gt;::<strong>value</strong>);</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Addend</strong>;</p><p>   <strong>mov   eax</strong>, 1;</p><p>   <strong>lock xadd [ecx</strong>], <strong>eax</strong>; //加</p><p>   <strong>inc   eax</strong>;</p><p>  <strong>}</strong></p><p>}</p><p>template&lt;typename **T**&gt;</p><p><strong>T CALL_METHOD exchange_add32</strong>(<strong>T VOLATILE</strong>* <strong>Addend</strong>,<strong>T Value</strong>)</p><p>{</p><p>  <strong>BOOST_STATIC_ASSERT</strong>(sizeof(<strong>T</strong>) == 4 &amp;&amp; <strong>boost</strong>::<strong>is_integral</strong>&lt;**T**&gt;::<strong>value</strong>);</p><p>  __asm</p><p>  <strong>{</strong></p><p>   <strong>mov   ecx</strong>, <strong>Addend</strong>;</p><p>   <strong>mov   eax</strong>, <strong>Value</strong>;</p><p>   <strong>lock xadd [ecx</strong>], <strong>eax</strong>;</p><p>  <strong>}</strong></p><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高并发之CAS自顶向下&quot;&gt;&lt;a href=&quot;#高并发之CAS自顶向下&quot; class=&quot;headerlink&quot; title=&quot;高并发之CAS自顶向下&quot;&gt;&lt;/a&gt;高并发之CAS自顶向下&lt;/h2&gt;&lt;p&gt;Wirte by 021. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器级代</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="并发原子锁" scheme="http://www.010101.cc/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程等待与唤醒之win32内核浅析</title>
    <link href="http://www.010101.cc/2021/11/10/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92/"/>
    <id>http://www.010101.cc/2021/11/10/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-10T12:36:55.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程唤醒与等待"><a href="#线程唤醒与等待" class="headerlink" title="线程唤醒与等待"></a>线程唤醒与等待</h2><h4 id="等待对象"><a href="#等待对象" class="headerlink" title="等待对象"></a>等待对象</h4><ul><li>伪代码 解释 基于win32 等待对象 与 当前线程 ，被等待对象的关系.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//被等待对象1</span><br><span class="line">int Thread </span><br><span class="line">&#123;</span><br><span class="line">int a = 0;</span><br><span class="line">return a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被等待对象2</span><br><span class="line">int Thread1 </span><br><span class="line">&#123;</span><br><span class="line">int a = 0;</span><br><span class="line">return a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当前主线程 </span><br><span class="line">void main(...)</span><br><span class="line">&#123;</span><br><span class="line">//被等待对象</span><br><span class="line">int a Thead.t1.start;</span><br><span class="line">int a1 = Thead1.t1.start;</span><br><span class="line"></span><br><span class="line">解析 -&gt; 等待对象</span><br><span class="line">waitingforSinglObject(arr[t1,t2],xx);</span><br><span class="line"></span><br><span class="line">只有等待： 等待对象中的被等待对象t1和t2执行完后，当前main线程才能继续执行.</span><br><span class="line">printf(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="逻辑步骤-TODO"><a href="#逻辑步骤-TODO" class="headerlink" title="逻辑步骤-TODO"></a>逻辑步骤-TODO</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject调用内核函数NtWaitForObject,</span><br><span class="line"></span><br><span class="line">NtWaitForObject 调用ObReferenceObjectByHandle,通过当前线程对象句柄找到&#x27;等待对象结构体&#x27;的首地址</span><br><span class="line"></span><br><span class="line">将结构体首地址传递给 KeWaitSingleObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KeWaitSingleObject 步骤：</span><br><span class="line"></span><br><span class="line">1，准备等待块._wait_block; 默认初始4个等待块  </span><br><span class="line">..... 这块内核比较复杂黑盒,todo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">被等待对象：必须具备_DISPATCHER_HEADER属性的对象，</span><br><span class="line"></span><br><span class="line">_DISPATCHER_HEADER结构体</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">+0x004 SingleStat; 信号状态 &gt; 0;</span><br><span class="line">+0x008 WaitListHead; 所有等待块双向链表地址.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">内部处理逻辑伪代码:</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">if(符合条件) // 1,符合超时条件， 等待对象的信号量 &gt; 0;</span><br><span class="line">&#123;</span><br><span class="line">1，修改等待对象的singleStat;</span><br><span class="line">2,退出循环</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(不符合条件) // 超时并且被等待对象 !&gt;0;</span><br><span class="line">&#123;</span><br><span class="line">if(第一次执行)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 将waitingblockList 位置清0;</span><br><span class="line">//释放_kwait_block等待块内存.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程唤醒与等待&quot;&gt;&lt;a href=&quot;#线程唤醒与等待&quot; class=&quot;headerlink&quot; title=&quot;线程唤醒与等待&quot;&gt;&lt;/a&gt;线程唤醒与等待&lt;/h2&gt;&lt;h4 id=&quot;等待对象&quot;&gt;&lt;a href=&quot;#等待对象&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="进程&amp;线程" scheme="http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>高并发之硬件MESI缓存一致性协议与CPU屏障浅析</title>
    <link href="http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%A1%AC%E4%BB%B6%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8ECPU%E5%B1%8F%E9%9A%9C%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%A1%AC%E4%BB%B6%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8ECPU%E5%B1%8F%E9%9A%9C%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-10T07:15:06.000Z</published>
    <updated>2021-11-11T08:32:18.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发之硬件MESI缓存一致性协议与CPU屏障"><a href="#高并发之硬件MESI缓存一致性协议与CPU屏障" class="headerlink" title="高并发之硬件MESI缓存一致性协议与CPU屏障"></a>高并发之硬件MESI缓存一致性协议与CPU屏障</h2><p>​    Wirte by 021. </p><h4 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h4><ul><li>cache line是cache与内存数据交换的最小单位，根据操作系统一般是32byte或64byte。在MESI协议中，状态可以是M、E、S、I，地址则是cache line中映射的内存地址，数据则是从内存中读取的数据。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbafnpbr0j30mr048glo.jpg" alt="img"></p><ul><li><p>  <strong>状态介绍</strong></p></li><li><p>MESI协议将cache line的状态分成modify、exclusive、shared、invalid，分别是修改、独占、共享和失效。</p><ul><li><p>modify：当前CPU cache拥有最新数据（最新的cache line），其他CPU拥有失效数据（cache line的状态是invalid），虽然当前CPU中的数据和主存是不一致的，但是以当前CPU的数据为准；</p></li><li><p>exclusive：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的；</p></li><li><p>shared：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致；</p></li><li><p>invalid：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的；</p></li><li><p>对于invalid而言，在MESI协议中采取的是写失效（write invalidate）。</p></li></ul></li></ul><ol start="4"><li><strong>cache操作</strong></li><li>MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），每个核心的缓存控制器通过监听也知道其他CPU中cache的操作（remote read和remote write），今儿再确定自己cache中共享数据的状态是否需要调整。</li></ol><ul><li>local read（LR）：读本地cache中的数据；</li><li>local write（LW）：将数据写到本地cache；</li><li>remote read（RR）：其他核心发生read；</li><li>remote write（RW）：其他核心发生write；</li></ul><h4 id="CPU内存保证"><a href="#CPU内存保证" class="headerlink" title="CPU内存保证"></a>CPU内存保证</h4><ul><li><p>通常情况下，在代码被正常编译成机器码后，在汇编代码级别不加lock 原子指令情况下，代码也会产生乱序，编译器会优化代码，调整执行顺序，如果需要执行强代码一致性需要加上CPU内存屏蔽代码;</p></li><li><p><strong>final int a =0</strong> 这行代码在编译器编译成机器码时会加内存屏障，防止重排序. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#TODO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sfence :</span><br><span class="line"></span><br><span class="line">ifence :</span><br><span class="line"></span><br><span class="line">mfence :</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbamdx1tlj30m60m8tav.jpg" alt="image-20211111163154506"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高并发之硬件MESI缓存一致性协议与CPU屏障&quot;&gt;&lt;a href=&quot;#高并发之硬件MESI缓存一致性协议与CPU屏障&quot; class=&quot;headerlink&quot; title=&quot;高并发之硬件MESI缓存一致性协议与CPU屏障&quot;&gt;&lt;/a&gt;高并发之硬件MESI缓存一致性协议</summary>
      
    
    
    
    <category term="计算机硬件" scheme="http://www.010101.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="并发原子锁" scheme="http://www.010101.cc/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>win32 之 PE文件结构解读</title>
    <link href="http://www.010101.cc/2021/11/10/win32%E4%B9%8BPE%E6%96%87%E4%BB%B6/"/>
    <id>http://www.010101.cc/2021/11/10/win32%E4%B9%8BPE%E6%96%87%E4%BB%B6/</id>
    <published>2021-11-10T06:44:58.000Z</published>
    <updated>2021-11-10T06:48:40.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><ul><li><p>Windows : PE (Portable Excuteable) 文件结构</p></li><li><p>Linux : ELF(Executable and linking formate) 文件结构</p></li></ul><h4 id="PE-文件特征和格式"><a href="#PE-文件特征和格式" class="headerlink" title="PE 文件特征和格式"></a>PE 文件特征和格式</h4><ul><li>执行二进制文件转16进制后，前2个字节是MZ, 3C位置值，再往下找3C位置的字节值会显示PE. 可判定为PE.</li></ul><h4 id="PE文件结构排列"><a href="#PE文件结构排列" class="headerlink" title="PE文件结构排列"></a>PE文件结构排列</h4><p><code>DOS + PE文件头 + 字表 + 字节数</code></p><p><img src="https://www.pianshen.com/images/785/9b4600340cb22b586c8e7f22c6573e31.png" alt="PE文件分析- 程序员大本营"></p><h5 id="dos文件头"><a href="#dos文件头" class="headerlink" title="dos文件头"></a>dos文件头</h5><ul><li>MZ头 ：64byte + 20byte PE_header + 节表section_header 40byte + option_header 224byte节数据</li></ul><h5 id="内存拉升："><a href="#内存拉升：" class="headerlink" title="内存拉升："></a>内存拉升：</h5><ul><li>PE文件在硬盘中200倍拉升， 在内存中1000倍拉升，空间扩充.</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa1xavystj31bx0u0juo.jpg" alt="image-20211109124840719"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PE文件结构&quot;&gt;&lt;a href=&quot;#PE文件结构&quot; class=&quot;headerlink&quot; title=&quot;PE文件结构&quot;&gt;&lt;/a&gt;PE文件结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Windows : PE (Portable Excuteable) 文件结构&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="PE可执行文件" scheme="http://www.010101.cc/tags/PE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>线程切换之内核E_thead浅析</title>
    <link href="http://www.010101.cc/2021/11/10/E_Thread/"/>
    <id>http://www.010101.cc/2021/11/10/E_Thread/</id>
    <published>2021-11-10T06:44:58.000Z</published>
    <updated>2021-11-10T08:13:32.529Z</updated>
    
    <content type="html"><![CDATA[<p>Wirte by 021.</p><h2 id="E-Thread"><a href="#E-Thread" class="headerlink" title="E_Thread"></a>E_Thread</h2><ul><li>线程结构体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">结构体</span><br><span class="line">&#123;</span><br><span class="line">线程名称</span><br><span class="line">线程状态</span><br><span class="line"></span><br><span class="line">堆栈起始地址</span><br><span class="line">线程堆栈界限 （终止地址）</span><br><span class="line">线程当前位置 ESP</span><br><span class="line"></span><br><span class="line">线程函数参数</span><br><span class="line">线程函数地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程结构体数组</span><br><span class="line"></span><br><span class="line">0 --- 当前线程 ，main</span><br><span class="line"></span><br><span class="line">1 --- 创建的新线程</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>线程状态不同存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正在运行线程 --- kpcr</span><br><span class="line"></span><br><span class="line">等待线程 --- 等待链表</span><br><span class="line"></span><br><span class="line">就绪/调度线程 --- 32个链表</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul><li><p>创建 — 初始化线程堆栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1，结构体初始化赋值</span><br><span class="line"></span><br><span class="line">2，执行体，函数，参数，赋值</span><br><span class="line"></span><br><span class="line">3，创建堆栈，申请堆栈 stackpage , 0x80000 大小，</span><br><span class="line"></span><br><span class="line">4，堆栈初始化，起始地址、</span><br><span class="line"></span><br><span class="line">5，设定堆栈边界值（终止地址）</span><br><span class="line"></span><br><span class="line">6， 入栈</span><br><span class="line"></span><br><span class="line">7, kernelStack 栈顶 赋值，esp 赋值。</span><br><span class="line">kernelStack = 入栈对象 （1-6）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>线程调度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="线程切换-SwapContext"><a href="#线程切换-SwapContext" class="headerlink" title="线程切换 SwapContext"></a>线程切换 SwapContext</h3><ul><li>线程不是被动切换，而是主动切换。 意思是，无论是时间片到了的被动切换，还是线程IO阻塞主动出让执行权，都需要当前线程调用切换线程函数.</li><li>线程没有使用TSS保存寄存器，而是使用堆栈.</li><li>线程切换过程就是堆栈切换过程.</li><li>在线程切换过程中，会判断2个线程是否属于同一个进程，如果不是，就切换cr3页面，也就是进程空间也切换了.</li></ul><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa1nx9qgvj30qm0fu753.jpg" alt="image-20211110115259985"></p><ul><li><p>TheadSwap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数 ： 1，当前线程(esp)地址， 2，将要被切换线程(edi)地址</span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line">1，保存当前线的栈顶，上图的push操作.</span><br><span class="line">2，将当前线程（esp）地址，存储到KernelStack中 ---  mov [esi kernelStack] ,esp</span><br><span class="line">3，将内核中 将要被切换edi线程 的地址，交换到当前位置 ---  mov esp, [edi kernelStack]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主动切换</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa1odurnyj30zr0g4774.jpg" alt="image-20211110123138625"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取出当前CPU kpcr正在执行的线程放到edi中</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><ul><li><p>时钟中断</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa1ogwzuej30tp0d7q3x.jpg" alt="image-20211110132601818"></p><ul><li><p>线程中断条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.时间片到期</span><br><span class="line">2，备用线程（KPCR.PrcbData.nextThread）</span><br><span class="line">3，主动调用切换切换线程函数，KiswapThread</span><br></pre></td></tr></table></figure></li><li><p>CPU时间片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，KPROCESS.ThreadQuantum 值是当前进程设置的时间片值</span><br><span class="line">2，_KTHREAD.ThreadQuantum 会读取 KPROCESS.ThreadQuantum的值，在线程初始化的时候</span><br><span class="line"></span><br><span class="line">在win32里面初始为6,每次中断会调用KeupdateRuntime函数会将当前线程_KTHREAD.ThreadQuantum - 3，如果减到0，则将</span><br><span class="line">KPCR.PrcbData.QuantumEnd 位 置为 非0，表示当前线程时间片到期.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Tss</p><ul><li><p>内核堆栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initStack 栈底</span><br><span class="line">kernelStack 栈顶</span><br><span class="line">stackLimte 边界</span><br><span class="line"></span><br><span class="line">TSS.esp0得到当前线程0环堆栈，线程在切换的时候保证0环线程堆栈的唯一和有序性.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>异常中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INT N， 页面异常</span><br></pre></td></tr></table></figure></li><li><p>如何永久占用CPU?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">满足 不调用API , 并且不会出现异常，并调用cli指令，屏蔽时间中断，CPU就会忽略时钟片中断.</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul><li><p>线程调度链表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">32个线程调度双向链表。</span><br><span class="line">KiFindReadyThread 查找方式： 先找 31 ... 30 .. 29, 优先查找高级别的。</span><br><span class="line">32位:</span><br><span class="line">0 1 0 1 0 0 0 0 ... 0 ， 31位上为1，证明当前有优先级的线程需要处理。</span><br><span class="line">当调度链表中没有任何需要调度执行的任务时，cpu会执行idelThread.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h2 id=&quot;E-Thread&quot;&gt;&lt;a href=&quot;#E-Thread&quot; class=&quot;headerlink&quot; title=&quot;E_Thread&quot;&gt;&lt;/a&gt;E_Thread&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线程结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;f</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="进程&amp;线程" scheme="http://www.010101.cc/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CPU内核模块之KPCR</title>
    <link href="http://www.010101.cc/2021/11/10/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BFKPCR/"/>
    <id>http://www.010101.cc/2021/11/10/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BFKPCR/</id>
    <published>2021-11-10T06:44:58.000Z</published>
    <updated>2021-11-10T06:49:08.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github-访问慢，而其他网页正常"><a href="#github-访问慢，而其他网页正常" class="headerlink" title="github 访问慢，而其他网页正常."></a>github 访问慢，而其他网页正常.</h2><h3 id="Mac-修改hosts文件"><a href="#Mac-修改hosts文件" class="headerlink" title="Mac 修改hosts文件"></a>Mac 修改hosts文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Step 1. cd /etc/</span><br><span class="line"></span><br><span class="line">Step 2. sudo vi hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 粘贴</span><br><span class="line">140.82.112.4 github.com</span><br><span class="line">140.82.113.3 gist.github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 gist.githubusercontent.com</span><br><span class="line">199.232.68.133 cloud.githubusercontent.com</span><br><span class="line">151.101.192.133 camo.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars8.githubusercontent.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;github-访问慢，而其他网页正常&quot;&gt;&lt;a href=&quot;#github-访问慢，而其他网页正常&quot; class=&quot;headerlink&quot; title=&quot;github 访问慢，而其他网页正常.&quot;&gt;&lt;/a&gt;github 访问慢，而其他网页正常.&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    <category term="测试分类" scheme="http://www.010101.cc/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="测试标签" scheme="http://www.010101.cc/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java类加载与自定义加载热更新</title>
    <link href="http://www.010101.cc/2021/11/10/JVM%E4%B9%8BclassLoader%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/10/JVM%E4%B9%8BclassLoader%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-10T06:44:58.000Z</published>
    <updated>2021-11-11T07:41:22.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java类加载器浅析"><a href="#Java类加载器浅析" class="headerlink" title="Java类加载器浅析"></a>Java类加载器浅析</h2><h4 id="java-文件生命周期"><a href="#java-文件生命周期" class="headerlink" title=".java 文件生命周期"></a>.java 文件生命周期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.java -&gt; javac编译 -&gt; Jvm加载classloader -&gt; Jvm连接[验证，准备，解析] -&gt; 准备初始化（常量变量等内存分配过程）-&gt; GC</span><br></pre></td></tr></table></figure><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p><strong>双亲委派含义与功能简单分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1，Bootstrap ClassLoader 启动类加载器 主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。</span><br><span class="line">2，Extention ClassLoader 标准扩展类加载器 主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</span><br><span class="line">3，Application ClassLoader 应用类加载器 主要负责加载当前应用的classpath下的所有类</span><br><span class="line">4，User ClassLoader 用户自定义类加载器 用户自定义的类加载器,可加载指定路径的class文件</span><br><span class="line"></span><br><span class="line">上面是Java中提供的4类加载器，每个加载器负责不同层次的class文件加载功能。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>双亲委派的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">双亲委派是java为了保护程序稳定性，防止字节码重复加载，或者加载不安全的class文件的一种机制，机制规范了Java中四种加载器的</span><br><span class="line">加载class的范围.</span><br><span class="line">当一个java收到一个类加载请求的时候，不会立刻执行当前类的加载函数，而是将加载任务抛给父类加载器，父类的加载器不是继承的，而是引用父类的加载器，从而达到加载扫描的作用，如果父类已经加载了该类，当前加载函数不会重复加载，负责将由父类加载。</span><br><span class="line">当使用 类.class.getClassloader的时候返回null的时候，表明已经是顶层加载器， 否则返回的就是父类加载器地址.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>双亲委派的功能</p><ul><li>防止重复加载</li><li>防止加载不安全的class文件，比如用户自定义Long类然后加载进去，此时顶层加载器Bootstrap ClassLoader已经加载过一遍了，此时父加载器为空，所以自定义的Long类不会被加载，从而达到保证安全性的效果.</li></ul></li></ul></li></ul><p>​                        <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwb42eye8rj318l0u0wic.jpg" alt="image-20211111124501383"></p><h4 id="自定义classLoader-重写findClass方法"><a href="#自定义classLoader-重写findClass方法" class="headerlink" title="自定义classLoader, 重写findClass方法"></a>自定义classLoader, 重写findClass方法</h4><ul><li>定义加载路径</li><li>defind 解释 二进制 转换 class.</li><li>findClass 找到自定义的class</li><li>转换 class 为目标类.</li><li>扩展 可以加密class文件，更安全</li></ul><ul><li> ClassLoader加载过程源码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    </span><br><span class="line">                    // 当父类没有加载，自定义加载函数</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="热更新："><a href="#热更新：" class="headerlink" title="热更新："></a>热更新：</h4><ul><li><p>摘抄一段网上示例的代码,实现了，文件更改后，类的卸载和重新加载</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwb62rk2mgj30vk0r5n0i.jpg" alt="image-20211111135438864"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java类加载器浅析&quot;&gt;&lt;a href=&quot;#Java类加载器浅析&quot; class=&quot;headerlink&quot; title=&quot;Java类加载器浅析&quot;&gt;&lt;/a&gt;Java类加载器浅析&lt;/h2&gt;&lt;h4 id=&quot;java-文件生命周期&quot;&gt;&lt;a href=&quot;#java-文件生命周</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>github访问慢，而其他网页正常解决</title>
    <link href="http://www.010101.cc/2021/11/08/github%20%E8%AE%BF%E9%97%AE%E6%85%A2%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%BD%91%E9%A1%B5%E6%AD%A3%E5%B8%B8/"/>
    <id>http://www.010101.cc/2021/11/08/github%20%E8%AE%BF%E9%97%AE%E6%85%A2%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%BD%91%E9%A1%B5%E6%AD%A3%E5%B8%B8/</id>
    <published>2021-11-08T14:04:58.000Z</published>
    <updated>2021-11-10T06:54:04.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github-访问慢，而其他网页正常"><a href="#github-访问慢，而其他网页正常" class="headerlink" title="github 访问慢，而其他网页正常."></a>github 访问慢，而其他网页正常.</h2><h3 id="Mac-修改hosts文件"><a href="#Mac-修改hosts文件" class="headerlink" title="Mac 修改hosts文件"></a>Mac 修改hosts文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Step 1. cd /etc/</span><br><span class="line"></span><br><span class="line">Step 2. sudo vi hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 粘贴</span><br><span class="line">140.82.112.4 github.com</span><br><span class="line">140.82.113.3 gist.github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 gist.githubusercontent.com</span><br><span class="line">199.232.68.133 cloud.githubusercontent.com</span><br><span class="line">151.101.192.133 camo.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars8.githubusercontent.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;github-访问慢，而其他网页正常&quot;&gt;&lt;a href=&quot;#github-访问慢，而其他网页正常&quot; class=&quot;headerlink&quot; title=&quot;github 访问慢，而其他网页正常.&quot;&gt;&lt;/a&gt;github 访问慢，而其他网页正常.&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    
    <category term="常见问题解决" scheme="http://www.010101.cc/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>免主机，免备案，从0到1教你搭建个人博客(hexo + github page)！</title>
    <link href="http://www.010101.cc/2021/11/08/github+hexo/"/>
    <id>http://www.010101.cc/2021/11/08/github+hexo/</id>
    <published>2021-11-08T14:04:58.000Z</published>
    <updated>2021-11-09T04:46:22.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理简介："><a href="#原理简介：" class="headerlink" title="原理简介："></a>原理简介：</h3><h5 id="1-github-page-提供服务和博客文档云端托管"><a href="#1-github-page-提供服务和博客文档云端托管" class="headerlink" title="1.github page 提供服务和博客文档云端托管"></a>1.github page 提供服务和博客文档云端托管</h5><h5 id="2-hexo提供博客页面模板引擎（负责加载md文档并引用渲染到博客主页）"><a href="#2-hexo提供博客页面模板引擎（负责加载md文档并引用渲染到博客主页）" class="headerlink" title="2.hexo提供博客页面模板引擎（负责加载md文档并引用渲染到博客主页）"></a>2.hexo提供博客页面模板引擎（负责加载md文档并引用渲染到博客主页）</h5><h5 id="3-md编辑器负责本地编辑博客内容"><a href="#3-md编辑器负责本地编辑博客内容" class="headerlink" title="3.md编辑器负责本地编辑博客内容"></a>3.md编辑器负责本地编辑博客内容</h5><h5 id="4-git客户端负责push文档到github托管"><a href="#4-git客户端负责push文档到github托管" class="headerlink" title="4.git客户端负责push文档到github托管."></a>4.git客户端负责push文档到github托管.</h5><h5 id="5-github-page-负责显示推送的最新内容"><a href="#5-github-page-负责显示推送的最新内容" class="headerlink" title="5.github page 负责显示推送的最新内容"></a>5.github page 负责显示推送的最新内容</h5><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h4 id="以Mac机器为操作环境-安装步骤本篇不作讲解"><a href="#以Mac机器为操作环境-安装步骤本篇不作讲解" class="headerlink" title="以Mac机器为操作环境, 安装步骤本篇不作讲解."></a>以Mac机器为操作环境, 安装步骤本篇不作讲解.</h4><h4 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">v12.13.1</span><br></pre></td></tr></table></figure><h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 5.4.0</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: darwin 20.6.0 11.6</span><br><span class="line"></span><br><span class="line">node: 12.13.1</span><br><span class="line">v8: 7.7.299.13-node.16</span><br><span class="line">uv: 1.33.1</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.39.2</span><br><span class="line">napi: 5</span><br><span class="line">llhttp: 1.1.4</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">openssl: 1.1.1d</span><br><span class="line">cldr: 35.1</span><br><span class="line">icu: 64.2</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 12.1</span><br></pre></td></tr></table></figure><h4 id="Git客户端"><a href="#Git客户端" class="headerlink" title="Git客户端"></a>Git客户端</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version 2.23.0</span><br></pre></td></tr></table></figure><h4 id="MarkDown-编辑器"><a href="#MarkDown-编辑器" class="headerlink" title="MarkDown 编辑器"></a>MarkDown 编辑器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">博主安装的是 typora.</span><br></pre></td></tr></table></figure><h2 id="操作部署步骤"><a href="#操作部署步骤" class="headerlink" title="操作部署步骤"></a>操作部署步骤</h2><h4 id="1-总流程步骤"><a href="#1-总流程步骤" class="headerlink" title="1.  总流程步骤"></a>1.  总流程步骤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1,新建博客文档文件夹 ,博主是在桌面 /desktop</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">2,初始化blog</span><br><span class="line"></span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line">3, 编译环境</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">4, 本地查看效果</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">5, 部署github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">6, 清除本地缓存</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h4 id="2-hexo配置文件环境介绍"><a href="#2-hexo配置文件环境介绍" class="headerlink" title="2. hexo配置文件环境介绍"></a>2. hexo配置文件环境介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># hexo 配置文件，负责博客主题样式加载引导</span><br><span class="line">/blog/_config.yml</span><br><span class="line"></span><br><span class="line"># themes 博客主题文件夹 负责存储主题文件</span><br><span class="line">/blog/themes</span><br><span class="line"></span><br><span class="line"># public 此文件是对外开放的博客文件，也是推送github的文件</span><br><span class="line">/blog/public</span><br><span class="line"></span><br><span class="line"># 资源文件夹 ，负责你写的博客内容给主页加载的md部分，也可以CNAME放在其中这样Push不会被覆盖</span><br><span class="line">/blog/source</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;原理简介：&quot;&gt;&lt;a href=&quot;#原理简介：&quot; class=&quot;headerlink&quot; title=&quot;原理简介：&quot;&gt;&lt;/a&gt;原理简介：&lt;/h3&gt;&lt;h5 id=&quot;1-github-page-提供服务和博客文档云端托管&quot;&gt;&lt;a href=&quot;#1-github-page-</summary>
      
    
    
    
    
    <category term="工具使用" scheme="http://www.010101.cc/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
