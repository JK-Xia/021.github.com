<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.010101.cc/atom.xml" rel="self"/>
  
  <link href="http://www.010101.cc/"/>
  <updated>2021-11-26T13:03:36.683Z</updated>
  <id>http://www.010101.cc/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发之Redis秒杀的本质</title>
    <link href="http://www.010101.cc/2021/11/26/%E7%A7%92%E6%9D%80%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://www.010101.cc/2021/11/26/%E7%A7%92%E6%9D%80%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2021-11-26T11:28:30.000Z</published>
    <updated>2021-11-26T13:03:36.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis秒杀的本质"><a href="#Redis秒杀的本质" class="headerlink" title="Redis秒杀的本质"></a>Redis秒杀的本质</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwstxaiidaj30e8074dfs.jpg" alt="基于Redis的分布式锁- SkrNet"></p><h2 id="秒杀场景与特点"><a href="#秒杀场景与特点" class="headerlink" title="秒杀场景与特点"></a>秒杀场景与特点</h2><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul><li><strong>秒杀活动，到时间点后，用户会对商品进行购买</strong></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>秒杀场景下，瞬时的并发会比较高</li><li>商品的数量是有限的，不能超买超卖</li><li>每个用户最多只能抢购一件商品</li></ul><h3 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwstczmfw0j31a20u0gq4.jpg" alt="截屏2021-11-26 下午8.14.40"></p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ul><li><p><strong>幂等性</strong></p><ul><li><strong>任意时间同一用户IP(默认一个用户一个客户端)无论操作多少次最多只能抢到资源一次.</strong></li></ul></li><li><p><strong>原子性</strong></p><ul><li><strong>同一时间只有一个线程扣查询库存并且扣库存成功，不能被打断.</strong></li></ul></li><li><p><strong>一致性</strong></p><ul><li><strong>在扣除库存成功后，能通知到其他集群节点，防止数据脏读.</strong></li></ul></li><li><p><strong>顺序性</strong></p><ul><li><strong>有序的更新数据库库存，温柔的像个绅士.</strong></li></ul></li></ul><h3 id="Redis-的-Lua脚本"><a href="#Redis-的-Lua脚本" class="headerlink" title="Redis 的 Lua脚本"></a>Redis 的 Lua脚本</h3><h4 id="脚本的原子性-官方介绍"><a href="#脚本的原子性-官方介绍" class="headerlink" title="脚本的原子性(官方介绍)"></a>脚本的原子性(官方介绍)</h4><ul><li><p>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of <a href="https://redis.io/commands/multi">MULTI</a> / <a href="https://redis.io/commands/exec">EXEC</a>. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</p><p>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</p></li><li><p><strong>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 <a href="http://www.redis.cn/commands/multi.html">MULTI</a> / <a href="http://www.redis.cn/commands/exec.html">EXEC</a> 包围的事务很类似。 在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。 另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难， 因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心， 因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</strong></p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS [goods]</span></span><br><span class="line"><span class="comment">-- ARGV [uid]</span></span><br><span class="line"><span class="comment">-- return -1-库存不足 0-重复购买 1-成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> goods = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> activity = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> uid = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> goodsuids = goods .. <span class="string">&#x27;:&#x27;</span> .. activity .. <span class="string">&#x27;:uids&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> goodsstock = goods .. <span class="string">&#x27;:&#x27;</span> .. activity .. <span class="string">&#x27;:stock&#x27;</span></span><br><span class="line"><span class="keyword">local</span> stock = redis.call(<span class="string">&#x27;GET&#x27;</span>, goodsstock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> stock <span class="keyword">or</span> <span class="built_in">tonumber</span>(stock) &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> isin = redis.call(<span class="string">&#x27;SISMEMBER&#x27;</span>, goodsuids, uid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isin &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&#x27;DECR&#x27;</span>, goodsstock)</span><br><span class="line">redis.call(<span class="string">&#x27;SADD&#x27;</span>, goodsuids, uid)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从参数中获取goods编号，activity编号，uid。</span><br><span class="line"><span class="number">1.</span>首先判断库存</span><br><span class="line">#使用GET命令，查询“goods:activity:stock”获取库存，判断是否还有库存，库存小于等于<span class="number">0</span>，返回<span class="number">-1</span></span><br><span class="line"><span class="number">2.</span>判断是否已经购买过</span><br><span class="line">#使用SISMEMBER命令，判断“goods:activity:uids”set中，是否有uid，有表示参加过秒杀，返回<span class="number">0</span></span><br><span class="line"><span class="number">3.</span>减库存</span><br><span class="line">#使用DECR命令，对“goods:activity:stock”减一，扣减库存.</span><br><span class="line"><span class="number">4.</span>更新参与秒杀记录</span><br><span class="line">#使用SADD命令添加“goods:activity:uids”用户uid，返回<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis秒杀的本质&quot;&gt;&lt;a href=&quot;#Redis秒杀的本质&quot; class=&quot;headerlink&quot; title=&quot;Redis秒杀的本质&quot;&gt;&lt;/a&gt;Redis秒杀的本质&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i m</summary>
      
    
    
    
    <category term="Redis" scheme="http://www.010101.cc/categories/Redis/"/>
    
    
    <category term="高并发原子锁" scheme="http://www.010101.cc/tags/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro intel日常使用问题记录</title>
    <link href="http://www.010101.cc/2021/11/20/MBP%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.010101.cc/2021/11/20/MBP%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-19T19:12:21.000Z</published>
    <updated>2021-11-19T19:25:54.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MacBook-Pro-蓝牙模块修复"><a href="#MacBook-Pro-蓝牙模块修复" class="headerlink" title="MacBook Pro 蓝牙模块修复"></a>MacBook Pro 蓝牙模块修复</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwl2cvhuagj30gw0migmt.jpg" alt="截屏2021-11-20 上午3.20.25"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul><li><p>按住键盘 ⌥ Option + ⇧ Shift 的同时，点击菜单栏中的 Bluetooth图标</p></li><li><p>在弹出的下拉菜单中选择「还原蓝牙模块」</p></li><li><p>确认继续操作.</p></li></ul><h2 id="MacBook-Pro-快捷键"><a href="#MacBook-Pro-快捷键" class="headerlink" title="MacBook Pro 快捷键"></a>MacBook Pro 快捷键</h2><h4 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h4><ul><li>Shift＋Command＋3 / Shift＋Command＋4</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MacBook-Pro-蓝牙模块修复&quot;&gt;&lt;a href=&quot;#MacBook-Pro-蓝牙模块修复&quot; class=&quot;headerlink&quot; title=&quot;MacBook Pro 蓝牙模块修复&quot;&gt;&lt;/a&gt;MacBook Pro 蓝牙模块修复&lt;/h2&gt;&lt;p&gt;Wirte </summary>
      
    
    
    
    <category term="工具使用" scheme="http://www.010101.cc/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具使用问题" scheme="http://www.010101.cc/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础之麻辣香锅</title>
    <link href="http://www.010101.cc/2021/11/20/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%BA%BB%E8%BE%A3%E9%A6%99%E9%94%85/"/>
    <id>http://www.010101.cc/2021/11/20/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%BA%BB%E8%BE%A3%E9%A6%99%E9%94%85/</id>
    <published>2021-11-19T19:08:02.000Z</published>
    <updated>2021-11-22T07:03:31.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言基础之麻辣香锅"><a href="#C语言基础之麻辣香锅" class="headerlink" title="C语言基础之麻辣香锅"></a>C语言基础之麻辣香锅</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="家常菜之-—-C基础语法"><a href="#家常菜之-—-C基础语法" class="headerlink" title="家常菜之 — C基础语法"></a>家常菜之 — C基础语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Assembly</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 021 on 2020/11/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> <span class="comment">//找包含文件目录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.cpp&quot;</span> <span class="comment">//找当前目录，</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int myOperation(int a, int b);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySwitch</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;Monday\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;Tuesday\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;Wednesday\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;Thursday\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;Friday\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;Saturday\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">&quot;Sunday\n&quot;</span>); <span class="keyword">break</span>;                </span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">&quot;8\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;9\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">10</span>: <span class="built_in">printf</span>(<span class="string">&quot;10\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myGoto</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    A :      <span class="comment">// 0x00001234 内存地址</span></span><br><span class="line">    </span><br><span class="line">    b++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b =%u\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">if</span>(b&lt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> A;  <span class="comment">// jmp 0x00001234; 直接跳转，重复执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;goto循环结束 =%u\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myWhile</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;while循环中 b =%u\n&quot;</span>,b);</span><br><span class="line">        b++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a=2 被continue跳过了，不会打印&quot;</span>,b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;while循环结束 =%u\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDoWhile</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>               <span class="comment">// 0x0000 0001;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;do while循环开始 =%u\n&quot;</span>,b);</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b&lt;=a);    <span class="comment">// 判断 ， 条件符合 jmp 0x0000 0001;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;do while循环结束 =%u\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFor</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="comment">//for(表达式1不要求有返回值;表达2要求有返回值,不是0就成立;表达式3不要有返回值)</span></span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>,d =<span class="number">2</span>;b&lt;a;b++,c++,d++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;for循环 =%u\n&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;for循环结束 =%u\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayOverStackTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arrayOverStackTest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myArrayOverStack</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">6</span>]=(<span class="keyword">int</span>)&amp;arrayOverStackTest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">methodAgrTest</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">methodArrAgrTest</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayTest</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组传参传的是数组第一个元素的地址，遍历元素值= %p\n&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组传参传的是数组第一个元素的地址，遍历元素值= %p\n&quot;</span>,*(&amp;a[i]));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayPointTest</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组指针传参传的是数组第一个元素的地址，遍历元素值= %d\n&quot;</span>,*(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">my_cdecl</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">my_stdcall</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">my_fastcall</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my8byteStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">double</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myPointSize</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">double</span> b1;</span><br><span class="line">    <span class="keyword">double</span> b2;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据宽度对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myPragmaStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">0x14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> name1 <span class="meta-string">&quot;021&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hello1 <span class="meta-string">&quot;你好，&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mystr strcpy(hello1,name1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//整型</span></span><br><span class="line">    <span class="comment">//-128 --- signed --- 0 --- unsigned --- 127；</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//1byet 0xff</span></span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">0xffff</span>; <span class="comment">// 2byte 0xffff</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0xffffffff</span>; <span class="comment">//4byte</span></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">0xffffffff</span>; <span class="comment">//4byte</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char : %c %d\n&quot;</span>,c,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short : %c %d\n&quot;</span>,s,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int i 无符号: %u int i 有符号: %d\n&quot;</span>,i,i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *符号表示 , 编译器只关注数值存储，取数时有无符号有区别；默认有符号；</span></span><br><span class="line"><span class="comment">     *大部分计算机只存补码， 符号位将影响取值和判断.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">char</span> sc = <span class="number">-1</span>; <span class="comment">// 1111 1111 0xff;  0000 0001 %u = 4294967295</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> usc = <span class="number">-1</span>; <span class="comment">// 补码+1 = 1111 1111 , 0xff</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> usc1 = <span class="number">-2</span>; <span class="comment">// 0000 0010 -&gt; 1111 1101 + 1 -&gt; 1111 1110 -&gt; 0xfe;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc有符号=%d,转换成无符号=%u\n&quot;</span>,sc,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)sc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc 无符号数（扩展错误数值） ： %u\n&quot;</span>,sc); <span class="comment">//此时取值可能进行了扩展 ,%u = 4294967295</span></span><br><span class="line">    <span class="comment">//有无符号之间转换</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无符号usc=%u,无符号转有符号usc=%d\n&quot;</span>,usc,(<span class="keyword">char</span>)usc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数据宽度扩展：低位为数据位， 高位为符号位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//将有符号8位char类型放入32位int类型，</span></span><br><span class="line">     <span class="keyword">int</span> i1 = sc; <span class="comment">// 1111 1111 -&gt; 0xffffff + 1111 1111 = 0xffffffff;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有符号sc数据扩展int=%u,无符号转有符号=%d\n&quot;</span>,i1,(<span class="keyword">int</span>)i1);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数据宽度溢出</span></span><br><span class="line"><span class="comment">     *溢出的值为正的：实际值为：溢出后的值 - 该类型能表示的立即数</span></span><br><span class="line"><span class="comment">     *溢出的值为负的：实际值为：溢出后的值 + 该类型能表示的立即数</span></span><br><span class="line"><span class="comment">     *其中-0的原码是：   1000 0000 补码是：1 0000 0000 = 128的由来，+0 -0有点无厘头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//默认有符号，0xff的数据区间：有符号最小值：1111 1111 = -0x7f=-127; 最大值：0111 1111 = 0x7f =127;</span></span><br><span class="line">    <span class="keyword">char</span> sc1 = <span class="number">256</span>; <span class="comment">//将256存入 -127 — 127数据宽度区间 发生溢出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据宽度溢出sc1=%u\n&quot;</span>,sc1); <span class="comment">//256- 1111 1111 = 0；</span></span><br><span class="line">    <span class="keyword">char</span> sc2 = <span class="number">-258</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据宽度溢出sc2=%d\n&quot;</span>,sc2); <span class="comment">//-257 + 1111 1111 = -2；</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *浮点类型</span></span><br><span class="line"><span class="comment">     *float    1位（符号位）    8位（整数位）    23位（尾数位）</span></span><br><span class="line"><span class="comment">     *double    1位（符号位）    11位（整数位）    52位（尾数位）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">123.25f</span>; <span class="comment">// 0xffffffff;</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">22.22</span>; <span class="comment">// 0xffffffff ffffffff;;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数f=%f\n&quot;</span>,f); <span class="comment">//-257 + 1111 1111 = -2；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有符号sc数据扩展int=%u&quot;</span>,<span class="number">0xffffffac</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Switch</span></span><br><span class="line">    mySwitch(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环goto</span></span><br><span class="line">    myGoto(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环while</span></span><br><span class="line">    myWhile(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环doWhile</span></span><br><span class="line">    myDoWhile(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环for</span></span><br><span class="line">    myFor(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// 不赋值，堆栈也默认会提升;</span></span><br><span class="line">    <span class="keyword">int</span> array1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// mov dword [ebp+4], 0x01;</span></span><br><span class="line">    <span class="keyword">char</span> charArray[<span class="number">10</span>] ; <span class="comment">//本机宽度 ，内存对齐, 32位 4byte对齐， 64位 8byte对齐;</span></span><br><span class="line">    <span class="keyword">short</span> shortArray[<span class="number">10</span>] ; <span class="comment">//本机宽度 ，内存是对齐,</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数组越界</span></span><br><span class="line">    myArrayOverStack(array1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *多维数组 , 一个班2个组，一个组5个人 //内存分布与一维数组一样</span></span><br><span class="line"><span class="comment">     *内存中数据被打平存储 ： 1,2,3,4,5, 5,4,3,2,1</span></span><br><span class="line"><span class="comment">     *索引 array[2][3] = array[(2-1)*5+3] 算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> array2[<span class="number">2</span>][<span class="number">5</span>] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构体/自定义类型， 未赋值之前不占用任何内存空间.</span></span><br><span class="line">    <span class="comment">//结构体为全局变量时占用空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> <span class="title">ms</span> =</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体属性值 c=%u\n&quot;</span>,ms.c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ---------------- 字节对齐 ---------------</span></span><br><span class="line"><span class="comment">     * 全局变量， char c; int z;  变量内存地址是变量类型宽度的整数倍;</span></span><br><span class="line"><span class="comment">     * 以类型宽度最大的为准，上述以int为准，int 类型4byte，那么内存地址是4的整数倍;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体属性c数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(ms.c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体属性s数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(ms.s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(ms));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my8byteStruct</span> <span class="title">m8s</span> =</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//大尺寸对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体m8s属性c数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(m8s.c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体m8s属性s数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(m8s.s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体m8s数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(m8s));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *改变结构体数据宽度对齐</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myPragmaStruct</span> <span class="title">mps</span> =</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 压缩结构体尺寸,</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体mps属性c数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(mps.c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体mps属性i数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(mps.c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体mps属性s数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(mps.d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体mps数据宽度=%u\n&quot;</span>,<span class="keyword">sizeof</span>(mps));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构体数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">p</span>[2];</span></span><br><span class="line">    p[<span class="number">0</span>].age = <span class="number">0x12</span>;</span><br><span class="line">    stpcpy(p[<span class="number">0</span>].name,<span class="string">&quot;021&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体person属性c数据值= %d\n&quot;</span>,p[<span class="number">0</span>].age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体person属性name数据值= %s\n&quot;</span>,p[<span class="number">0</span>].name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *指针类型 :</span></span><br><span class="line"><span class="comment">     *多星的时候恒定数据宽度为4= char** cp ，一星的 char* cp 数据宽度=指针类型的宽度;</span></span><br><span class="line"><span class="comment">     *指针类型运算时以 指针类型的数据宽度为基数自增</span></span><br><span class="line"><span class="comment">     *指针无符号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* cp ; <span class="comment">//char******* cp ;</span></span><br><span class="line">    <span class="keyword">int</span>* ip ;</span><br><span class="line">    <span class="keyword">short</span>* sp ;</span><br><span class="line">    cp = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    ip = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    sp = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">p1</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针类型person数据值= %p\n&quot;</span>,p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针类型cp数据值= %d\n&quot;</span>,cp);</span><br><span class="line">    cp++;</span><br><span class="line">    ip++;</span><br><span class="line">    sp++;</span><br><span class="line">    <span class="comment">//指针类型不能做乘法和除法</span></span><br><span class="line">    <span class="comment">//sp*1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char指针类型cp自增后数据值= %d, 数据宽度=%d\n&quot;</span>,cp,<span class="keyword">sizeof</span>(cp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int指针类型ip自增后数据值= %d\, 数据宽度=%d\n&quot;</span>,ip,<span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short指针类型sp自增后数据值= %d\, 数据宽度=%d\n&quot;</span>,sp,<span class="keyword">sizeof</span>(sp));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针类型比较</span></span><br><span class="line">    <span class="keyword">if</span>(ip&gt;cp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;指针类型比较后数据值= %d\n&quot;</span>,ip);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取地址符 &amp; , 只能和变量用</span></span><br><span class="line"><span class="comment">     *  lea指令=将局部变量地址获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;取地址符 &#x27;&amp;&#x27; ,sp地址值= %p\n&quot;</span>,&amp;sp);</span><br><span class="line">    <span class="comment">//类型不匹配 能过编译，执行不生效</span></span><br><span class="line">    <span class="keyword">int</span> ip1 = &amp;cp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;取地址符 &#x27;&amp;&#x27; ,ip1地址值= %p cp=%p\n&quot;</span>,&amp;ip1,&amp;cp);</span><br><span class="line">    <span class="keyword">char</span>* cp1 = &amp;cp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;取地址符 &#x27;&amp;&#x27; ,cp1地址值= %p cp=%p\n&quot;</span>,&amp;cp1,&amp;cp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取值运算符: &#x27;*&#x27;,</span></span><br><span class="line"><span class="comment">     *  指针取地址值符 * , 只能指针类型用</span></span><br><span class="line"><span class="comment">     *  int*** a ; *a取值会变成 = int** a;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>* ip2 = &amp;ip;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针取值运算符 &#x27;*&#x27; ,指针cp1存储的数据值= %d\n&quot;</span>,*cp1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针取值运算符 &#x27;*&#x27; ,指针ip2存储的数据值= %d\n&quot;</span>,*ip2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* ip3 = &amp;i2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针地址取值&#x27;&amp;&#x27; 地址值=%p ,指针取值运算符 &#x27;*&#x27; ,指针cp1存储的数据值= %d\n&quot;</span>,&amp;i2,*ip3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数传递，是地址传参，还是值传参，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> methodAgr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> methodAgrTestValue = methodAgrTest(methodAgr);</span><br><span class="line">    methodAgrTest(methodAgr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;值传参还是地址传参 答案是值传递数据值= %d\n&quot;</span>,methodAgr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;值传参还是地址传参 答案是值传递数据值= %d\n&quot;</span>,methodAgrTestValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数组传参</span></span><br><span class="line"><span class="comment">     *传递的是数组首地址第一个元素 int array[2] = &#123;1,2&#125; ;</span></span><br><span class="line"><span class="comment">     *  mov  eax  , &amp;array[1];     // 数组第一个元素的地址</span></span><br><span class="line"><span class="comment">     *  array[2] = lea dword ds:[eax+1*4] ;  // 获取第二个元素是使用 第一个元素地址偏移量*4；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> arrayTestArg[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    arrayTest(arrayTestArg,<span class="number">2</span>);</span><br><span class="line">    arrayPointTest(&amp;arrayTestArg[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  字符串函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>] =&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>&#125;;    <span class="comment">//需要手动补0;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串str= %s\n&quot;</span>,str);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先在常量区 创建&#x27;021&#x27;, 再把&#x27;021&#x27;复制到数组str1[]中，进行操作;</span></span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">4</span>] = <span class="string">&quot;021&quot;</span>;           <span class="comment">//编译器自动补0；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串str1= %s\n&quot;</span>,str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串str1= %s\n&quot;</span>,*(&amp;str1));</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">9</span>] = <span class="string">&quot;021中国&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen函数字符串str1长度= %d，值=%s\n&quot;</span>,<span class="built_in">strlen</span>(str2),&amp;str2);</span><br><span class="line">    <span class="keyword">char</span> cp3[<span class="number">6</span>] ;</span><br><span class="line">    <span class="built_in">strcpy</span>(cp3, <span class="string">&quot;china&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strcpy复制字符串cp3= %s\n&quot;</span>,cp3);</span><br><span class="line">    <span class="keyword">char</span> love[<span class="number">10</span>] ;</span><br><span class="line">    <span class="keyword">char</span> you[<span class="number">10</span>] ;</span><br><span class="line">    <span class="built_in">strcpy</span>(love, <span class="string">&quot;l love&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(you, <span class="string">&quot;you&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(love,you);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strcat拼接字符串= %s\n&quot;</span>,love);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> love1[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">char</span> love2[<span class="number">9</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(love1, <span class="string">&quot;l love&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(love2, <span class="string">&quot;l love&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> stat =<span class="built_in">strcmp</span>(love1,love2); <span class="comment">//0相同，非0不相同；</span></span><br><span class="line">    <span class="keyword">if</span>(!stat)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;strcmp判断字符串love1与love2相同\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一级指针与多级指针</span></span><br><span class="line"><span class="comment">     * 外包装*加1；</span></span><br><span class="line"><span class="comment">     * 拆包装*减1；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//包装</span></span><br><span class="line">    <span class="keyword">int</span> ip4 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* ip5 = &amp;ip4;</span><br><span class="line">    <span class="keyword">int</span>** ip6 = &amp;ip5;</span><br><span class="line">    <span class="keyword">int</span>*** ip7 = &amp;ip6;</span><br><span class="line">    <span class="comment">//解包装</span></span><br><span class="line">    <span class="keyword">int</span> ip8 = *(*(*(ip7)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;多级指针 ip8=%d\n&quot;</span>,ip8);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;多级指针 ip7=%d\n&quot;</span>,***ip7);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构体指针 数据宽度恒定4字节</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myPoint</span> <span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myPoint</span>* <span class="title">mp1</span> =</span> &amp;mp; <span class="comment">//类型对齐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体指针数据宽度 mp1=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(mp1));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    mp1-&gt;a = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体指针获取数据值mp1.a=%d\n&quot;</span>,mp1-&gt;a);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数组指针指向结构体指针 数据宽度恒定4字节</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myPoint</span>* <span class="title">mp2</span> =</span> (struct myPoint*)&amp;arr; <span class="comment">//指针类型强转</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体指针获取数据值mp2.a=%d\n&quot;</span>,mp2-&gt;a);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指针数组与数组指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//指针数组 数据宽度恒定4字节</span></span><br><span class="line">    <span class="keyword">char</span> arr2[<span class="number">10</span>];<span class="comment">//20byte</span></span><br><span class="line">    <span class="keyword">char</span>* arr3[<span class="number">10</span>]; <span class="comment">//40byte 10指针(10* char*);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myPoint</span>* <span class="title">arr4</span>[10];</span> <span class="comment">//40byte 10指针(10* myPoint*);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* c2 = <span class="string">&quot;china&quot;</span>; <span class="comment">//将china字符串常量内存地址赋值给C1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* c1 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//将hello字符串常量内存地址赋值给C1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* c3[<span class="number">10</span>] = &#123;c1,c2&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体指针获取数据值c3=%s\n&quot;</span>,c3[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数组指针 数据宽度恒定4字节 , cpu位数不同指针宽度可能不同</span></span><br><span class="line">    <span class="keyword">int</span> arr5[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* arrPoint = &amp;arr5; <span class="comment">//数组指针,取数组里第一个元素的地址</span></span><br><span class="line">    <span class="keyword">int</span>* arrPoint1 = ++arrPoint;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体指针获取数据值arrPoint=%p ，指针值=%d \n&quot;</span>,&amp;arrPoint1,*arrPoint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arrPoint2 = ++arrPoint;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体指针获取数据值arrPoint=%p ，指针值=%d \n&quot;</span>,&amp;arrPoint2,*arrPoint);</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *函数指针—— 按照自定义方式调用目标函数;</span></span><br><span class="line"><span class="comment">     * 使用别人写好的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//定义函数指针,模拟自己写好的int __cdecl my_cdecl(int a,int b)函数</span></span><br><span class="line">    <span class="comment">//自己写的函数</span></span><br><span class="line">    <span class="keyword">int</span> result1 = my_cdecl(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数指针调用被调用函数返回结果值=%d 返回值地址=%p\n&quot;</span>,result1,&amp;result1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (__cdecl *my_cdeclCall)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值 ; 函数指针赋值执行地址,0x100002830为my_cdecl函数调用地址，此处为硬编码</span></span><br><span class="line">    <span class="comment">//0x1000033c9 &lt;+2873&gt;: callq  0x100002830               ; my_cdecl at main.c:145</span></span><br><span class="line">    <span class="comment">//my_cdeclCall = (int (__cdecl *)(int,int))0x1000027d0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用函数指针</span></span><br><span class="line">    <span class="comment">//int result = my_cdeclCall(1,2); //结果为3;</span></span><br><span class="line">    <span class="comment">//printf(&quot;函数指针调用返回结果值=%d \n&quot;,result);</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用公约</span></span><br><span class="line"><span class="comment">     * _cdecl  - 从右到左压栈，调用者平栈(外平栈)</span></span><br><span class="line"><span class="comment">     * _stdcall - 从右到左压栈，函数自身平栈(内平栈)</span></span><br><span class="line"><span class="comment">     * _fastcall - ecx edx 传送前两个参数，剩下的从右到左入栈，函数自身平栈(内平栈)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg1 = <span class="number">1</span>;</span><br><span class="line">    my_cdecl(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    my_stdcall(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    my_fastcall(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理与自定义宏</span></span><br><span class="line"><span class="comment">     * 逻辑少的时候用宏</span></span><br><span class="line"><span class="comment">     * 逻辑多的时候用函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// #define name1 &quot;021&quot;</span></span><br><span class="line">    <span class="comment">// #define true 1</span></span><br><span class="line">    <span class="comment">// #define false 0</span></span><br><span class="line">    <span class="comment">// #define hello1 &quot;你好，&quot;</span></span><br><span class="line">    <span class="comment">// #define mystr strcpy(hello,name)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;自定义宏调用返回结果值=%s \n&quot;</span>,name1);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件编译与文件包含</span></span><br><span class="line"><span class="comment">     * 条件编译主要用于调试与测试代码的管理，把测试代码不编译到源文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * #undef debug //取消之前定义debug宏</span></span><br><span class="line"><span class="comment">     * #define debug 0 //重新定义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * #if debug</span></span><br><span class="line"><span class="comment">     *      printf(&quot;编译后可以生成反汇编.&quot;);</span></span><br><span class="line"><span class="comment">     * #endif</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * #if debug</span></span><br><span class="line"><span class="comment">     *      printf(&quot;编译后不能生成反汇编.&quot;);</span></span><br><span class="line"><span class="comment">     * #endif</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * #if define b  //如果b定义了编译</span></span><br><span class="line"><span class="comment">     *       printf(&quot;编译后可以生成反汇编.&quot;);</span></span><br><span class="line"><span class="comment">     * #elif define a //如果a定义了编译</span></span><br><span class="line"><span class="comment">     *       printf(&quot;编译后可以生成反汇编.&quot;);</span></span><br><span class="line"><span class="comment">     * #else define c //如果c定义了编译</span></span><br><span class="line"><span class="comment">     *       printf(&quot;编译后可以生成反汇编.&quot;);</span></span><br><span class="line"><span class="comment">     * #endif</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//使用包含文件函数</span></span><br><span class="line">    <span class="keyword">int</span> fileResult = myAdd(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用包含文件函数，返回结果=%d \n&quot;</span>,fileResult);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="厨师长特调之-—–-浮点数"><a href="#厨师长特调之-—–-浮点数" class="headerlink" title="厨师长特调之 —– 浮点数"></a>厨师长特调之 —– 浮点数</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwllggtsu9j30u0074weu.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwllgk36qbj30u006jq3a.jpg" alt="img"></p><h3 id="精度概要"><a href="#精度概要" class="headerlink" title="精度概要"></a>精度概要</h3><ul><li><p><strong>对于float型浮点数，尾数部分23位，换算成十进制就是2^23=8388608，所以十进制精度只有6 ~ 7位；</strong></p></li><li><p><strong>对于double型浮点数，尾数部分52位，换算成十进制就是2^52 = 4503599627370496，所以十进制精度只有15 ~ 16位</strong></p></li></ul><pre><code>* **前景概要与演练**</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwlmoqt3m2j30xm0htmyh.jpg" alt="截屏2021-11-20 下午3.01.21"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 求十进制浮点数 ，求转换 12.34</span><br><span class="line">1 * 10¹ + 2*1（10零次方） + 3 * 1/10（10的负一次方）+ 4 * 1/10*10(10的负二次方)</span><br><span class="line">浮点数的规范后： 1.234 * 10¹ ; 指数为1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 二进制浮点转十进制 ，求转换 1100.11</span><br><span class="line">1 * 2*2*2（三次方） + 1 * 2*2(二次方) + 0 * 2(一次方) + 0 * 1(2的0次方) + 1 * 1/2¹ + 1 * 1/2*2(二次方)</span><br><span class="line">=  8 + 4 + 0 + 0 + 1/2 + 1/4</span><br><span class="line">=  12.75</span><br><span class="line">浮点数的规范后： 2.475 * 10¹; 指数为1;</span><br><span class="line"></span><br><span class="line">求 1010.01 的十进制，二进制浮点数规范后= 1.01001 * 2*2*2 指数: 3</span><br><span class="line">1 * 2*2*2 + 0 * 2*2 + 1 * 2 + 0 * 2(零次方) + 0 * 1/2¹ + 1 * 1/2²</span><br><span class="line">= 8 + 0 + 2 + 0 + 1/2 + 1/4</span><br><span class="line">= 10.75 </span><br><span class="line">10进制浮点数的规范后： 1.075 * 10¹; 指数为1;</span><br><span class="line"></span><br><span class="line">求 10101.01 的十进制，二进制浮点数规范后= 1.010101 * 2*2*2*2 指数: 4</span><br><span class="line">1 * 2*2*2*2 + 0 * 2*2*2 + 1 * 2*2 + 0 * 2 + 1 * 1（2的零次方）+ 0 * 1/2 + 1 * /2*2</span><br><span class="line">= 16 + 0 + 4 + 0 + 1 + 0 + 1/4</span><br><span class="line">= 21.25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="浮点数二进制存储表示"><a href="#浮点数二进制存储表示" class="headerlink" title="浮点数二进制存储表示"></a>浮点数二进制存储表示</h4><ul><li><p><strong>1，确定符号位</strong></p></li><li><p><strong>2，确定指数偏移量</strong></p></li><li><p><strong>3，对齐小数位并补0(总共23位)</strong></p></li></ul><h5 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h5><ul><li><p>0 正</p></li><li><p>1 负</p></li></ul><h5 id="指数位"><a href="#指数位" class="headerlink" title="指数位"></a>指数位</h5><ul><li><strong>按照127+指数偏移量得出二进制，填充进指数位，填充8位</strong></li></ul><h5 id="小数位"><a href="#小数位" class="headerlink" title="小数位"></a>小数位</h5><ul><li><strong>去掉 浮点规范后的 整数位，低位补0，补齐23位</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">求 1.125的小数位:</span><br><span class="line"></span><br><span class="line">0.125×2=0.25 取整数位0</span><br><span class="line">0.25×2=0.5 取整数位0</span><br><span class="line">0.5×2=1 取整数位1</span><br><span class="line"></span><br><span class="line">小数部分所得结果为 001;</span><br><span class="line"></span><br><span class="line">为什么这么做， 当尾数*2=1的时候代表有进位，才能标记.</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>那我们来测试一下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">简单点以5结尾的小数；</span><br><span class="line"></span><br><span class="line">求 123.25 的内存存储</span><br><span class="line"></span><br><span class="line">1. 首先求出二进制数（小规律，先求数据宽度区间最大数和最小数，然后依次取最大数填充，这样就不用计算器了）</span><br><span class="line">123 = 100 + 20 + 3 =   1 1  1 1  1 1 1 1  =  01??  +  ?1(确定最大最小数) </span><br><span class="line"> 128 64 32  16 8 4 2 1</span><br><span class="line"> </span><br><span class="line">= 64 + 3 ，还差56，继续填充 = 01 1(32) 1(16) 1(8)011 = 0111 1011; 最终整数部分;</span><br><span class="line"></span><br><span class="line">小数部分：结果01</span><br><span class="line">推出:</span><br><span class="line">0.25 * 2 ; 0</span><br><span class="line">0.50 * 2 ; 1</span><br><span class="line"></span><br><span class="line">整合: 0111 1011.01 , 浮点数规范 ： 1.11 1011 01 指数为8; （错误）</span><br><span class="line">整合: 0111 1011.01 , 浮点数规范 ： 1.111011 01 指数为6; (正确)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2,定义符号位：</span><br><span class="line">正数 = 0；</span><br><span class="line"></span><br><span class="line">3，定义指数位:</span><br><span class="line">127 + 8 = 135 = 1000 0111（错误）</span><br><span class="line">127 + 6 = 133 = 1000 0101 (正确)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4,定义尾数部分 ，去掉整数部分，低位补齐0，23位； 1.11101101 = 1110 1101；</span><br><span class="line"></span><br><span class="line">5，整合：</span><br><span class="line">0 + 1000 0111 + 1110 1101 = 0100 0011 1111 0110 1000 0000 0000 0000 = 0x43f68000; （错误）</span><br><span class="line">//纠错</span><br><span class="line">0 + 1000 0101 + 1110 1101 = 0100 0010 1111 0110 1000 0000 0000 0000 = 0x42f68000;（正确）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结果 和 程序运行有误差 ... 0x42F68000 这个才是正确的，找一下问题：</span><br><span class="line">整合: 0111 1011.01 , 浮点数规范 ： 1.11 1011 01 指数为8; （错误） 这里位移脑子抽了，计算失误. 还是计算机好...</span><br><span class="line"></span><br><span class="line">//到此 结果正确，</span><br><span class="line">0 + 1000 0101 + 1110 1101 = 0100 0010 1111 0110 1000 0000 0000 0000 = 0x42f68000;（正确）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="厨师长特调之-—–-Switch算法（参考数组存储）"><a href="#厨师长特调之-—–-Switch算法（参考数组存储）" class="headerlink" title="厨师长特调之 —– Switch算法（参考数组存储）"></a>厨师长特调之 —– Switch算法（参考数组存储）</h3><ul><li><p><strong>在特定区间连续条件下，switch算法会进行优化</strong></p></li><li><p><strong>switch会维护一张地址表，编译器优化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模拟代码逻辑:</span><br><span class="line"></span><br><span class="line">int minCase = 1; 最小的条件语句</span><br><span class="line"></span><br><span class="line">int maxCase = 9; 最大</span><br><span class="line"></span><br><span class="line">int myCondition = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//最小值处理，如果小于最小值直接不符合case区间，也会直接走default;</span><br><span class="line">if(myCondition &lt; minCase) 如果大于最大值；直接跳默认值</span><br><span class="line">&#123;</span><br><span class="line">// Jcc跳转</span><br><span class="line">jmp default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最大值处理，如果大于最大值直接不符合case区间，直接走default;</span><br><span class="line">if(myCondition &gt; maxCase) 如果大于最大值；直接跳默认值</span><br><span class="line">&#123;</span><br><span class="line">// Jcc跳转</span><br><span class="line">jmp default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//连续case区间逻辑跳转，参数数组内存存储,编译器优化连续case，利用偏移量找位置</span><br><span class="line">if((myCondition - minCase)*4的内存地址) </span><br><span class="line">&#123;</span><br><span class="line">如果条件为1 ； 1-1 = 0 ； 0 * 4 = 0 ；跳转到索引表第0个，一次类推，这个表的算法是编译器优化的，</span><br><span class="line">jmp addresstable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwmokvwjbbj31c00u0tfq.jpg" alt="截屏2021-11-21 下午12.55.12"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwnxt1zedlj31c00u0dqi.jpg" alt="截屏2021-11-21 下午12.55.19"></p><ul><li><strong>在case区间大的时候 switch 无法优化</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwnxsxz7e7j31c00u0n40.jpg" alt="截屏2021-11-20 下午9.28.18"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwlxtiksvoj31c00u0dpm.jpg" alt="截屏2021-11-20 下午9.29.41"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言基础之麻辣香锅&quot;&gt;&lt;a href=&quot;#C语言基础之麻辣香锅&quot; class=&quot;headerlink&quot; title=&quot;C语言基础之麻辣香锅&quot;&gt;&lt;/a&gt;C语言基础之麻辣香锅&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i m</summary>
      
    
    
    
    <category term="C语言" scheme="http://www.010101.cc/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://www.010101.cc/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Kill someone who wirting C++&amp;Java!</title>
    <link href="http://www.010101.cc/2021/11/20/C++%E7%9A%84%E8%8A%B1%E6%8B%B3%E7%BB%A3%E8%85%BF/"/>
    <id>http://www.010101.cc/2021/11/20/C++%E7%9A%84%E8%8A%B1%E6%8B%B3%E7%BB%A3%E8%85%BF/</id>
    <published>2021-11-19T19:08:02.000Z</published>
    <updated>2021-11-22T10:08:33.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杀了那个写C-和Java的人！"><a href="#杀了那个写C-和Java的人！" class="headerlink" title="杀了那个写C++和Java的人！"></a>杀了那个写C++和Java的人！</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="封装-amp-继承-amp-多态"><a href="#封装-amp-继承-amp-多态" class="headerlink" title="封装&amp;继承&amp;多态"></a>封装&amp;继承&amp;多态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  myMain.cpp</span></span><br><span class="line"><span class="comment">//  Assembly</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by jiankang on 2020/11/22.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">    <span class="keyword">char</span>* heapObject;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this当前指针=%p\n&quot;</span>,&amp;(<span class="keyword">this</span>-&gt;name));</span><br><span class="line">    &#125;</span><br><span class="line">    person2(<span class="keyword">int</span> age,<span class="keyword">char</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="comment">//heapObject = (char*)malloc(1024);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;有参构造函数执行了，成员变量赋值初始化 \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    person2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空参构造函数执行了 \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数 负责清理工作，Java的finalize</span></span><br><span class="line">    ~person2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;析构函数执行了，对象要销毁了 \n&quot;</span>);</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="comment">//free(heapObject);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;person2父类多态方法被调用了 \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">teacher</span> :</span><span class="keyword">public</span> person2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> coachAge;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;teacher子类多态方法被调用了 \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(person2* p)</span></span>&#123;</span><br><span class="line">    p-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myMain.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line">person2 p1; <span class="comment">//全局变量，堆中分配，构造函数和析构函数(进程退出之前)都会执行;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//局部变量在堆栈中分配,构造函数和析构函数(方法退出之前)都会执行</span></span><br><span class="line">    person2 p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this会存储在ecx寄存器中,当前指针=%p\n&quot;</span>,&amp;p);</span><br><span class="line">    p.printThis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)&amp;p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip当前指针=%p\n&quot;</span>,&amp;ip);</span><br><span class="line">    <span class="keyword">int</span>* ip1 = ++ip;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip当前指针=%p\n&quot;</span>,&amp;ip1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//堆中分配对象,利用空参构造创建一个对象</span></span><br><span class="line">    person2* p3 = <span class="keyword">new</span> person2();</span><br><span class="line">    <span class="comment">// new 汇编 ： _nh_malloc ~ 系统函数malloc ;  new = malloc + 构造函数;</span></span><br><span class="line">    <span class="comment">//释放堆中对象</span></span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//C中申请内存</span></span><br><span class="line">    <span class="keyword">int</span>* cp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    person2* mallocP = (person2*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(person2)*<span class="number">10</span>); <span class="comment">//不会调用构造函数与析构函数;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">free</span>(cp);</span><br><span class="line">    <span class="built_in">free</span>(mallocP);</span><br><span class="line">    <span class="comment">//C++申请内存</span></span><br><span class="line">    <span class="keyword">int</span>* cp1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    person2* cpp = <span class="keyword">new</span> person2[<span class="number">10</span>]; <span class="comment">//会调用构造函数与析构函数;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="keyword">delete</span>[] cp1;</span><br><span class="line">    <span class="comment">//delete cpp; //只删除数组首元素；</span></span><br><span class="line">    <span class="keyword">delete</span>[] cpp; <span class="comment">//删除堆中所有对象；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用类型-当前变量的别名 ; 变量地址的引用;    mov xRef , x[address]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前被引用类型指针=%p value=%d \n&quot;</span>,&amp;x,x);</span><br><span class="line">    <span class="keyword">int</span>&amp; xRef = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xRef当前指针=%p value=%d \n&quot;</span>,&amp;xRef,xRef);</span><br><span class="line">    xRef = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xRef当前指针=%p value=%d \n&quot;</span>,&amp;xRef,xRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>** ipp = (<span class="keyword">int</span>**)<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>** ipRef = ipp;</span><br><span class="line">    ipRef = (<span class="keyword">int</span>**)<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ipRef当前指针=%p value=%d \n&quot;</span>,&amp;ipRef,ipRef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针与引用的差异</span></span><br><span class="line">    <span class="keyword">int</span>* xp = &amp;x;</span><br><span class="line">    xp++;  <span class="comment">//int* xp - 减到一颗星的宽度，再自增 ，int为4 , 指针地址自增;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xp++当前指针=%p value=%d \n&quot;</span>,&amp;xp,xp);</span><br><span class="line">    xRef++; <span class="comment">// 引用运算，只运算被引用对象的值;  此时 x= 21;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xRef++当前指针=%p value=%d \n&quot;</span>,&amp;xRef,xRef);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多态 virtual关键字</span></span><br><span class="line"><span class="comment">     * 同一方法，能体现父类与子类的相同方法的不同体现;</span></span><br><span class="line"><span class="comment">     * 间接调用; 动态调用地址; 多态应用</span></span><br><span class="line"><span class="comment">     * 直接调用; 地址是静态的，非多态应用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    myPrint(&amp;p); <span class="comment">//person2父类多态方法被调用了</span></span><br><span class="line">    teacher* t = <span class="keyword">new</span> teacher();</span><br><span class="line">    myPrint(t); <span class="comment">// teacher子类多态方法被调用了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板设计模式 template&lt;class T&gt; 对应java的泛型，编译器把不同地址编译在调用函数中.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * static就是私有全局变量;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;杀了那个写C-和Java的人！&quot;&gt;&lt;a href=&quot;#杀了那个写C-和Java的人！&quot; class=&quot;headerlink&quot; title=&quot;杀了那个写C++和Java的人！&quot;&gt;&lt;/a&gt;杀了那个写C++和Java的人！&lt;/h2&gt;&lt;p&gt;Wirte by 021.   </summary>
      
    
    
    
    <category term="C语言" scheme="http://www.010101.cc/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="http://www.010101.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>epoll之redis自顶向下</title>
    <link href="http://www.010101.cc/2021/11/17/epoll%E4%B9%8Bredis%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/17/epoll%E4%B9%8Bredis%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-17T04:16:39.000Z</published>
    <updated>2021-11-17T06:24:08.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Epoll-之-Redis-自行向下"><a href="#Epoll-之-Redis-自行向下" class="headerlink" title="Epoll 之 Redis 自行向下"></a>Epoll 之 Redis 自行向下</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwi12adr5aj30e808zgm0.jpg" alt="LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL | Byte_Liu&#39;s Blog"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwi0zuuv27j30gt0cbwf3.jpg" alt="Redis系统架构- 知乎"></p><h3 id="IO-进化史"><a href="#IO-进化史" class="headerlink" title="IO 进化史"></a>IO 进化史</h3><h4 id="BIO阻塞IO"><a href="#BIO阻塞IO" class="headerlink" title="BIO阻塞IO"></a>BIO阻塞IO</h4><ul><li><strong>Socket阻塞伪代码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//有1000个客户端读文件描述符的需求</span><br><span class="line">files waitRead = read(fd)*1000;</span><br><span class="line"></span><br><span class="line">1, file = read(waitRead[0]);</span><br><span class="line"></span><br><span class="line">2, if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">//do work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//单线程阻塞， 只能使用多线程处理, 每一条线程处理一个文件描述符的读取系统调用</span><br><span class="line"></span><br><span class="line">new Thread(</span><br><span class="line"></span><br><span class="line">files waitRead = read(fd)*1000;</span><br><span class="line"></span><br><span class="line">1, file = read(waitRead[0]);</span><br><span class="line"></span><br><span class="line">2, if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">//do work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">).start();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="NIO同步非阻塞"><a href="#NIO同步非阻塞" class="headerlink" title="NIO同步非阻塞"></a>NIO同步非阻塞</h4><ul><li>同步非阻塞伪代码模拟**</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//有1000个读文件描述符的需求</span><br><span class="line">read(int fd) * 1000;</span><br><span class="line"></span><br><span class="line">for(;;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(1000 * fd)        // 用户空间 系统调用轮询1000次， </span><br><span class="line">&#123;</span><br><span class="line">file = read(fd1~fd1000);   //轮询读取每一个fd文件描述符，不管数据有没有准备好</span><br><span class="line"></span><br><span class="line">if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">// do work....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Select（多路复用）"><a href="#Select（多路复用）" class="headerlink" title="Select（多路复用）"></a>Select（多路复用）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//有1000个读文件描述符的需求</span><br><span class="line">read(int fd) * 1000;</span><br><span class="line"></span><br><span class="line">//select 系统调用函数， 一次性传输多个文件描述符传输给内核，返回准备好的文件描述;</span><br><span class="line">select(fd*1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file fds = select(fd*1000);    // 系统调用，内核返回准备好的文件的描述符</span><br><span class="line">for( 0;fds; )         // 用户空间遍历内核返回的全部文件描述符，</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(fd.readAble)              //检测文件可读状态</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">file = read(fd);        </span><br><span class="line">if(file != null)</span><br><span class="line">&#123;</span><br><span class="line">// do work....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul><li><p><strong>模拟内核 和 用户 共享空间逻辑</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模拟原始内存空间：</span><br><span class="line"></span><br><span class="line">0xffffffff ------------用户空间-------------0x80000000 ------------内核空间------------ 0x00000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模拟共享空间：   //用户与内核 映射 同一块物理空间</span><br><span class="line"></span><br><span class="line">0xffffffff ---------用户空间---------[0x80000000 ---共享空间--- 0x700000000 ]------内核空间----- 0x00000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 共享空间容器</span><br><span class="line">1，红黑树 - 等待读取的文件描述符 ,btree;</span><br><span class="line">2，链表 - 准备好的文件描述符  , readyLinkList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">btree.add(epoll.creat(fd));   // 将待读取的文件描述符 放入共享空间的红黑树.</span><br><span class="line"></span><br><span class="line">file = read(readyLinkList(fd));    //读取 共享空间 链表容器 已准备好的文件描述符；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="redis-单进程-单线程-为什么快？"><a href="#redis-单进程-单线程-为什么快？" class="headerlink" title="redis 单进程 单线程 为什么快？"></a>redis 单进程 单线程 为什么快？</h4><ul><li><strong>如何保证顺序性？</strong><ul><li><strong>每个连接</strong></li><li></li></ul></li></ul><ul><li><strong>sendfile 零拷贝</strong></li><li></li></ul><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Epoll-之-Redis-自行向下&quot;&gt;&lt;a href=&quot;#Epoll-之-Redis-自行向下&quot; class=&quot;headerlink&quot; title=&quot;Epoll 之 Redis 自行向下&quot;&gt;&lt;/a&gt;Epoll 之 Redis 自行向下&lt;/h2&gt;&lt;p&gt;Wirte </summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="Redis" scheme="http://www.010101.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>WIN32之保护模式</title>
    <link href="http://www.010101.cc/2021/11/15/WIN32%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.010101.cc/2021/11/15/WIN32%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-15T11:42:37.000Z</published>
    <updated>2021-11-16T03:40:44.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java编译器浅析"><a href="#Java编译器浅析" class="headerlink" title="Java编译器浅析"></a>Java编译器浅析</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><h3 id="段-寄存器"><a href="#段-寄存器" class="headerlink" title="段 寄存器"></a>段 寄存器</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwguaroxt1j30co0daaao.jpg" alt="汇编-8086内部寄存器+对段寄存器使用的约定- 二十一点关机- 博客园"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwg2x5gwpjj30ww0hkab1.jpg" alt="image-20211115195319374"></p><ul><li>Selector</li><li>Attribute</li><li>Base</li><li>Limit</li></ul><h4 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h4><h4 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h4><h4 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h4><h4 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h4><h4 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h4><h4 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h4><h4 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h4><h4 id="TR"><a href="#TR" class="headerlink" title="TR"></a>TR</h4><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java编译器浅析&quot;&gt;&lt;a href=&quot;#Java编译器浅析&quot; class=&quot;headerlink&quot; title=&quot;Java编译器浅析&quot;&gt;&lt;/a&gt;Java编译器浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messe</summary>
      
    
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="操作系统内核" scheme="http://www.010101.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编基础</title>
    <link href="http://www.010101.cc/2021/11/14/%E6%B1%87%E7%BC%96%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.010101.cc/2021/11/14/%E6%B1%87%E7%BC%96%E4%B9%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-11-14T02:25:43.000Z</published>
    <updated>2021-11-15T09:27:12.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><ul><li> <strong>提供三种容器寄存器 ： 8 ， 16 ， 32.</strong></li></ul><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><ul><li><strong>提供4中容器寄存器 ：     8 ，16 ，32 ，64.</strong></li></ul><h4 id="通用寄存器32位"><a href="#通用寄存器32位" class="headerlink" title="通用寄存器32位"></a>通用寄存器32位</h4><ul><li><p><strong>用户自定义使用寄存器</strong></p></li><li><p><strong>数据宽度为32位 多余的丢弃</strong></p><ul><li><p>EAX </p><ul><li><strong>返回值容器</strong></li></ul></li><li><p>ECX</p><ul><li><strong>REP执行计数器</strong></li></ul></li><li><p>EDX</p></li><li><p>EBX</p></li><li><p><strong>ESP</strong></p><ul><li><strong>栈指针寄存器,栈内存起始位置到ESP指针位置为已使用内存</strong></li></ul></li><li><p><strong>EBP</strong></p><ul><li><strong>栈底</strong></li></ul></li><li><p><strong>ESI</strong></p><ul><li><strong>movs 使用</strong></li></ul></li><li><p><strong>EDI</strong></p><ul><li><strong>movs 使用</strong></li></ul></li><li><p><strong>EFL</strong></p><ul><li>内存地址高低方向位</li></ul></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwei5fapk8j30v70syads.jpg" alt="image-20211114110903790"></p><h4 id="非通用寄存器"><a href="#非通用寄存器" class="headerlink" title="非通用寄存器"></a>非通用寄存器</h4><h4 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h4><ul><li><strong>cpu下次执行时会找EIP存的值</strong></li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li><p><strong>mov</strong></p><ul><li><strong>操作数数据宽度需要相同</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov eax,1 ;  将1存进eax寄存器。</span><br><span class="line">mov ecx,1 ;  将1存进ecx寄存器。</span><br><span class="line">mov eax,ecx ;  将ecx存进eax寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> x64模拟器：</span><br><span class="line">%rax 作为函数返回值使用。</span><br><span class="line">%rsp 栈指针寄存器，指向栈顶</span><br><span class="line">%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。</span><br><span class="line">%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</span><br><span class="line">%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>add 加法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add eax,ecx; 将ecx 与 eax 相加 存进eax寄存器;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>sub 减法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub eax,ecx; 将ecx 与 eax 相减 存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p><strong>AND 与运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND eax,ecx; 将ecx 与 eax 与运算 存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p><strong>or 或运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">or eax,ecx; 将ecx 与 eax 与或算 存进eax寄存器;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>xor 异或运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor eax,ecx; 将ecx 与 eax 与异或算 存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p><strong>NOT 非运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not eax, 将eax取反 ,存进eax寄存器;</span><br></pre></td></tr></table></figure></li><li><p>**movs 从内存到内存 **</p><ul><li><strong>每复制一次 内存地址自增长当前数据宽度位</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Movs byte ptr es:[edi] , byte ptr ds:[esi]</span><br><span class="line"></span><br><span class="line">Movs byte ptr es:[0x00000000] , byte ptr ds:[0x00000001]</span><br><span class="line"></span><br><span class="line">ELF</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>stos 将AI/AX/EAX的值存储到[EDI]指定的内存单元</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">STOS WORD PTR ES:[edi]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>REP 重复执行 ，依赖ecx 寄存器的计数器 10进制，每次执行ecx值减一</strong></li></ul><p>​    </p><ul><li><p><strong>JMP 寄存器/立即数/内存</strong></p><ul><li><strong>修改EIP的值</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jmp dword ptr ds:[eax];  将eax的地址值，赋给EIP,cpu下次执行的将是eax里面的指令.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>CALL</strong></p><ul><li><p><strong>修改EIP值，再将ESP-4,并将栈顶值压入在ESP-4的地址中</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwewjs1s1uj31400u0q70.jpg" alt="Untitled 1"></p></li></ul></li><li><p><strong>RET</strong></p><ul><li><p><strong>1，将当前栈顶的值放进EIP中</strong></p></li><li><p><strong>2，将当前ESP指针值+4</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwewjw62v7j31400u0tcq.jpg" alt="Untitled 2"></p></li></ul></li></ul><h4 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h4><ul><li><p><strong>0x0000000</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据宽度：32位.</span><br></pre></td></tr></table></figure></li><li><p><strong>内存基本单元= 1byte = 8bit</strong></p></li></ul><h3 id="往内存中写数据"><a href="#往内存中写数据" class="headerlink" title="往内存中写数据"></a>往内存中写数据</h3><ul><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov byte ptr ds:[0x00000000] ,1</strong></p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov word ptr ds:[0x00000000] ,1 ; 单字宽度</strong>  </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov Dword ptr ds:[0x00000000] ,1; 双字宽度</strong> </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov Dword ptr ds:[0x00000000] ,eax; 将寄存器写入内存</strong> </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov eax, Dword ptr ds:[0x00000000] ; 将内存写入寄存器</strong> </p></li><li><p><strong>mov 数据宽度 ptr ds:[内存地址] ,值 , mov eax, Dword ptr ds:[ecx+4] ; 将ecx内存地址+4的位置值写入寄存器</strong> </p></li></ul><h3 id="存储模式"><a href="#存储模式" class="headerlink" title="存储模式"></a>存储模式</h3><ul><li><p><strong>小端模式 x86</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据低位在低位，数据高位在高位.</span><br><span class="line"></span><br><span class="line">mov word ptr ds:[0x00000000],0x1a2c ,  0x00000000[1a], 0x00000001[2c]. </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>大端模式 arm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据低位在高位，数据高位在低位.</span><br><span class="line"></span><br><span class="line">mov word ptr ds:[0x00000000],0x1a2c ,  0x00000000[2c], 0x00000001[1a]. </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><ul><li><p><strong>PUSH压栈</strong></p><ul><li><strong>push指令将数据压入栈中，并移动栈针ESP ,（eps - 数据宽度）</strong></li></ul></li><li><p><strong>pop弹栈</strong></p><ul><li><p><strong>pop指令将数据弹出栈外，并移动栈针ESP ,（eps + 数据宽度)</strong></p></li><li><p><strong>pop eax; 将栈顶的值存入eax中，esp指针 + eax值的数据宽度</strong></p></li></ul></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><strong>JMP调用函数（通常不用）</strong></li></ul><h4 id="CALL-调用函数"><a href="#CALL-调用函数" class="headerlink" title="CALL()调用函数**"></a>CALL()调用函数**</h4><ul><li><strong>基本函数调用流程</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">求 10 + 7 = ？</span><br><span class="line"></span><br><span class="line">10 = 0000 1010 = 0x0a;  7 = 0000 0111 = 0x07;</span><br><span class="line"></span><br><span class="line">模拟入参：</span><br><span class="line"></span><br><span class="line">初始地址 esp : 0x00000128</span><br><span class="line">        ecx : 0x0000012c</span><br><span class="line">        edx : 0x00000131</span><br><span class="line">0x00000135  : null;      </span><br><span class="line">0x00000139   mov ecx 0x0a;</span><br><span class="line">0x0000013D   mov edx ox07;</span><br><span class="line">   //加</span><br><span class="line">0x00000142   add ecx ,edx;</span><br><span class="line"> //移动返回值</span><br><span class="line">0x00000146    mov eax, ecx;</span><br><span class="line"></span><br><span class="line">0x0000014a    ret;</span><br><span class="line"></span><br><span class="line">执行调用 call 0x00000139;  首先将 jmp eip ,esp; 然后 mov esp-4, esp; 再执行0x00000139位置;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数执行 139 13d 142 系列函数之后到达146 ret返回点，ret首先 jmp eip ,esp; 然后 mov esp+4 ,esp; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>堆栈函数与平衡</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">求 1 + 2 + 3 + 4 = ？</span><br><span class="line"></span><br><span class="line">0x0000 0117 ; push 4;</span><br><span class="line">0x0000 011b ; push 3;</span><br><span class="line">0x0000 0120 ; push 2;</span><br><span class="line">0x0000 0124 ; push 1;</span><br><span class="line">0x0000 0128 ; add eax, dword ptr ds:[esp+10], 由于压入4个立即数，堆栈地址增加了16，所以将第一个数与eax相加.</span><br><span class="line">............  add eax, dword ptr ds:[esp+0c],</span><br><span class="line">............  add eax, dword ptr ds:[esp+08],</span><br><span class="line">............  add eax, dword ptr ds:[esp+04],</span><br><span class="line">............  ret;</span><br><span class="line"></span><br><span class="line">call 0x0000 0117;</span><br><span class="line"></span><br><span class="line">============================================================================================</span><br><span class="line"></span><br><span class="line">堆栈平衡： </span><br><span class="line">在调用函数中 应该保证函数调用前后，堆栈的一致性不发生变化;</span><br><span class="line">在ret之前 应该保证堆栈指针esp 是call函数压入的esp地址;</span><br><span class="line"></span><br><span class="line">0x0000 0117 ; add eax, dword ptr ds:[0x0000 011b]</span><br><span class="line">0x0000 011b ; push 3;      ------ 此时esp已经发生变化 返回时指向esp的地址和堆栈已经发生变化，再次执行就会出错</span><br><span class="line">0x0000 0120 ; push 2;</span><br><span class="line">0x0000 0124 ; push 1;     </span><br><span class="line">0x0000 0128 ; ret;     ------ ret指令 ：将esp值放到eip，然后将esp的值+4;</span><br><span class="line"></span><br><span class="line">怎么平衡？</span><br><span class="line"></span><br><span class="line">外平栈</span><br><span class="line">call 0x0000 0117; add esp , 0x0c; 将esp复位;</span><br><span class="line"></span><br><span class="line">内平栈</span><br><span class="line">0x0000 0128 ; ret 0x0c;  在函数内部将esp复位;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ESP栈顶寻址"><a href="#ESP栈顶寻址" class="headerlink" title="ESP栈顶寻址"></a>ESP栈顶寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">求 1 + 2 + 3 + 4 = ？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//调用函数 </span><br><span class="line">0x0000 0113 : call 0x0000 0117; 压栈后栈顶指针esp;</span><br><span class="line"></span><br><span class="line">//执行压栈</span><br><span class="line">0x0000 0117 ; push 4;    </span><br><span class="line">0x0000 011b ; push 3;</span><br><span class="line">0x0000 0120 ; push 2;</span><br><span class="line">0x0000 0124 ; push 1;</span><br><span class="line"></span><br><span class="line">//执行相加</span><br><span class="line">0x0000 0128 : add eax , dword ptr ss:[esp+14] ; 执行加第一个数 1；</span><br><span class="line">0x0000 012c : add eax , dword ptr ss:[esp+10] ; 执行加第2个数 2；</span><br><span class="line">0x0000 0130 : add eax , dword ptr ss:[esp+c] ; 执行加第3个数 3；</span><br><span class="line">0x0000 0134 : add eax , dword ptr ss:[esp+8] ; 执行加第4个数 4；</span><br><span class="line">// 平栈  弹出/修正esp位置</span><br><span class="line">0x0000 0130 : pop 1 ;</span><br><span class="line"></span><br><span class="line">pop 1 ~ 4;</span><br><span class="line"></span><br><span class="line">0x0000 0134 : ret;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="EBP栈底寻址"><a href="#EBP栈底寻址" class="headerlink" title="EBP栈底寻址"></a>EBP栈底寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">求 1+2 = ？</span><br><span class="line"></span><br><span class="line">整体步骤，</span><br><span class="line">1： 将参数压栈</span><br><span class="line">2： 调用函数, 2.1 备份esp到ebp, 2.2 开辟新空间， 2.3 复位esp, 2.4弹出备份ebp; 2.5平栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始堆栈：</span><br><span class="line">esp : 0x0000 0120;</span><br><span class="line">ebp : 0x0000 011c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1. 参数压栈</span><br><span class="line">push 2;  esp : 0x0000 0118;   eip :  0x0000 0001;</span><br><span class="line">push 1;  esp : 0x0000 011c;    eip : 0x0000 0002;</span><br><span class="line"></span><br><span class="line">//2. 调用函数</span><br><span class="line">call  0x0000 0005;    esp : 0x0000 0114;   （ eip : 0x0000 0004; 指向下一条指令)</span><br><span class="line">// 下一条的指令;</span><br><span class="line">mov eax,1;eip : 0x0000 0004;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==============================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数：</span><br><span class="line">1，备份栈底ebp</span><br><span class="line">push ebp;  esp : 0x0000 0110;     eip : 0x0000 0005;</span><br><span class="line"></span><br><span class="line">2，记录起始ebp的值</span><br><span class="line">mov ebp,esp; esp : 0x0000 0110; ebp : 0x0000 0110;      eip : 0x0000 0006;</span><br><span class="line"></span><br><span class="line">3，开辟新空间 开辟16个字节</span><br><span class="line">sub esp,10;   esp : 0x0000 0100;                     eip : 0x0000 0007;</span><br><span class="line"></span><br><span class="line">4,执行加操作</span><br><span class="line">add eax ,dword ptr ss:[ebp+c]                         eip : 0x0000 0008;</span><br><span class="line">add eax ,dword ptr ss:[ebp+8] </span><br><span class="line"></span><br><span class="line">5,复位堆栈</span><br><span class="line">mov esp,ebp;     esp : 0x0000 0110; </span><br><span class="line"></span><br><span class="line">pop ebp;   esp : 0x0000 0114; </span><br><span class="line"></span><br><span class="line">ret c;      esp : 0x0000 0120;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JCC指令集"><a href="#JCC指令集" class="headerlink" title="JCC指令集"></a>JCC指令集</h3><ul><li><strong>JCC指令根据标志寄存器值的标志位来修改EIP的，从而实现执行跳转</strong></li></ul><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwfyghrzp2j30jf09djrt.jpg" alt="标志寄存器（EFLAGS） - 程序员大本营"></p><ul><li><strong>运算相关指令都会影响标志寄存器</strong></li></ul><table><thead><tr><th>JCC指令</th><th>中文含义</th><th>英文原意</th><th>检查符号位</th><th>典型C应用</th></tr></thead><tbody><tr><td><code>JZ/JE</code></td><td>若为0则跳转；若相等则跳转</td><td>jump if zero;jump if equal</td><td><code>ZF=1</code></td><td><code>if (i == j);if (i == 0);</code></td></tr><tr><td><code>JNZ/JNE</code></td><td>若不为0则跳转；若不相等则跳转</td><td>jump if not zero;jump if not equal</td><td><code>ZF=0</code></td><td><code>if (i != j);if (i != 0);</code></td></tr><tr><td><code>JS</code></td><td>若为负则跳转</td><td>jump if sign</td><td><code>SF=1</code></td><td><code>if (i &lt; 0);</code></td></tr><tr><td><code>JNS</code></td><td>若为正则跳转</td><td>jump if not sign</td><td><code>SF=0</code></td><td><code>if (i &gt; 0);</code></td></tr><tr><td><code>JP/JPE</code></td><td>若1出现次数为偶数则跳转</td><td>jump if Parity (Even)</td><td><code>PF=1</code></td><td><code>(null)</code></td></tr><tr><td><code>JNP/JPO</code></td><td>若1出现次数为奇数则跳转</td><td>jump if not parity (odd)</td><td><code>PF=0</code></td><td><code>(null)</code></td></tr><tr><td><code>JO</code></td><td>若溢出则跳转</td><td>jump if overflow</td><td><code>OF=1</code></td><td><code>(null)</code></td></tr><tr><td><code>JNO</code></td><td>若无溢出则跳转</td><td>jump if not overflow</td><td><code>OF=0</code></td><td><code>(null)</code></td></tr><tr><td><code>JC/JB/JNAE</code></td><td>若进位则跳转；若低于则跳转；若不高于等于则跳转</td><td>jump if carry;jump if below;jump if not above equal</td><td><code>CF=1</code></td><td><code>if (i &lt; j);</code></td></tr><tr><td><code>JNC/JNB/JAE</code></td><td>若无进位则跳转；若不低于则跳转；若高于等于则跳转；</td><td>jump if not carry;jump if not below;jump if above equal</td><td><code>CF=0</code></td><td><code>if (i &gt;= j);</code></td></tr><tr><td><code>JBE/JNA</code></td><td>若低于等于则跳转；若不高于则跳转</td><td>jump if below equal;jump if not above</td><td><code>ZF=1或CF=1</code></td><td><code>if (i &lt;= j);</code></td></tr><tr><td><code>JNBE/JA</code></td><td>若不低于等于则跳转；若高于则跳转</td><td>jump if not below equal;jump if above</td><td><code>ZF=0或CF=0</code></td><td><code>if (i &gt; j);</code></td></tr><tr><td><code>JL/JNGE</code></td><td>若小于则跳转；若不大于等于则跳转</td><td>jump if less;jump if not greater equal jump</td><td><code>SF != OF</code></td><td><code>if (si &lt; sj);</code></td></tr><tr><td><code>JNL/JGE</code></td><td>若不小于则跳转；若大于等于则跳转；</td><td>jump if not less;jump if greater equal</td><td><code>SF = OF</code></td><td><code>if (si &gt;= sj);</code></td></tr><tr><td><code>JLE/JNG</code></td><td>若小于等于则跳转；若不大于则跳转</td><td>jump if less equal;jump if not greater</td><td><code>ZF != OF 或 ZF=1</code></td><td><code>if (si &lt;= sj);</code></td></tr><tr><td><code>JNLE/JG</code></td><td>若不小于等于则跳转；若大于则跳转</td><td>jump if not less equal;jump if greater</td><td><code>SF=0F 且 ZF=0</code></td><td><code>if(si&gt;sj)</code></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;汇编基础&quot;&gt;&lt;a href=&quot;#汇编基础&quot; class=&quot;headerlink&quot; title=&quot;汇编基础&quot;&gt;&lt;/a&gt;汇编基础&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messed up ! : )&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="Assembly" scheme="http://www.010101.cc/categories/Assembly/"/>
    
    
    <category term="汇编" scheme="http://www.010101.cc/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础之内存分布</title>
    <link href="http://www.010101.cc/2021/11/14/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <id>http://www.010101.cc/2021/11/14/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</id>
    <published>2021-11-14T02:25:43.000Z</published>
    <updated>2021-11-18T16:46:36.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言之内存分布简单分析"><a href="#C语言之内存分布简单分析" class="headerlink" title="C语言之内存分布简单分析"></a>C语言之内存分布简单分析</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="C源码-脑图模拟汇编Win32"><a href="#C源码-脑图模拟汇编Win32" class="headerlink" title="C源码 | 脑图模拟汇编Win32"></a>C源码 | 脑图模拟汇编Win32</h3><ul><li><strong>win32汇编设计上还是有很多不合理，造成了很多资源浪费，比如断点C的填充，在AT&amp;T的汇编上得到了改良</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//减函数</span><br><span class="line">int sub(int c)&#123;</span><br><span class="line">    return c-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 加函数</span><br><span class="line">int add(int a , int b)&#123;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    //函数嵌入</span><br><span class="line">    c = sub(c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//main函数</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    // insert code here...</span><br><span class="line">    int a = 20;</span><br><span class="line">    int b = 10;</span><br><span class="line">    int c = add(a,b);</span><br><span class="line">    //int a = 7;</span><br><span class="line">    //putchar(a);</span><br><span class="line">    //printf(&quot;Hello, World! %d \n&quot;,c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">================================模拟汇编堆栈====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始堆栈：</span><br><span class="line"></span><br><span class="line">esp   0x0000 02ff;</span><br><span class="line">ebp   0x0000 0208;</span><br><span class="line">eip   0x0005 0001;</span><br><span class="line"></span><br><span class="line">//预留三个参数寄存器</span><br><span class="line"></span><br><span class="line">esi ....</span><br><span class="line">edi ....</span><br><span class="line">ebx ....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">============================ main start =====================</span><br><span class="line"></span><br><span class="line">// 1. 提栈</span><br><span class="line">0x0005 0001 ------------   push ebp; |  esp  0x0000 01fb; ebp   0x0000 0208[0x0000 0208]; </span><br><span class="line">0x0005 0002 ------------   mov ebp, esp; |  esp  0x0000 01fb; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line">0x0005 0003 ------------   sub esp, 0x20; |  esp  0x0000 01db; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line"></span><br><span class="line">// 2. 压栈 - 编译环境不一样，编译器优化汇编 可能有一些差异，整体逻辑是不变的, </span><br><span class="line">//   有的环境是直接取寄存器的值，有的直接压值，这里选择压值, </span><br><span class="line">//   win32 压在缓冲区外，AT&amp;T 压在缓冲区内: push 0x14 , ebp - 0x04;</span><br><span class="line">0x0005 0004 ------------   push 0x14; |  esp  0x0000 01d7; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line">0x0005 0005 ------------   push 0x0a; |  esp  0x0000 01d3; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line"></span><br><span class="line">// 3. 函数调用</span><br><span class="line">0x0005 0006 ------------   call 0x0005 000b; |  esp  0x0000 01cf[0x0005 0007]; ebp   0x0000 01fb[0x0000 01fb]; </span><br><span class="line">// 此时 eax = 29; esp  esp  0x0000 01cf; ebp   0x0000 01fb[0x0000 0208]; eax = 29;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 4.恢复堆栈</span><br><span class="line">0x0005 0007 ------------   mov esp, ebp; |  esp  0x0000 01fb; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0008 ------------   pop ebp; |  esp  0x0000 01ff; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line"></span><br><span class="line">//由于没有选择寄存器传值，压入的两个参数此时不用处理，平栈的方式很多种，这里似乎可以直接平.</span><br><span class="line">//0x0005 0009 ------------   add esp,0x20; |  esp  0x0000 01fb; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line"></span><br><span class="line">0x0005 0009 ------------   ret; |  esp  0x0000 01ff; ebp   0x0000 0208; </span><br><span class="line"></span><br><span class="line">=================================== main end ===============================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 加函数</span><br><span class="line">============================ add start ===================== esp  0x0000 01cf</span><br><span class="line"></span><br><span class="line">0x0005 000b ------------   push ebp - 0x0c ,eax ; |  esp  esp  0x0000 01cb; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 000b ------------   mov ebp, esp ;|  esp  esp  0x0000 01cb; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line"></span><br><span class="line">// 加</span><br><span class="line">0x0005 000c ------------   mov eax , ebp - 0x08; |    esp  0x0000 01cb; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line">0x0005 000d ------------   add eax , ebp - 0x04; |    esp  0x0000 01cb; eax = 30;</span><br><span class="line"></span><br><span class="line">//压参数 </span><br><span class="line">0x0005 000e ------------   push ebp - 0x0c , eax; |  esp  0x0000 01c7; eax = 30;</span><br><span class="line">0x0005 000f ----   call 0x0005 0013 |  esp  esp  0x0000 01c3[0x0005 0000]; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 恢复堆栈</span><br><span class="line">0x0005 0000 ------------   pop ebp ; |  esp  esp  0x0000 01c7; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0011 ------------   add esp,0x08 ; |  esp  0x0000 01cf; ebp   0x0000 01cb[0x0000 01cb]; </span><br><span class="line">0x0005 0012 ------------   ret ; |  esp  0x0000 01f9; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line"></span><br><span class="line">=================================add end====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 减函数</span><br><span class="line">============================ sub start =====================</span><br><span class="line">// win32汇编并没有使用寄存器传参，此处eax应该使用寄存器，或者EBP寻址;</span><br><span class="line">0x0005 0013 ------------   sub ebp - 0x0c , 0x01;  |  esp  0x0000 01c3; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0014 ------------   mov eax , ebp - 0x0c;   |  esp  0x0000 01c3; ebp   0x0000 01fb[0x0000 0208]; </span><br><span class="line">0x0005 0015 ------------   ret;   |  esp  0x0000 01c3; ebp   0x0000 01fb[0x0000 0208]; eax = 29;</span><br><span class="line"></span><br><span class="line">============================ sub end =====================</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言之内存分布简单分析&quot;&gt;&lt;a href=&quot;#C语言之内存分布简单分析&quot; class=&quot;headerlink&quot; title=&quot;C语言之内存分布简单分析&quot;&gt;&lt;/a&gt;C语言之内存分布简单分析&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a messag</summary>
      
    
    
    
    <category term="C语言" scheme="http://www.010101.cc/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://www.010101.cc/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>内存管理之页</title>
    <link href="http://www.010101.cc/2021/11/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.010101.cc/2021/11/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-14T02:25:43.000Z</published>
    <updated>2021-11-26T11:16:46.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="101012-分页"><a href="#101012-分页" class="headerlink" title="101012 分页"></a>101012 分页</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h3><p><strong>mov eax , dword ds:[0x00000124]</strong></p><ul><li><strong>其中0x00000124是有效地址</strong></li><li><strong>ds.base(段寄存器) + 0x0000124 是线性地址。</strong></li></ul><h4 id="101012-地址拆分"><a href="#101012-地址拆分" class="headerlink" title="101012 地址拆分"></a>101012 地址拆分</h4><ul><li>**32位地址示例 0x00000124 **</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000124 =</span><br><span class="line"></span><br><span class="line">将 32位 拆成 10 - 10 - 12 ;</span><br><span class="line"></span><br><span class="line">0000 0000 00 , 10 ;</span><br><span class="line"></span><br><span class="line">00 0000 0000 , 10 ;</span><br><span class="line"></span><br><span class="line">0001 0010 0100 , 12 ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CR3物理地址寄存器"><a href="#CR3物理地址寄存器" class="headerlink" title="CR3物理地址寄存器"></a>CR3物理地址寄存器</h4><ul><li><strong>CR3寄存器存储了物理地址</strong></li></ul><ul><li><p><strong>CR3指向了一个4KB页</strong></p><ul><li><p><strong>第一级分页（页目录表PDT）（4kb）（第一个10）</strong></p><ul><li><p><strong>存储的地址，</strong></p></li><li><p><strong>第一级分页存储了1024个第二级分页的地址</strong></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第一级分页数据结构：</span><br><span class="line"></span><br><span class="line">每个PDE地址数据宽度：4个字节；</span><br><span class="line"></span><br><span class="line">4096/4 = 1024； </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>0地址不能读写是因为没有挂物理页，挂了之后可以读写</strong></li></ul><ul><li><p><strong>第二级分页(页表PTT)(第二个10)</strong></p><ul><li><strong>数据为：PTE</strong></li><li><strong>多个PTE可以指向同一个物理页</strong></li><li><strong>一个PTE只能指向一个物理页，不能指向多个物理页</strong></li><li><strong>一个可以不指向物理页</strong></li></ul></li><li><p><strong>第三级分页（物理页）(第三个12)</strong></p><ul><li><p><strong>一个物理页的大小是4kb=4096=2的12次方，也就是需要12个bit位才能表示4kb中所有的地址.</strong></p></li><li><p><strong>指向物理页地址</strong></p></li></ul></li></ul></li></ul><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><ul><li><strong>CPU 将线性地址转换的物理地址</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwsl4xe287j315p0ioq4d.jpg" alt="截屏2021-11-26 下午3.30.04"></p><ul><li><p><strong>R/W可读可写位</strong></p></li><li><p><strong>P数据有效位</strong></p></li><li><p><strong>U/S 权限位，0 - 特权用户，1 - 普通用户</strong></p></li><li><p>**PS位对PDE有用，PageSize的意思，当ps=1的时候是大页，低22位直接指向物理页. **</p></li><li><p><strong>A位，是否访问位</strong></p></li><li><p><strong>D位，duty, 是否被写过，0 - 没有写过，1 - 写过</strong></p></li></ul><h4 id="页目录基址（0xc03000000）"><a href="#页目录基址（0xc03000000）" class="headerlink" title="页目录基址（0xc03000000）"></a>页目录基址（0xc03000000）</h4><ul><li><p><strong>PDT页目录表的基址</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwsmmnfxkcj31400u078l.jpg" alt="Untitled 4"></p></li></ul><h4 id="访问进程内存公式"><a href="#访问进程内存公式" class="headerlink" title="访问进程内存公式"></a>访问进程内存公式</h4><ul><li><strong>10-10-12 ； PDI(页目录项) : 10 , PTI(页表项) : 10 , 12 物理页</strong></li></ul><ul><li><strong>访问页目录的公式</strong><ul><li><strong>0xc0300000 + PDI*4</strong></li></ul></li></ul><ul><li><strong>访问页表的公式</strong><ul><li><strong>0xc0000000 + PDI * 4096 + PTI * 4</strong></li></ul></li></ul><h2 id="2-9-9-12-分页（PAE-物理地址拓展分页）"><a href="#2-9-9-12-分页（PAE-物理地址拓展分页）" class="headerlink" title="2 - 9 - 9 - 12 分页（PAE 物理地址拓展分页）"></a>2 - 9 - 9 - 12 分页（PAE 物理地址拓展分页）</h2><ul><li><strong>2 : PDPTE 页目录指针表(page directory point table entry)</strong><ul><li><strong>数据宽度2个bit, 最多拥有4个元素</strong></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwsr5lo6asj31500jvwg9.jpg" alt="未命名"></p><ul><li>**9 : PDE **</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwsr9y1fvmj31680j8juc.jpg" alt="截屏2021-11-26 下午7.02.24"></p><ul><li><strong>9 : PTE</strong></li><li><strong>12 ： 物理页</strong></li></ul><ul><li><strong>当x=1时，此数据为不可执行数据.</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwsrijw71bj314p0j0jul.jpg" alt="截屏2021-11-26 下午7.10.48"></p><h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;101012-分页&quot;&gt;&lt;a href=&quot;#101012-分页&quot; class=&quot;headerlink&quot; title=&quot;101012 分页&quot;&gt;&lt;/a&gt;101012 分页&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messe</summary>
      
    
    
    
    <category term="内存管理" scheme="http://www.010101.cc/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="页" scheme="http://www.010101.cc/tags/%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>汇编之趣味计算机</title>
    <link href="http://www.010101.cc/2021/11/13/%E6%B1%87%E7%BC%96%E8%B6%A3%E5%91%B3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>http://www.010101.cc/2021/11/13/%E6%B1%87%E7%BC%96%E8%B6%A3%E5%91%B3%E8%AE%A1%E7%AE%97%E6%9C%BA/</id>
    <published>2021-11-13T07:56:26.000Z</published>
    <updated>2021-11-15T07:55:07.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="汇编之有趣的计算机"><a href="#汇编之有趣的计算机" class="headerlink" title="汇编之有趣的计算机"></a>汇编之有趣的计算机</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdkgbq4kgj30jg0cv3zx.jpg" alt="汇编语言入门教程- 阮一峰的网络日志"></p><h3 id="汇编的加减乘除："><a href="#汇编的加减乘除：" class="headerlink" title="汇编的加减乘除："></a>汇编的加减乘除：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  汇编语言                 编译器                    机器语言   </span><br><span class="line"></span><br><span class="line">加      INC EAX                  ---&gt;                  0100 0000  </span><br><span class="line"></span><br><span class="line">减      DEC EAX                    ---&gt;                  0100 1000</span><br><span class="line"></span><br><span class="line">乘      MUL EAX         ---&gt;                  1111 0111 1110 0000</span><br><span class="line"></span><br><span class="line">除      DIV EAX                    ---&gt;                  1111 0111 1111 0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进制换算"><a href="#进制换算" class="headerlink" title="进制换算"></a>进制换算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 </span><br><span class="line"></span><br><span class="line">0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15</span><br><span class="line"></span><br><span class="line">0    1    2    3    4    5    6    7    8    9    A    B    C    D     E   F</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">hex : 6d  7f 008c e3 246</span><br><span class="line"></span><br><span class="line">hex to bin</span><br><span class="line">6 + d = 0110 1101, 7 + f = 0111 1111, 8 + c =0000 0000 1000 1100, e + 3 = 1110 0011, 2 + 4 + 6 = 0010 0100 0110.</span><br></pre></td></tr></table></figure><h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><ul><li><strong>超过数据宽度将被丢弃</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">位 bit: 0，最大值 1.</span><br><span class="line"></span><br><span class="line">字节 byte: 0000 0000 , 最大值 1111 1111 ， 0 - ff. 0xff.</span><br><span class="line"></span><br><span class="line">字word: 0000 0000 0000 0000 ,最大值 1111 1111 1111 1111 , 0 - ffff, 0xffff.</span><br><span class="line"></span><br><span class="line">双字doubleWord: 0000 0000 0000 0000 0000 0000 0000 0000 0000 , 最大值 0xffffffff.</span><br><span class="line"></span><br><span class="line">数据宽度测试：</span><br><span class="line">char a = 0x1ff, 存入数据是ff 舍弃了1，因为宽度不够.</span><br><span class="line"></span><br><span class="line">Xcode 进入debug 模式， 在右边控制台或者内存值, 输出：</span><br><span class="line"></span><br><span class="line">x/1xb 0x7ffeefbff3df ， 取1个字节的值，用16进制表示，表示单字节</span><br><span class="line">0x7ffeefbff3df: 0xff  只存了ff。</span><br><span class="line"></span><br><span class="line">x/nfu &lt;addr&gt; </span><br><span class="line"></span><br><span class="line">n，表示要显示的内存单元的个数</span><br><span class="line">f，表示显示方式, 可取如下值：</span><br><span class="line">x 按十六进制格式显示变量</span><br><span class="line">d 按十进制格式显示变量</span><br><span class="line">u 按十进制格式显示无符号整型</span><br><span class="line">o 按八进制格式显示变量</span><br><span class="line">t 按二进制格式显示变量</span><br><span class="line">a 按十六进制格式显示变量</span><br><span class="line">i 指令地址格式</span><br><span class="line">c 按字符格式显示变量</span><br><span class="line">f 按浮点数格式显示变量</span><br><span class="line"></span><br><span class="line">u，表示一个地址单元的长度：</span><br><span class="line">b 表示单字节</span><br><span class="line">h 表示双字节</span><br><span class="line">w 表示四字节</span><br><span class="line">g 表示八字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/16xb self</span><br><span class="line">会显示 self 指针地址内容，16 个字节，16 进制。</span><br><span class="line">x/8cb 0x7fc359a03040</span><br><span class="line">会显示地址 0x7fc359a03040 地址的内容，8 个字节，按字符格式显示。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="有符号-与-无符号"><a href="#有符号-与-无符号" class="headerlink" title="有符号 与 无符号"></a>有符号 与 无符号</h3><ul><li><p><strong>有符号数与无符号数正数显示结果一样，负数结果不一样</strong></p></li><li><p>有符号</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无符号 0000 0001 就是 0000 0001, </span><br></pre></td></tr></table></figure><ul><li>无符号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">测试： 1 ， 0x01,</span><br><span class="line">最高位 0， 是正数.</span><br><span class="line">0000 0001    </span><br><span class="line"></span><br><span class="line">最高位 1，是负数.</span><br><span class="line">1000 0001  , 0x81</span><br><span class="line"></span><br><span class="line">int x = 0x81000000; </span><br><span class="line">printf(&quot;有符号表示 %u\n&quot;,x);</span><br><span class="line">printf(&quot;无符号表示 %d\n&quot;,x);</span><br><span class="line">有符号表示 2164260864</span><br><span class="line">无符号表示 -2130706432</span><br></pre></td></tr></table></figure><h3 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><ul><li><strong>正数存储用原码反码补码都一样</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最高位是符号位，其余位为数值的绝对值. </span><br><span class="line">1 的原码 0000 0001 </span><br></pre></td></tr></table></figure><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><ul><li><strong>正数的反码原码相同，负数符号位1，其余位取反</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">原码： 1000 0001</span><br><span class="line">反码:  1111 1110  , 最高位不变.</span><br></pre></td></tr></table></figure><h4 id="补码-！！！负数存储！！！"><a href="#补码-！！！负数存储！！！" class="headerlink" title="补码 -！！！负数存储！！！"></a>补码 -！！！负数存储！！！</h4><ul><li><p><strong>负数补码存储，符号位不变，正数不变，其余位反码加1，</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">正码</span><br><span class="line">1 , 0000 0001.</span><br><span class="line">反码</span><br><span class="line">-1, 1111,1110.</span><br><span class="line">反码</span><br><span class="line">-1, 1111 1111.</span><br><span class="line"></span><br><span class="line">测试： 求 1，-1 在内存中的16进制值;</span><br><span class="line"></span><br><span class="line">1: 正数无需关心，直接转16进制 = 0x01.</span><br><span class="line"></span><br><span class="line">-1: 反码+1， 原码 1000 0001 ， 反码 ，1111 1110 ， 补码+1 , 1111 1111, 得出内存值 0xff.</span><br><span class="line"></span><br><span class="line">cha x = -1;</span><br><span class="line">输出:</span><br><span class="line">x/1xb 0x7ffeefbff3df</span><br><span class="line">0x7ffeefbff3df: 0xff</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><ul><li>**同位为1，结果才是1，否则是0. **</li><li><strong>并且（当2个开关都闭合灯才亮）</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdq50bglcj30e4089t8n.jpg" alt="image-20211113185951722"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试：C: 1 &amp; 2 ，  assembly: and</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">结果 : 0000 0000; 结果为0；</span><br></pre></td></tr></table></figure><h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><ul><li><strong>同位只要有1，就是1</strong></li><li><strong>或者 (两个开关只要一个开关闭合灯就能亮)</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdq732jodj30fj08vq2y.jpg" alt="image-20211113190157102"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试: C: 1 | 2 , assembly : or</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">结果为： 0000 0011; 结果为3；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><ul><li><strong>同位相反才为1，否则为0</strong></li><li><strong>不一样的时候才为1</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwfw171yf7j30fi09tdfv.jpg" alt="image-20211113191238456"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">测试: C: 1 ^ 2 , assembly : xor</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">结果为： 0000 0011; 结果为3；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h4><ul><li><strong>同位交换,单数运算</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试: 1 ，C: ~ , assembly : not</span><br><span class="line">0000 0001</span><br><span class="line"></span><br><span class="line">结果为： 1111 1110；</span><br></pre></td></tr></table></figure><h4 id="左移运算"><a href="#左移运算" class="headerlink" title="左移运算"></a>左移运算</h4><ul><li><strong>各二进制位全部向左移动若干位，高位丢弃，地位补0</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C：&lt;&lt; , assembly : shl</span><br><span class="line"></span><br><span class="line">测试 ： 1，左移1位，</span><br><span class="line">0000 0001 ,结果： 0000 0010； = 2.</span><br><span class="line">左移2；</span><br><span class="line">0000 0001, 结果： 0000 0100； = 4.</span><br><span class="line"></span><br><span class="line">char c = 1 &lt;&lt; 2;</span><br><span class="line">输出为：4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="右移运算"><a href="#右移运算" class="headerlink" title="右移运算"></a>右移运算</h4><ul><li><strong>各二进制位向右移动若干位，无符号高位补0或者有符号高位补1，低位丢弃</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C：&gt;&gt; , assembly : shr</span><br><span class="line"></span><br><span class="line">测试 ： 1，</span><br><span class="line"></span><br><span class="line">右移1位，</span><br><span class="line">0000 0001 ,结果： 0000 0000； = 0.</span><br><span class="line">右移2；</span><br><span class="line">0000 0001, 结果： 0000 0000； = 0.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补符号： 高位补1</span><br><span class="line">C：&gt;&gt; , assembly : sar</span><br><span class="line">测试数： 10；右移2位；</span><br><span class="line">0000 1100; 结果： 1000 0011； 负数存的是反码+1， 1111 1101， 内存值= 0xfd;</span><br><span class="line"></span><br><span class="line">1000 1010 -&gt; 1111 0110 补码值 ：0xf6 右移-&gt; 1111 1101; fd</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="+  - * /"></a>+  - * /</h3><h4 id="-2"><a href="#-2" class="headerlink" title="+"></a>+</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">求 10 + 7 = ？</span><br><span class="line">//混搭伪代码</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 7;</span><br><span class="line"></span><br><span class="line">funcAdd(a,b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//转换</span><br><span class="line">0000 1010 </span><br><span class="line">0000 0111 </span><br><span class="line">//第一步先异或</span><br><span class="line">int tmp = funXor(a,b) funXor(a,b); = 0000 1101</span><br><span class="line">//第二步判断是否有进位</span><br><span class="line">int shlTemp = funcCmp(a,b); 0000 0010； 有进位</span><br><span class="line"></span><br><span class="line">//判断是否有进位 ,</span><br><span class="line">if(shlTemp!=0)</span><br><span class="line">&#123;</span><br><span class="line">//有进位需要位移,位移后的值.</span><br><span class="line">int shlTempValue = funcSHL(shlTemp,1); 0000 0100;</span><br><span class="line"></span><br><span class="line">//将第一次的结果与进位的结果异或 ,第一次递归调用</span><br><span class="line">funcAdd(tmp,shlTempValue);</span><br><span class="line">//第二次异或; </span><br><span class="line">0000 1101</span><br><span class="line">0000 0100</span><br><span class="line">    = tmp = 0000 1001;   </span><br><span class="line">第二次与运算对比，有进位;shlTemp = 0000 0100 </span><br><span class="line">shlTempValue = funcSHL(shlTemp ,1) = 0000 1000;</span><br><span class="line"></span><br><span class="line">//第二次递归调用funcAdd(tmp, shlTempValue); </span><br><span class="line">0000 1001</span><br><span class="line">0000 1000</span><br><span class="line">//第三次异或运算</span><br><span class="line">tem = 0000 0001</span><br><span class="line">//第三次对比 与 运算</span><br><span class="line">shlTemp =0000 1000;</span><br><span class="line">//有进位，第三次位移</span><br><span class="line">shlTempValue = 0001 0000；</span><br><span class="line"></span><br><span class="line">//第三次次递归调用funcAdd(tmp, shlTempValue)</span><br><span class="line">//第四次异或</span><br><span class="line">0000 0001</span><br><span class="line">0001 0000</span><br><span class="line">tem = 0001 0001 = 17;</span><br><span class="line">//第四次与运算，判断是否有进位</span><br><span class="line">//第四次无进位，判断执行完毕，执行后面代码</span><br><span class="line">&#125;</span><br><span class="line">returun tem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与运算</span><br><span class="line">funcCmp(a,b)</span><br><span class="line">&#123;</span><br><span class="line"> 0000 1010 </span><br><span class="line"> &amp;</span><br><span class="line"> 0000 0111  </span><br><span class="line"> </span><br><span class="line">return a&amp;b = 0000 0010;   如果非0，作为返回值继续异或</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左移1位</span><br><span class="line">funcSHL(int a,int offset)&#123;</span><br><span class="line">  a = 0000 0010;</span><br><span class="line">offset = 1;</span><br><span class="line">return a &lt;&lt; 1 = 0000 0100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异或运算</span><br><span class="line">funXor(a,b)</span><br><span class="line">&#123;</span><br><span class="line">a = 0000 1010 </span><br><span class="line">b = 0000 0111 </span><br><span class="line">// 假设没进位</span><br><span class="line">return a^b; 0000 1101;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="－"><a href="#－" class="headerlink" title="－"></a>－</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">求 10 - 7 = ？</span><br><span class="line"></span><br><span class="line">减法就是加法 ， 10-7 = 1 + （-7）;</span><br><span class="line"> </span><br><span class="line">-7 是补码存储，求补码：</span><br><span class="line">正码： 0000 0111; 反码： 1111 1000；补码=反码+1= 1111 1001； 内存=0xf9;</span><br><span class="line"></span><br><span class="line">//混搭伪代码</span><br><span class="line">int a = 10;</span><br><span class="line">int b = -7;</span><br><span class="line">funcAdd(a,b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//转换</span><br><span class="line">0000 1010 </span><br><span class="line">1111 1001 </span><br><span class="line">//第一步先异或</span><br><span class="line">int tmp = funXor(a,b) funXor(a,b); = 1111 0011</span><br><span class="line">//第二步判断是否有进位</span><br><span class="line">int shlTemp = funcCmp(a,b); 0000 1000； 有进位</span><br><span class="line"></span><br><span class="line">//判断是否有进位 ,</span><br><span class="line">if(shlTemp!=0)</span><br><span class="line">&#123;</span><br><span class="line">//有进位需要位移,位移后的值.</span><br><span class="line">int shlTempValue = funcSHL(shlTemp,1); 0001 0000;</span><br><span class="line"></span><br><span class="line">//将第一次的结果与进位的结果异或 ,第一次递归调用</span><br><span class="line">funcAdd(tmp,shlTempValue);</span><br><span class="line">//第二次异或; </span><br><span class="line">1111 0011</span><br><span class="line">0001 0000</span><br><span class="line">    = tmp = 1110 0011;   </span><br><span class="line">第二次与运算对比，有进位;shlTemp = 0001 0000 </span><br><span class="line">shlTempValue = funcSHL(shlTemp ,1) = 0010 0000;</span><br><span class="line"></span><br><span class="line">--------------n次递归-----------------</span><br><span class="line">求 10 - 7 = 10 + （-7） </span><br><span class="line">0000 1010 </span><br><span class="line">1111 1001 </span><br><span class="line">异或 tmp = 1111 0011</span><br><span class="line">进位： 0000 1000</span><br><span class="line">进位后的值 shlTempValue = funcSHL(000 1000 ,1) = 0001 0000</span><br><span class="line">-------------------------------------</span><br><span class="line">1111 0011</span><br><span class="line">0001 0000</span><br><span class="line">异或 tmp = 1110 0011</span><br><span class="line">进位： 0001 0000</span><br><span class="line">进位后的值 shlTempValue = funcSHL(0001 0000 ,1) = 0010 0000</span><br><span class="line">---------------------------------------</span><br><span class="line">1110 0011</span><br><span class="line">0010 0000</span><br><span class="line">tmp = 1100 0011</span><br><span class="line">shlTempValue = funcSHL(0010 0000 ,1) = 0100 0000</span><br><span class="line">-------------------------------</span><br><span class="line">0100 0000</span><br><span class="line">1100 0011</span><br><span class="line">tmp = 1000 0011</span><br><span class="line">shlTempValue = funcSHL(0100 0000 ,1) = 1000 0000</span><br><span class="line">---------------------------------</span><br><span class="line">1000 0000</span><br><span class="line">1000 0011</span><br><span class="line">tmp = 1000 0011;</span><br><span class="line">shlTempValue = funcSHL(0100 0000 ,1) = 0001 0000 0000</span><br><span class="line">0001 0000 0000</span><br><span class="line">0000 0000 0011</span><br><span class="line">0001 0000 0011  ？？？？？？WTF  此时结果产生了溢出； 篇幅原因 就不展开讲了</span><br><span class="line">-------------------------------------</span><br><span class="line">tem = 0001 0000 0011 ;</span><br><span class="line">//第四次与运算，判断是否有进位</span><br><span class="line">//第四次无进位，判断执行完毕，执行后面代码</span><br><span class="line">&#125;</span><br><span class="line">returun tem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与运算</span><br><span class="line">funcCmp(a,b)</span><br><span class="line">&#123;</span><br><span class="line"> 0000 1010 </span><br><span class="line"> &amp;</span><br><span class="line"> 0000 0111  </span><br><span class="line"> </span><br><span class="line">return a&amp;b = 0000 0010;   如果非0，作为返回值继续异或</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左移1位</span><br><span class="line">funcSHL(int a,int offset)&#123;</span><br><span class="line">  a = 0000 0010;</span><br><span class="line">offset = 1;</span><br><span class="line">return a &lt;&lt; 1 = 0000 0100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//异或运算</span><br><span class="line">funXor(a,b)</span><br><span class="line">&#123;</span><br><span class="line">a = 0000 1010 </span><br><span class="line">b = 0000 0111 </span><br><span class="line">// 假设没进位</span><br><span class="line">return a^b; 0000 1101;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-3"><a href="#-3" class="headerlink" title="*"></a>*</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">求 10 * 7 = ？ </span><br><span class="line">解： 7 个 10 相加; </span><br><span class="line">int a = 10;</span><br><span class="line">int b = 7;</span><br><span class="line"></span><br><span class="line">for (int i =0; i &lt; 7 ; i++ )&#123;</span><br><span class="line">funcAdd(a,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-4"><a href="#-4" class="headerlink" title="/"></a>/</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">求 10 * 7 = ？ </span><br><span class="line">解： 7 个 10 相加; </span><br><span class="line">int a = 10;</span><br><span class="line">int b = 7;</span><br><span class="line"></span><br><span class="line">for (int i =0; i &lt; 7 ; i++ )&#123;</span><br><span class="line">//转换补码负数</span><br><span class="line">b = 1111 1001; </span><br><span class="line">funcAdd(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;汇编之有趣的计算机&quot;&gt;&lt;a href=&quot;#汇编之有趣的计算机&quot; class=&quot;headerlink&quot; title=&quot;汇编之有趣的计算机&quot;&gt;&lt;/a&gt;汇编之有趣的计算机&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a message if i messe</summary>
      
    
    
    
    <category term="Assembly" scheme="http://www.010101.cc/categories/Assembly/"/>
    
    
    <category term="汇编" scheme="http://www.010101.cc/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC Stop The World &amp; SafePoint</title>
    <link href="http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%20Stop%20The%20World%20&amp;%20SafePoint/"/>
    <id>http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%20Stop%20The%20World%20&amp;%20SafePoint/</id>
    <published>2021-11-13T05:08:57.000Z</published>
    <updated>2021-11-13T07:06:33.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC-Stop-The-World-amp-SafePoint浅析"><a href="#GC-Stop-The-World-amp-SafePoint浅析" class="headerlink" title="GC Stop The World &amp; SafePoint浅析"></a>GC Stop The World &amp; SafePoint浅析</h2><p>Wirte by 021.  Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdj0ch0g1j30k00f00tt.jpg" alt="Portable Unobtrusive Garbage Collection for Multiprocessor Systems Damien"></p><h4 id="1-在哪里停止-Where-is-SafePoint？"><a href="#1-在哪里停止-Where-is-SafePoint？" class="headerlink" title="1. 在哪里停止 Where is SafePoint？"></a>1. 在哪里停止 Where is SafePoint？</h4><ul><li><strong>什么是安全点SafePoint？</strong></li></ul><ul><li><strong>安全点的实现</strong></li></ul><h4 id="2-什么时候停-When-is-the-Stop-the-world-happend"><a href="#2-什么时候停-When-is-the-Stop-the-world-happend" class="headerlink" title="2. 什么时候停 When is the Stop the world happend?"></a>2. 什么时候停 When is the Stop the world happend?</h4><h4 id="3-停下来做什么-after-Stop-The-World"><a href="#3-停下来做什么-after-Stop-The-World" class="headerlink" title="3. 停下来做什么 after Stop The World?"></a>3. 停下来做什么 after Stop The World?</h4><h4 id="上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90"><a href="#上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90" class="headerlink" title="上一篇 ：GC垃圾回收原理浅析：https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"></a>上一篇 ：GC垃圾回收原理浅析：<a href="https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/">https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GC-Stop-The-World-amp-SafePoint浅析&quot;&gt;&lt;a href=&quot;#GC-Stop-The-World-amp-SafePoint浅析&quot; class=&quot;headerlink&quot; title=&quot;GC Stop The World &amp;amp; Sa</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC调优方法论</title>
    <link href="http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>http://www.010101.cc/2021/11/13/JVM%E4%B9%8BGC%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2021-11-13T05:08:57.000Z</published>
    <updated>2021-11-13T05:56:33.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC调优方法论"><a href="#JVM之GC调优方法论" class="headerlink" title="JVM之GC调优方法论"></a>JVM之GC调优方法论</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd42l4mej319j0jt762.jpg" alt="image-20210320093842591"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwceol0aqkj30fy091aa8.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfra35t1j30xe0d5775.jpg" alt="image-20211112161507515"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd4ba2k2j30k006yjrz.jpg" alt="img"></p><h4 id="1-GC调优目标："><a href="#1-GC调优目标：" class="headerlink" title="1. GC调优目标："></a>1. GC调优目标：</h4><h5 id="高吞吐型："><a href="#高吞吐型：" class="headerlink" title="高吞吐型："></a>高吞吐型：</h5><p>​            * </p><h5 id="快速响应型："><a href="#快速响应型：" class="headerlink" title="快速响应型："></a>快速响应型：</h5><h4 id="上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90"><a href="#上一篇-：GC垃圾回收原理浅析：https-www-010101-cc-2021-11-11-JVM-E4-B9-8BGC-E5-9E-83-E5-9C-BE-E5-9B-9E-E6-94-B6-E6-B5-85-E6-9E-90" class="headerlink" title="上一篇 ：GC垃圾回收原理浅析：https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"></a>上一篇 ：GC垃圾回收原理浅析：<a href="https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/">https://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC调优方法论&quot;&gt;&lt;a href=&quot;#JVM之GC调优方法论&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC调优方法论&quot;&gt;&lt;/a&gt;JVM之GC调优方法论&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java编译器浅析</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E7%BC%96%E8%AF%91%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-13T07:21:02.195Z</updated>
    
    <content type="html"><![CDATA[<p>Wirte by 021.</p><h2 id="Java编译器浅析"><a href="#Java编译器浅析" class="headerlink" title="Java编译器浅析"></a>Java编译器浅析</h2><ul><li><p><strong>本地代码（native code）</strong> 是计算机编程（代码），编译用来运行一个特殊的处理器（如英特尔x86级的处理器）和它的特殊指令集，简称机器码.</p><ul><li><p>Win : exe</p></li><li><p>Linux : elf</p></li></ul></li></ul><h4 id="模式1-：-即时编译JIT编译器-Just-in-time"><a href="#模式1-：-即时编译JIT编译器-Just-in-time" class="headerlink" title="模式1 ： 即时编译JIT编译器-Just in time."></a>模式1 ： 即时编译JIT编译器-Just in time.</h4><ul><li>主要用于JVM将 **class热点代码 ** 编译为本地代码.</li></ul><h4 id="模式2：-解释器-byteCode-intepreter"><a href="#模式2：-解释器-byteCode-intepreter" class="headerlink" title="模式2： 解释器 byteCode intepreter"></a>模式2： 解释器 byteCode intepreter</h4><ul><li>在程序运行过程中，JVM将字节码再转换成本地可执行的本地代码,边解释字节码边执行，故而称为解释器。</li></ul><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认： -Xmixed 混合模式</span><br><span class="line">-Xint 解释模式，启动块，执行稍微慢</span><br><span class="line">-XComp 编译模式，启动时间慢，需要编译</span><br></pre></td></tr></table></figure><h4 id="编译器-—-TODO"><a href="#编译器-—-TODO" class="headerlink" title="编译器 — TODO"></a>编译器 — TODO</h4><ul><li> <strong>C1</strong></li><li> <strong>C2</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h2 id=&quot;Java编译器浅析&quot;&gt;&lt;a href=&quot;#Java编译器浅析&quot; class=&quot;headerlink&quot; title=&quot;Java编译器浅析&quot;&gt;&lt;/a&gt;Java编译器浅析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地代码</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC垃圾回收器与算法深入浅出</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-15T10:01:27.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC浅析"><a href="#JVM之GC浅析" class="headerlink" title="JVM之GC浅析"></a>JVM之GC浅析</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd42l4mej319j0jt762.jpg" alt="image-20210320093842591"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwceol0aqkj30fy091aa8.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwfzkk2861j30u00q7ju1.jpg" alt="img"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd4ba2k2j30k006yjrz.jpg" alt="img"></p><h4 id="堆特性"><a href="#堆特性" class="headerlink" title="堆特性"></a>堆特性</h4><ul><li>Eden <ul><li>存活对象少</li></ul></li><li>S1</li><li>S2</li><li>Old<ul><li>存活对象多</li></ul></li></ul><h4 id="对象存活晋升过程"><a href="#对象存活晋升过程" class="headerlink" title="对象存活晋升过程"></a>对象存活晋升过程</h4><ul><li>按年龄</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。</span><br><span class="line"></span><br><span class="line">Paralle Scavenge 15</span><br><span class="line">CMS 6</span><br><span class="line">G1 15</span><br></pre></td></tr></table></figure><ul><li>动态年龄分配函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line">//survivor_capacity是survivor空间的大小</span><br><span class="line">  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);</span><br><span class="line">  size_t total = 0;</span><br><span class="line">  uint age = 1;</span><br><span class="line">  while (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];//sizes数组是每个年龄段对象大小</span><br><span class="line">    if (total &gt; desired_survivor_size) break;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="什么是垃圾？（对象引用详解）"><a href="#什么是垃圾？（对象引用详解）" class="headerlink" title="什么是垃圾？（对象引用详解）"></a>什么是垃圾？（对象引用详解）</h4><ul><li><p><strong>什么是强引用Strong Reference？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。</span><br></pre></td></tr></table></figure></li><li><p><strong>什么情况下会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">o = null;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>什么是软引用SoftReference？</strong></p><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Student&gt;studentSoftReference=new SoftReference&lt;Student&gt;(new Student());</span><br><span class="line">        Student student = studentSoftReference.get();</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        </span><br><span class="line"> SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;byte[]&gt;(new byte[1024*1024*10]);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        byte[] bytes = new byte[1024 * 1024 * 10];</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">//// 将内存调小 -Xmx20M ，输出结果：</span><br><span class="line"></span><br><span class="line">[B@11d7fff</span><br><span class="line">[B@11d7fff</span><br><span class="line">null</span><br></pre></td></tr></table></figure></li><li><p><strong>什么时候会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当JVM内存不足，执行GC后，内存依然不足，会回收软引用.</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>什么是弱引用WeakReference？</strong></p><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1]);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        </span><br><span class="line">//输出结果：        </span><br><span class="line">[B@11d7fff</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>什么情况下会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要触发GC就会被回收.</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>什么是虚引用PhantomReference？</strong></p><ul><li><p><strong>特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NIO中，就运用了虚引用管理堆外内存，用于堆外内存的释放.</span><br></pre></td></tr></table></figure><ul><li><p>看官方源码注释 ： 本大神硬核翻译！希望你能懂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Phantom reference objects, which are enqueued after the collector</span><br><span class="line"> * determines that their referents may otherwise be reclaimed.  Phantom</span><br><span class="line"> * references are most often used for scheduling pre-mortem cleanup actions in</span><br><span class="line"> * a more flexible way than is possible with the Java finalization mechanism.</span><br><span class="line"> *</span><br><span class="line"> </span><br><span class="line">虚引用对象，在垃圾收集器决定这些引用可能被回收时入队，</span><br><span class="line">虚引用经常用于在“对象死亡后，对对象进行死亡讣告” </span><br><span class="line">是一种可能比Java直接回收的更灵活一种方式.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> * &lt;p&gt; If the garbage collector determines at a certain point in time that the</span><br><span class="line"> * referent of a phantom reference is &lt;a</span><br><span class="line"> * href=&quot;package-summary.html#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that</span><br><span class="line"> * time or at some later time it will enqueue the reference.</span><br><span class="line"> *</span><br><span class="line"> //此段没有太大的意义</span><br><span class="line"> </span><br><span class="line"> * &lt;p&gt; In order to ensure that a reclaimable object remains so, the referent of</span><br><span class="line"> * a phantom reference may not be retrieved: The &lt;code&gt;get&lt;/code&gt; method of a</span><br><span class="line"> * phantom reference always returns &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line"> *</span><br><span class="line"> // 为了保证 已确定回收对象 的规则， 虚引用不再返回该对象的引用.</span><br><span class="line"> </span><br><span class="line"> * &lt;p&gt; Unlike soft and weak references, phantom references are not</span><br><span class="line"> * automatically cleared by the garbage collector as they are enqueued.  An</span><br><span class="line"> * object that is reachable via phantom references will remain so until all</span><br><span class="line"> * such references are cleared or themselves become unreachable.</span><br><span class="line"> *</span><br><span class="line"> * @author   Mark Reinhold</span><br><span class="line"> * @since    1.2</span><br><span class="line"> */</span><br><span class="line"> //不像其他引用一样，在虚引用入队后不会自动被垃圾回收器清理,</span><br><span class="line"> 一个可达对象被虚引用所引用后会一直保持在列队，直到这些引用被清理或者这些引用变得不可达.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> =================================</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Reference queues, to which registered reference objects are appended by the</span><br><span class="line"> * garbage collector after the appropriate reachability changes are detected.</span><br><span class="line"> *</span><br><span class="line"> * @author   Mark Reinhold</span><br><span class="line"> * @since    1.2</span><br><span class="line"> */</span><br><span class="line"> 当垃圾回收器在适合的时机检测到可达性发生改变时决定 将这些 引用 加入列队.</span><br><span class="line"></span><br><span class="line">public class ReferenceQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>什么情况下会被回收？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;A对象 被回收了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void freeMem() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行堆外内存释放&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;B对象 被回收了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    final  int a = 0;</span><br><span class="line">    final int b =10;</span><br><span class="line">    final static int c = 0;</span><br><span class="line">    volatile int d = 0;</span><br><span class="line">    volatile int e = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        PerformanceTest p = new PerformanceTest();</span><br><span class="line">        //p.test(0,0);</span><br><span class="line">        //打印当前对象内存分布</span><br><span class="line">        //System.out.println(VM.current().details());</span><br><span class="line">        //System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable());</span><br><span class="line">        //虚引用测试</span><br><span class="line">        p.phantomReferenceTest();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void phantomReferenceTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class="line">        //强引用</span><br><span class="line">        A a = new A();</span><br><span class="line">        B b = new B();</span><br><span class="line">        //虚引用</span><br><span class="line">        PhantomReference&lt;A&gt; reference = new PhantomReference&lt;A&gt;(new A(),queue);</span><br><span class="line">        //弱引用</span><br><span class="line">        WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1024*1024*10]);</span><br><span class="line">        System.out.println(&quot;强引用GC回收前强引用=====================&quot;+a);</span><br><span class="line">        System.out.println(&quot;强引用GC回收前弱引用：=====================&quot;+weakReference.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //此线程触发GC 设置-Xmx20M</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 30;i++ ) &#123;</span><br><span class="line">                bytes.add(new byte[1024 * 1024]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;强引用GC回收后弱引用：=====================&quot;+weakReference.get());</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Reference poll = queue.poll();</span><br><span class="line">                if (poll != null) &#123;</span><br><span class="line">                    System.out.println(&quot;虚引用被回收了：&quot; + poll);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll == null) &#123;</span><br><span class="line">                    System.out.println(&quot;内存中没有引虚拟引用了，被清理了&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        new A().freeMem();</span><br><span class="line">                    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                        throwable.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;强引用GC回收后强引用A:=====================&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出结果:     执行结果有乱序，不影响，用序号标记解释</span><br><span class="line"></span><br><span class="line">1.强引用GC回收前强引用=====================com.mybrainsbox.performance.A@621be5d1</span><br><span class="line">2.强引用GC回收前弱引用：=====================[B@573fd745</span><br><span class="line">3.A对象 被回收了</span><br><span class="line">4.强引用GC回收后弱引用：=====================null</span><br><span class="line">5.强引用GC回收后强引用A:=====================com.mybrainsbox.performance.A@621be5d1</span><br><span class="line">6.虚引用被回收了：java.lang.ref.PhantomReference@6d39548b</span><br><span class="line">7.内存中没有引虚拟引用了，被清理了</span><br><span class="line">8.B对象 被回收了</span><br><span class="line">9.执行堆外内存释放</span><br><span class="line">10.A对象 被回收了</span><br><span class="line">====================================================</span><br><span class="line"></span><br><span class="line">3.A对象 被回收了  这一步输出对应 ：         </span><br><span class="line">PhantomReference&lt;A&gt; reference = new PhantomReference&lt;A&gt;(new A(),queue);</span><br><span class="line">一旦触发GC, 被PhantomReference引用的对象都会被设置为弱引用，并加入虚引用列队.等待回收.</span><br><span class="line">所以这一步在GC触发时输出.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.虚引用被回收了：java.lang.ref.PhantomReference@6d39548b</span><br><span class="line">这一步是 虚引用列队在GC后拿到被虚引用引用的new A()最后的回执，所有的可达性检测决定可能要回收的对象都会被加入此列队，直到poll()出全部.</span><br><span class="line"></span><br><span class="line">7.内存中没有引虚拟引用了，被清理了;</span><br><span class="line">这一步是poll出了所有的虚引用的对象列队;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.B对象 被回收了</span><br><span class="line">10.A对象 被回收了</span><br><span class="line">8和10是方法出栈被回收的.</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="怎么样找到垃圾？"><a href="#怎么样找到垃圾？" class="headerlink" title="怎么样找到垃圾？"></a>怎么样找到垃圾？</h4><ul><li><p><strong>引用计数器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在对象头里，有数据位表示该对象有没有引用，当引用计数为0对象将被回收.</span><br></pre></td></tr></table></figure><ul><li>缺陷 ：<strong>循环引用</strong>  容易引起孤岛效应—- 即 ： A -&gt; B -&gt; C , 3个对象互相引用，计数不为0，但实际已经没有任何引用指向这三个对象.</li></ul></li></ul><ul><li><strong>Root Searching 根可达算法</strong>  <ul><li><strong>根路径</strong><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li></ul></li></ul></li></ul><h4 id="常见GC垃圾回收算法"><a href="#常见GC垃圾回收算法" class="headerlink" title="常见GC垃圾回收算法"></a>常见GC垃圾回收算法</h4><ul><li><p>标记  -&gt; 清除</p><ul><li><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，标记过程：</span><br><span class="line">从GC root出发遍历所有对象，在可达对象头中的markeword进行标记. </span><br><span class="line"></span><br><span class="line">2，清理过程：遍历堆中对象，判断对象头markword是否存活标记，进行回收.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>缺陷</p><ul><li><p>效率问题：需要2遍扫描，标记和清除都需要遍历，效率不高；</p></li><li><p>空间问题：标记清除后会产生大量不连续的内存水平，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。</p></li></ul></li><li><p>适用堆区</p><ul><li>Old</li></ul></li><li><p>触发GC类型</p><ul><li>Major GC/老年代GC</li></ul></li></ul></li></ul><ul><li><p>标记 -&gt; 复制</p><ul><li><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，标记 : 将年轻代的空间一分为三，[Eden],[ s1 ] ,[ s2 ]，比例是：8：1：1 ，</span><br><span class="line"></span><br><span class="line">2，复制: 当使用 s1内存块 使用率达到阈值，s2空白，将存活对象复制到s2内存空间.</span><br><span class="line"></span><br><span class="line">3,清理 : 清理s1空间块. 通过这个方式避免了碎片化空间问题.</span><br></pre></td></tr></table></figure></li><li><p>缺陷</p><ul><li>效率问题：标记和清除都需要遍历，效率不高；</li><li>空间问题：内存空间浪费，最大10%，</li></ul></li><li><p>适用堆区</p><ul><li>Eden</li></ul></li><li><p>触发GC类型</p><ul><li>MinorGC/年轻代GC</li></ul></li></ul></li><li><p>标记 -&gt; 压缩（整理）</p><ul><li><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，先标记</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2，压缩整理： 把可达对象往内存块偏移量折中的任意一端移动，达到空间整洁规整。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>缺陷</p><ul><li>效率问题：需要扫描2次，移动对象引用需要重新引用地址，，效率不如复制算法高效；</li></ul></li><li><p>适用堆区</p><ul><li> Old</li></ul></li></ul><ul><li>触发GC类型<ul><li>Major GC/老年代GC</li></ul></li></ul></li></ul><h4 id="GC垃圾回收器（算法的实现）"><a href="#GC垃圾回收器（算法的实现）" class="headerlink" title="GC垃圾回收器（算法的实现）"></a>GC垃圾回收器（算法的实现）</h4><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><h4 id="STW安全点"><a href="#STW安全点" class="headerlink" title="STW安全点"></a>STW安全点</h4><ul><li>编译器提前编译好安全区域标志位，通过对象oopmap映射，GC通过opmap表来判断线程是否到达对象安全点.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">HotSpot 用的就是映射表，这个表叫 OopMap。</span><br><span class="line"></span><br><span class="line">在 HotSpot 中，对象的类型信息里会记录自己的 OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据，而在解释器中执行的方法可以通过解释器里的功能自动生成出 OopMap 出来给 GC 用。</span><br><span class="line"></span><br><span class="line">被 JIT 编译过的方法，也会在特定的位置生成 OopMap，记录了执行到该方法的某条指令时栈上和寄存器里哪些位置是引用。</span><br><span class="line"></span><br><span class="line">这些特定的位置主要在：</span><br><span class="line"></span><br><span class="line">循环的末尾（非 counted 循环）</span><br><span class="line"></span><br><span class="line">方法临返回前 / 调用方法的call指令后</span><br><span class="line"></span><br><span class="line">可能抛异常的位置</span><br><span class="line"></span><br><span class="line">这些位置就叫作安全点(safepoint)。</span><br><span class="line"></span><br><span class="line">那为什么要选择这些位置插入呢？因为如果对每条指令都记录一个 OopMap 的话空间开销就过大了，因此就选择这些个关键位置来记录即可。</span><br><span class="line"></span><br><span class="line">所以在 HotSpot 中 GC 不是在任何位置都能进入的，只能在安全点进入。</span><br><span class="line"></span><br><span class="line">至此我们知晓了可以在类加载时计算得到对象类型中的 OopMap，解释器生成的 OopMap 和 JIT 生成的 OopMap ，所以 GC 的时候已经有充足的条件来准确判断对象类型。</span><br><span class="line"></span><br><span class="line">因此称为准确式 GC。</span><br><span class="line"></span><br><span class="line">其实还有个 JNI 调用，它们既不在解释器执行，也不会经过 JIT 编译生成，所以会缺少 OopMap。</span><br><span class="line"></span><br><span class="line">在 HotSpot 是通过句柄包装来解决准确性问题的，像 JNI 的入参和返回值引用都通过句柄包装起来，也就是通过句柄再访问真正的对象。</span><br><span class="line"></span><br><span class="line">这样在 GC 的时候就不用扫描 JNI 的栈帧，直接扫描句柄表就知道 JNI 引用了 GC 堆中哪些对象了。</span><br><span class="line"></span><br><span class="line">安全点</span><br><span class="line"></span><br><span class="line">我们已经提到了安全点，安全点当然不是只给记录 OopMap 用的，因为 GC 需要一个一致性快照，所以应用线程需要暂停，而暂停点的选择就是安全点。</span><br><span class="line"></span><br><span class="line">我们来捋一遍思路。首先给个 GC 名词，在垃圾收集场景下将应用程序称为 mutator 。</span><br><span class="line"></span><br><span class="line">一个能被 mutator 访问的对象就是活着的，也就是说 mutator 的上下文包含了可以访问存活对象的数据。</span><br><span class="line"></span><br><span class="line">这个上下文其实指的就是栈、寄存器等上面的数据，对于 GC 而言它只关心栈上、寄存器等哪个位置是引用，因为它只需要关注引用。</span><br><span class="line"></span><br><span class="line">但是上下文在 mutator 运行过程中是一直在变化的，所以 GC 需要获取一个一致性上下文快照来枚举所有的根对象。</span><br><span class="line"></span><br><span class="line">而快照的获取需要停止 mutator 所有线程，不然就得不到一致的数据，导致一些活着对象丢失，这里说的一致性其实就像事务的一致性。</span><br><span class="line"></span><br><span class="line">而 mutator 所有线程中这些有机会成为暂停位置的点就叫 safepoint 即安全点。</span><br><span class="line"></span><br><span class="line">openjdk 官网对安全点的定义是：</span><br><span class="line"></span><br><span class="line">A point during program execution at which all GC roots are known and all heap object contents are consistent. From a global point of view, all threads must block at a safepoint before the GC can run.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在JIT执行方式下，JIT编译的时候直接把Safepoint的检查代码加入了生成的本地代码。当JVM需要让Java线程进入Safepoint时，只需要设置一个标志位，让Java线程运行到Safepoint时主动检查这个标志位，如果标志被设置，那么线程停顿，如果没有被设置，那么继续执行。如HotSpot在x86中为轮询Safepoint会生成一条类似于test汇编指令。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcgefrhokj31g20u0ahv.jpg" alt="image-20211112163726225"></p><h4 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h4><ul><li>l</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC浅析&quot;&gt;&lt;a href=&quot;#JVM之GC浅析&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC浅析&quot;&gt;&lt;/a&gt;JVM之GC浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.si</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java对象内存分布</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T09:12:21.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java对象内存分布"><a href="#Java对象内存分布" class="headerlink" title="Java对象内存分布"></a>Java对象内存分布</h2><p>Wirte by 021.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbbdazz1gj30va0u0gpj.jpg" alt="image-20211111165741691"></p><ul><li><strong>对象全局图</strong></li></ul><p>​    <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbataffm6j30k00ct74n.jpg" alt="img"></p><ul><li><p><strong>头部markword</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbaul5a3lj30k006yjrz.jpg" alt="img"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java对象内存分布&quot;&gt;&lt;a href=&quot;#Java对象内存分布&quot; class=&quot;headerlink&quot; title=&quot;Java对象内存分布&quot;&gt;&lt;/a&gt;Java对象内存分布&lt;/h2&gt;&lt;p&gt;Wirte by 021.&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Java运行时数据区浅析---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BATODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T10:19:31.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之运行时数据区-————–-TODO"><a href="#JVM之运行时数据区-————–-TODO" class="headerlink" title="JVM之运行时数据区 ————–   TODO"></a>JVM之运行时数据区 ————–   TODO</h2><p>Wirte by 021.</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbc2zlq9nj31060n5jvn.jpg" alt="image-20211111172223120"></h4><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    final  int a = 0;</span><br><span class="line">    final int b =10;</span><br><span class="line">    final static int c = 0;</span><br><span class="line">    volatile int d = 0;</span><br><span class="line">    volatile int e = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line">        PerformanceTest p = new PerformanceTest();</span><br><span class="line">        p.test(a,b);</span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">        System.out.println(ClassLayout.parseClass(PerformanceTest.class).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int test(int a , int b)&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(this.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Long.class.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Integer.class.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Progarm-Counter-程序计数器"><a href="#Progarm-Counter-程序计数器" class="headerlink" title="Progarm Counter 程序计数器"></a>Progarm Counter 程序计数器</h4><ul><li>执行代码行标记</li></ul><h4 id="JVM-stack-方法栈"><a href="#JVM-stack-方法栈" class="headerlink" title="JVM stack 方法栈"></a>JVM stack 方法栈</h4><ul><li><p>Local Variable Table 局部变量表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args[]</span><br><span class="line"></span><br><span class="line">int f = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Operand Stack 操作数栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>Dynamic Linking 静态连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前线程在运行时与常量池符号的连接. 指向常量池的变量.  示例代码中：final static int c = 0，p.test(0,0);;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Retuen Address 返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数执行结果的值地址存入栈顶. p.test(a,b) = return a + b;</span><br></pre></td></tr></table></figure></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul><li>Native  本地方法相关方法栈.</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>l</li></ul><h4 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h4><ul><li>JVM可以直接访问的内核空间内存，0拷贝。</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li></li></ul><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认： -Xmixed 混合模式</span><br><span class="line">-Xint 解释模式，启动块，执行稍微慢</span><br><span class="line">-XComp 编译模式，启动时间慢，需要编译</span><br></pre></td></tr></table></figure><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之运行时数据区-————–-TODO&quot;&gt;&lt;a href=&quot;#JVM之运行时数据区-————–-TODO&quot; class=&quot;headerlink&quot; title=&quot;JVM之运行时数据区 ————–   TODO&quot;&gt;&lt;/a&gt;JVM之运行时数据区 ————–   TO</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Btree之Mysql自顶向下</title>
    <link href="http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <id>http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Btree%E4%B9%8BMysql%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-11T15:40:05.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析"><a href="#M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析" class="headerlink" title="M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析"></a>M Way Serach, Balance Tree , Balance+ tree, Mysql数据存储与底层结构浅析</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbmoyywxmj30xp0j0gnc.jpg" alt="B+ Tree structure with buckets (Begginer question) - Database  Administrators Stack Exchange"></p><div class="row">    <embed src="./数据结构Btree之Mysql自顶向下.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析&quot;&gt;&lt;a href=&quot;#M-Way-Serach-Balance-Tree-Balance-tree-Mysql数据存储与底层结构浅析&quot; class=&quot;h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树结构" scheme="http://www.010101.cc/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC垃圾回收器浅析</title>
    <link href="http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>http://www.010101.cc/2021/11/11/JVM%E4%B9%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-25T03:20:06.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM之GC垃圾回收器浅析"><a href="#JVM之GC垃圾回收器浅析" class="headerlink" title="JVM之GC垃圾回收器浅析"></a>JVM之GC垃圾回收器浅析</h2><p>Wirte by 021.   Leave a message if i messed up ! : )</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwqlquf8qmj30kc0hmwg7.jpg" alt="img"></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcd4ba2k2j30k006yjrz.jpg" alt="img"></p><h4 id="GC垃圾回收器的目标"><a href="#GC垃圾回收器的目标" class="headerlink" title="GC垃圾回收器的目标"></a>GC垃圾回收器的目标</h4><ul><li><strong>减少GC停顿时间</strong></li><li><strong>避免程序崩溃</strong></li><li><strong>优化JVM内存空间</strong></li></ul><h4 id="GC垃圾回收的主要步骤："><a href="#GC垃圾回收的主要步骤：" class="headerlink" title="GC垃圾回收的主要步骤："></a>GC垃圾回收的主要步骤：</h4><p>A garbage collector (GC) is a memory management tool. The G1 GC achieves automatic memory management through the following operations:</p><ul><li><p>Allocating objects to a young generation and promoting aged objects into an old generation.</p><ul><li><strong>在年轻代为新的对象分配内存, 将晋升的对象移到老年代</strong></li></ul></li><li><p>Finding live objects in the old generation through a concurrent (parallel) marking phase. The Java HotSpot VM triggers the marking phase when the total Java heap occupancy exceeds the default threshold.</p><ul><li><strong>通过并发(并行)标记阶段在老年代寻找存活对象，当Java的堆总内存占用率超过默认的阈值时hotspop虚拟机将触发标记执行阶段</strong></li></ul></li><li><p>Recovering free memory by compacting live objects through parallel copying.</p><ul><li><strong>通过并行的 ”复制和压缩存活对象“ 的方式，来恢复和释放可用的内存空间</strong></li></ul></li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul><li><strong>基于 标记-清除 算法</strong></li><li><strong>适用于老年代</strong></li></ul><ul><li><p><strong>回收过程</strong></p><ul><li><strong>初始标记 STW</strong></li><li><strong>并发标记</strong></li><li><strong>重新标记 STW</strong></li><li><strong>并发清除</strong></li></ul></li><li><p><strong>缺陷</strong></p><ul><li><p><strong>2次STW</strong></p></li><li><p><strong>内存碎片化</strong></p></li></ul></li></ul><h3 id="G1-（garbage-first-垃圾第一）"><a href="#G1-（garbage-first-垃圾第一）" class="headerlink" title="G1 （garbage first 垃圾第一）"></a>G1 （garbage first 垃圾第一）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwqgycbj9tj31400u00xj.jpg" alt="Untitled 3"></p><ul><li><p><strong>逻辑分代对象</strong></p><ul><li><p><strong>eden 新创建的对象（new object）</strong></p></li><li><p><strong>survivor 存活对象</strong></p></li><li><p><strong>old 老年对象</strong></p></li><li><p><strong>humongous 超大对象</strong></p></li></ul></li></ul><h4 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h4><ul><li>The <a href="https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html">Garbage First Garbage Collector (G1 GC)</a> is the low-pause, server-style generational garbage collector for Java HotSpot VM. The G1 GC uses concurrent and parallel phases to achieve its target pause time and to maintain good throughput. When G1 GC determines that a garbage collection is necessary, it collects the regions with the least live data first (garbage first).</li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>it collects the regions with the least live data first</strong><ul><li><strong>优先收集存活对最少的区域</strong></li></ul></li></ul><ul><li><p><strong>The G1 GC is a regionalized and generational garbage collector, which means that the Java object heap (heap) is divided into a number of equally sized regions. Upon startup, the Java Virtual Machine (JVM) sets the region size. The region sizes can vary from 1 MB to 32 MB depending on the heap size. The goal is to have no more than 2048 regions. The eden, survivor, and old generations are logical sets of these regions and are not contiguous.</strong></p><ul><li><strong>G1是区域化和分代的垃圾回收器，堆内存被划分化为大小相等的区域。启动时，虚拟机会设置区域大小。这些区域的大小会根据总堆尺寸被划分为1-32m不同的尺寸。目标是不要超过2048个区域。年轻代，存活代，和老年代，在区域里是逻辑集合，并且并不是连续相邻的.</strong></li></ul></li></ul><ul><li><p><strong>The G1 GC has a pause time-target that it tries to meet (soft real time). During young collections, the G1 GC adjusts its young generation (eden and survivor sizes) to meet the soft real-time target. During mixed collections, the G1 GC adjusts the number of old regions that are collected based on a target number of mixed garbage collections, the percentage of live objects in each region of the heap, and the overall acceptable heap waste percentage.</strong></p><ul><li><strong>G1 GC 有一个它试图满足的暂停时间的目标，</strong></li><li>**在年轻代收集期间，G1回收器会调整 年轻代的堆尺寸 来达到 ”暂停时间的预期 目标“. **</li><li><strong>在混合混合收集期间，G1回收器会调整 收集过的老年代区域的数量， 基于混合收集器模式预期的目标数量，以及在整个堆每个区域中存活对象的比例，和综合可接受的堆浪费比。</strong></li></ul></li></ul><h4 id="Phases-of-the-Marking-Cycle-标记周期的阶段性"><a href="#Phases-of-the-Marking-Cycle-标记周期的阶段性" class="headerlink" title="Phases of the Marking Cycle(标记周期的阶段性)"></a>Phases of the Marking Cycle(标记周期的阶段性)</h4><p>The marking cycle has the following phases:</p><ul><li><p><strong>Initial mark phase</strong>: The G1 GC marks the roots during this phase. This phase is piggybacked on a normal (STW) young garbage collection.</p><ul><li><strong>初始化标记阶段（STW）： G1 在这个阶段是 从ROOTS开始引用. 这阶段会装载一个普通（STW)的young垃圾回收上。</strong></li></ul></li><li><p><strong>Root region scanning phase</strong>: The G1 GC scans survivor regions of the initial mark for references to the old generation and marks the referenced objects. This phase runs concurrently with the application (not STW) and must complete before the next STW young garbage collection can start.</p><ul><li><strong>根区块扫描阶段： G1会扫描 在 （初始标记阶段中 成为old老年代的引用和被老年代引用的对象） 中的survivor存活区块 . 这个阶段是并发运行的应用线程不需要停止，只有当前扫描完成后下一个young垃圾收集才能(STW)开始.</strong></li></ul></li><li><p><strong>Concurrent marking phase</strong>: The G1 GC finds reachable (live) objects across the entire heap. This phase happens concurrently with the application, and can be interrupted by STW young garbage collections.</p><ul><li><strong>并发标记阶段： G1 在整个堆中寻找可达存活的对象.这个阶段与应用线程并发执行，并且可以被young年轻代垃圾收集器(STW)打断.</strong></li></ul></li></ul><ul><li><p><strong>Remark phase</strong>: This phase is STW collection and helps the completion of the marking cycle. G1 GC drains SATB buffers, traces unvisited live objects, and performs reference processing.</p><ul><li><strong>重新标记阶段(STW)： 这个阶段是为了帮助其完成标记周期的。G1将会清空SATB(Snapshot-At-The-Beginning)的缓冲区，追踪未访问的存活对象，和执行重新引用进程。</strong></li></ul></li><li><p><strong>Cleanup phase</strong>: In this final phase, the G1 GC performs the STW operations of accounting and RSet scrubbing. During accounting, the G1 GC identifies completely free regions and mixed garbage collection candidates. The cleanup phase is partly concurrent when it resets and returns the empty regions to the free list.</p><ul><li>**清理阶段（STW）： 在这最后一步，G1 会执行 计算和清理RSET的STW操作. 在计算期间, G1 会分解出 完整的空闲区块 和 混合垃圾收集的和混合收集器待收集的对象。 清理阶段一定程度上是并发的当 重置和返回空区块到空闲清单  的时候。 **</li></ul></li></ul><h4 id="Garbage-Collection-Phases-垃圾收集阶段"><a href="#Garbage-Collection-Phases-垃圾收集阶段" class="headerlink" title="Garbage Collection Phases(垃圾收集阶段)"></a>Garbage Collection Phases(垃圾收集阶段)</h4><p>Apart from evacuation pauses (described below) that compose the stop-the-world (STW) young and mixed garbage collections, the G1 GC also has parallel, concurrent, and multiphase marking cycles. G1 GC uses the Snapshot-At-The-Beginning (SATB) algorithm, which takes a snapshot of the set of live objects in the heap at the start of a marking cycle. The set of live objects is composed of the live objects in the snapshot, and the objects allocated since the start of the marking cycle. The G1 GC marking algorithm uses a pre-write barrier to record and mark objects that are part of the logical snapshot.</p><ul><li><strong>下面的两段分别描述了组成 stop-the-world (STW) 的两种回收器， 年轻代回收器与混合回收器，G1 也具备 并发 ，并行 和 联合多相标记周期. G1 使用快照的算法，在标记周期开始之前取得堆中存活对象集合的快照. 快照中的存活对象集合组成了一个集合，并且在开始标记之前这些对象已经被分配好了.  G1的标记算法用了前置的写屏障来记录和标记对象来保证对象在物理快照中的一致性。</strong></li></ul><h4 id="Young-Garbage-Collections（年轻代的垃圾收集）"><a href="#Young-Garbage-Collections（年轻代的垃圾收集）" class="headerlink" title="Young Garbage Collections（年轻代的垃圾收集）"></a>Young Garbage Collections（年轻代的垃圾收集）</h4><p>The G1 GC satisfies most allocation requests from regions added to the eden set of regions. During a young garbage collection, the G1 GC collects both the eden regions and the survivor regions from the previous garbage collection. The live objects from the eden and survivor regions are copied, or evacuated, to a new set of regions. The destination region for a particular object depends upon the object’s age; an object that has aged sufficiently evacuates to an old generation region (that is, promoted); otherwise, the object evacuates to a survivor region and will be included in the CSet of the next young or mixed garbage collection.</p><ul><li><strong>G1满足大部分从一个区域添加到年轻代集合区域的内存申请，在年轻代回收期间，G1收集器会同时收集eden区域的垃圾和survivor区域的垃圾从上一个垃圾集中。 eden区和survivor区存活的对象已经被拷贝了，或者已经被撤离出当前区域到了一个的区域集。复制的目标区域是特定的，取决于对象的年龄来决定复制到哪个区块； 一个对象有足够的年龄撤离出eden与survivor到老年区域（这一步是晋升）； 另外，如果这个对象撤离到survivor 区 对象的引用会被包含到下一个young 或者 mixed 垃圾集的 cset 中.（CSET标记存活）</strong></li></ul><h4 id="Mixed-Garbage-Collections-（混合垃圾收集）"><a href="#Mixed-Garbage-Collections-（混合垃圾收集）" class="headerlink" title="Mixed Garbage Collections （混合垃圾收集）"></a>Mixed Garbage Collections （混合垃圾收集）</h4><p>Upon successful completion of a concurrent marking cycle, the G1 GC switches from performing young garbage collections to performing mixed garbage collections. In a mixed garbage collection, the G1 GC optionally adds some old regions to the set of eden and survivor regions that will be collected. The exact number of old regions added is controlled by a number of flags that will be discussed later (see “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Taming">Taming Mixed GCs</a>“). After the G1 GC collects a sufficient number of old regions (over multiple mixed garbage collections), G1 reverts to performing young garbage collections until the next marking cycle completes.</p><ul><li><strong>在成功完成并发标记周期的基础上，G1 从 执行年轻代垃圾收集切换到执行混合垃圾收集。在混合的垃圾收集模式中，G1选择性的添加一些老年代区块到已经被收集了的young和survivor的区块中.  一个标志数字控多少准确个老年代会被添加到已经被清空的新区块中；在G1 收集了足够多的old区块（在多个混合的垃圾集合中），G1 会切换执行young代的垃圾收集直到下一个标记周期完成.</strong></li></ul><ul><li><p><strong>核心算法实现</strong></p><ul><li><p><strong>Rset (Remember Set) 引用记忆集</strong></p><ul><li><p><strong>The G1 GC uses independent Remembered Sets (RSets) to track references into regions. Independent RSets enable parallel and independent collection of regions because only a region’s RSet must be scanned for references into that region, instead of the whole heap. The G1 GC uses a post-write barrier to record changes to the heap and update the RSets.</strong></p></li><li><p><strong>G1垃圾回收器使用独立的记忆集来追踪区域里的引用，独立的RSET允许并行，并且 每个区域的RSET是独立的，因为只有当前区域的RSET为了扫描引用才必须进入当前区域，从而避免全堆扫描。垃圾回收器利用后置写屏障来标记记录堆更改和RSET的更新.</strong></p></li></ul></li><li><p><strong>Cset（Collection Set）存活收集集</strong></p><ul><li><strong>The G1 GC reduces heap fragmentation by incremental parallel copying of live objects from one or more sets of regions (called Collection Set (CSet)) into different new region(s) to achieve compaction.</strong></li></ul><ul><li><strong>垃圾收集器为了减少堆内存碎片,将一组或多组区域的存活对象并行复制到不同的新区域来实现内存整理压缩.</strong></li></ul></li></ul></li></ul><h4 id="Important-Defaults-（官方文档）"><a href="#Important-Defaults-（官方文档）" class="headerlink" title="Important Defaults （官方文档）"></a>Important Defaults （官方文档）</h4><p>The G1 GC is an adaptive garbage collector with defaults that enable it to work efficiently without modification. Here is a list of important options and their default values. This list applies to the latest Java HotSpot VM, build 24. You can adapt and tune the G1 GC to your application performance needs by entering the following options with changed settings on the JVM command line.</p><ul><li><p>```<br>-XX:G1HeapRegionSize=n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Sets the size of a G1 region. The value will be a power of two and can range from 1MB to 32MB. The goal is to have around 2048 regions based on the minimum Java heap size.</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -XX:MaxGCPauseMillis=200</span><br></pre></td></tr></table></figure><p>Sets a target value for desired maximum pause time. The default value is 200 milliseconds. The specified value does not adapt to your heap size.</p></li><li><p>```<br>-XX:G1NewSizePercent=5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Sets the percentage of the heap to use as the minimum for the young generation size. The default value is 5 percent of your Java heap. This is an experimental flag. See &quot;[How to unlock experimental VM flags](https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock)&quot; for an example. This setting replaces the `-XX:DefaultMinNewGenPercent` setting. This setting is not available in Java HotSpot VM, build 23.</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -XX:G1MaxNewSizePercent=60</span><br></pre></td></tr></table></figure><p>Sets the percentage of the heap size to use as the maximum for young generation size. The default value is 60 percent of your Java heap. This is an experimental flag. See “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags</a>“ for an example. This setting replaces the <code>-XX:DefaultMaxNewGenPercent</code> setting. This setting is not available in Java HotSpot VM, build 23.</p></li><li><p>```<br>-XX:ParallelGCThreads=n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Sets the value of the STW worker threads. Sets the value of n to the number of logical processors. The value of `n` is the same as the number of logical processors up to a value of 8.</span><br><span class="line"></span><br><span class="line">  If there are more than eight logical processors, sets the value of `n` to approximately 5/8 of the logical processors. This works in most cases except for larger SPARC systems where the value of `n` can be approximately 5/16 of the logical processors.</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -XX:ConcGCThreads=n</span><br></pre></td></tr></table></figure><p>Sets the number of parallel marking threads. Sets <code>n</code> to approximately 1/4 of the number of parallel garbage collection threads (<code>ParallelGCThreads</code>).</p></li><li><p>```<br>-XX:InitiatingHeapOccupancyPercent=45</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Sets the Java heap occupancy threshold that triggers a marking cycle. The default occupancy is 45 percent of the entire Java heap.</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -XX:G1MixedGCLiveThresholdPercent=65</span><br></pre></td></tr></table></figure><p>Sets the occupancy threshold for an old region to be included in a mixed garbage collection cycle. The default occupancy is 65 percent. This is an experimental flag. See “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags</a>“ for an example. This setting replaces the <code>-XX:G1OldCSetRegionLiveThresholdPercent</code> setting. This setting is not available in Java HotSpot VM, build 23.</p></li><li><p>```<br>-XX:G1HeapWastePercent=10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Sets the percentage of heap that you are willing to waste. The Java HotSpot VM does not initiate the mixed garbage collection cycle when the reclaimable percentage is less than the heap waste percentage. The default is 10 percent. This setting is not available in Java HotSpot VM, build 23.</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -XX:G1MixedGCCountTarget=8</span><br></pre></td></tr></table></figure><p>Sets the target number of mixed garbage collections after a marking cycle to collect old regions with at most <code>G1MixedGCLIveThresholdPercent</code> live data. The default is 8 mixed garbage collections. The goal for mixed collections is to be within this target number. This setting is not available in Java HotSpot VM, build 23.</p></li><li><p>```<br>-XX:G1OldCSetRegionThresholdPercent=10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Sets an upper limit on the number of old regions to be collected during a mixed garbage collection cycle. The default is 10 percent of the Java heap. This setting is not available in Java HotSpot VM, build 23.</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -XX:G1ReservePercent=10</span><br></pre></td></tr></table></figure><p>Sets the percentage of reserve memory to keep free so as to reduce the risk of to-space overflows. The default is 10 percent. When you increase or decrease the percentage, make sure to adjust the total Java heap by the same amount. This setting is not available in Java HotSpot VM, build 23.</p></li></ul><h4 id="How-to-Unlock-Experimental-VM-Flags"><a href="#How-to-Unlock-Experimental-VM-Flags" class="headerlink" title="How to Unlock Experimental VM Flags"></a>How to Unlock Experimental VM Flags</h4><p>To change the value of experimental flags, you must unlock them first. You can do this by setting <code>-XX:+UnlockExperimentalVMOptions</code> explicitly on the command line before any experimental flags. For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=10 -XX:G1MaxNewSizePercent=75 G1test.jar</span><br></pre></td></tr></table></figure><h4 id="Recommendations"><a href="#Recommendations" class="headerlink" title="Recommendations"></a>Recommendations</h4><p>When you evaluate and fine-tune G1 GC, keep the following recommendations in mind:</p><ul><li><p><strong>Young Generation Size</strong>: Avoid explicitly setting young generation size with the <code>-Xmn</code> option or any or other related option such as <code>-XX:NewRatio</code>. Fixing the size of the young generation overrides the target pause-time goal.</p></li><li><p><strong>Pause Time Goals</strong>: When you evaluate or tune any garbage collection, there is always a latency versus throughput trade-off. The G1 GC is an incremental garbage collector with uniform pauses, but also more overhead on the application threads. The throughput goal for the G1 GC is 90 percent application time and 10 percent garbage collection time. When you compare this to Java HotSpot VM’s throughput collector, the goal there is 99 percent application time and 1 percent garbage collection time. Therefore, when you evaluate the G1 GC for throughput, relax your pause-time target. Setting too aggressive a goal indicates that you are willing to bear an increase in garbage collection overhead, which has a direct impact on throughput. When you evaluate the G1 GC for latency, you set your desired (soft) real-time goal, and the G1 GC will try to meet it. As a side effect, throughput may suffer.</p></li><li><p>Taming Mixed Garbage Collections</p><p>: Experiment with the following options when you tune mixed garbage collections. See “</p><p>Important Defaults</p><p>“ for information about these options:</p><ul><li><code>-XX:InitiatingHeapOccupancyPercent</code><br>For changing the marking threshold.</li><li><code>-XX:G1MixedGCLiveThresholdPercent</code> and <code>-XX:G1HeapWastePercent</code><br>When you want to change the mixed garbage collections decisions.</li><li><code>-XX:G1MixedGCCountTarget</code> and <code>-XX:G1OldCSetRegionThresholdPercent</code><br>When you want to adjust the CSet for old regions.</li></ul></li></ul><h4 id="Overflow-and-Exhausted-Log-Messages"><a href="#Overflow-and-Exhausted-Log-Messages" class="headerlink" title="Overflow and Exhausted Log Messages"></a>Overflow and Exhausted Log Messages</h4><p>When you see to-space overflow/exhausted messages in your logs, the G1 GC does not have enough memory for either survivor or promoted objects, or for both. The Java heap cannot expand since it is already at its max. Example messages:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs]</span><br></pre></td></tr></table></figure><p>OR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]</span><br></pre></td></tr></table></figure><p>To alleviate the problem, try the following adjustments:</p><p>Increase the value of the <code>-XX:G1ReservePercent</code> option (and the total heap accordingly) to increase the amount of reserve memory for “to-space”.</p><p>Start the marking cycle earlier by reducing the <code>-XX:InitiatingHeapOccupancyPercent</code>.</p><p>You can also increase the value of the <code>-XX:ConcGCThreads</code> option to increase the number of parallel marking threads.</p><p>See “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Imp">Important Defaults</a>“ for a description of these options.</p><h4 id="Humongous-Objects-and-Humongous-Allocations"><a href="#Humongous-Objects-and-Humongous-Allocations" class="headerlink" title="Humongous Objects and Humongous Allocations"></a>Humongous Objects and Humongous Allocations</h4><p>For G1 GC, any object that is more than half a region size is considered a “Humongous object”. Such an object is allocated directly in the old generation into “Humongous regions”. These Humongous regions are a contiguous set of regions. <code>StartsHumongous</code> marks the start of the contiguous set and <code>ContinuesHumongous</code> marks the continuation of the set.</p><p>Before allocating any Humongous region, the marking threshold is checked, initiating a concurrent cycle, if necessary.</p><p>Dead Humongous objects are freed at the end of the marking cycle during the cleanup phase also during a full garbage collection cycle.</p><p>In-order to reduce copying overhead, the Humongous objects are not included in any evacuation pause. A full garbage collection cycle compacts Humongous objects in place.</p><p>Since each individual set of StartsHumongous and ContinuesHumongous regions contains just one humongous object, the space between the end of the humongous object and the end of the last region spanned by the object is unused. For objects that are just slightly larger than a multiple of the heap region size, this unused space can cause the heap to become fragmented.</p><p>If you see back-to-back concurrent cycles initiated due to Humongous allocations and if such allocations are fragmenting your old generation, please increase your <code>-XX:G1HeapRegionSize</code> such that previous Humongous objects are no longer Humongous and will follow the regular allocation path.</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>G1 GC is a regionalized, parallel-concurrent, incremental garbage collector that provides more predictable pauses compared to other HotSpot GCs. The incremental nature lets G1 GC work with larger heaps and still provide reasonable worst-case response times. The adaptive nature of G1 GC just needs a maximum soft-real time pause-time goal along-with the desired maximum and minimum size for the Java heap on the JVM command line.</p><h4 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h4><ul><li><a href="https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html">The Garbage-First Garbage Collector</a></li><li><a href="https://www.oracle.com/java/technologies/javase/javase-core-technologies-apis.html">Java HotSpot Garbage Collection</a></li></ul><h4 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h4><p>Monica Beckwith, Principal Member of Technical Staff at Oracle, is the performance lead for the Java HotSpot VM’s Garbage First Garbage Collector. She has worked in the performance and architecture industry for over 10 years. Prior to Oracle and Sun Microsystems, Monica lead the performance effort at Spansion Inc. Monica has worked with many industry standard Java based benchmarks with a constant goal of finding opportunities for improvement in the Java HotSpot VM.</p><h3 id="王者ZGC"><a href="#王者ZGC" class="headerlink" title="王者ZGC"></a>王者ZGC</h3><ul><li><p><strong>回收过程</strong></p><ul><li><p><strong>初始标记 STW</strong></p></li><li><p><strong>并发标记</strong></p></li><li><p><strong>并发转移STW</strong></p></li></ul></li><li><p><strong>核心算法</strong></p><ul><li><p><strong>标记对象指针</strong></p><ul><li><strong>暂时可以理解为在64位内存地址中取三个标志位映射对象的同一块物理内存地址，标记对象的标记过程，重新定位过程，等GC回收标志</strong></li></ul></li><li><p><strong>合理利用64位处理器架构 ，Numa架构</strong></p><ul><li><strong>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那其中一颗CPU上的12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。</strong></li></ul></li><li><p><strong>读屏障</strong></p><ul><li>因为在标记和移动过程中，GC线程和应用线程是并发执行的，所以存在这种情况：对象A内部的引用所指的对象B在标记或者移动状态，为了保证应用线程拿到的B对象是对的，那么在读取B的指针时会经过一个 “load barriers” 读屏障，这个屏障可以保证在执行GC时，数据读取的正确性。</li></ul></li><li><p><strong>Compacting 内存页压缩</strong></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM之GC垃圾回收器浅析&quot;&gt;&lt;a href=&quot;#JVM之GC垃圾回收器浅析&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC垃圾回收器浅析&quot;&gt;&lt;/a&gt;JVM之GC垃圾回收器浅析&lt;/h2&gt;&lt;p&gt;Wirte by 021.   Leave a me</summary>
      
    
    
    
    <category term="Java" scheme="http://www.010101.cc/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://www.010101.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构RingBuffer之机械之美---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84RingBuffer%E4%B9%8B%E6%9C%BA%E6%A2%B0%E4%B9%8B%E7%BE%8E---TODO/"/>
    <id>http://www.010101.cc/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84RingBuffer%E4%B9%8B%E6%9C%BA%E6%A2%B0%E4%B9%8B%E7%BE%8E---TODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-18T04:45:53.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构RingBuffer之机械之美"><a href="#数据结构RingBuffer之机械之美" class="headerlink" title="数据结构RingBuffer之机械之美"></a>数据结构RingBuffer之机械之美</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbmoyywxmj30xp0j0gnc.jpg" alt="B+ Tree structure with buckets (Begginer question) - Database  Administrators Stack Exchange"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构RingBuffer之机械之美&quot;&gt;&lt;a href=&quot;#数据结构RingBuffer之机械之美&quot; class=&quot;headerlink&quot; title=&quot;数据结构RingBuffer之机械之美&quot;&gt;&lt;/a&gt;数据结构RingBuffer之机械之美&lt;/h2&gt;&lt;p&gt;Wi</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="线性结构" scheme="http://www.010101.cc/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>经典设计之AQS与ConcurrentHashMap---TODO</title>
    <link href="http://www.010101.cc/2021/11/11/%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E4%B9%8BAQS%E4%B8%8EConcurrentHashMap---TODO/"/>
    <id>http://www.010101.cc/2021/11/11/%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E4%B9%8BAQS%E4%B8%8EConcurrentHashMap---TODO/</id>
    <published>2021-11-11T07:04:04.000Z</published>
    <updated>2021-11-18T04:47:09.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典设计之AQS与ConcurrentHashMap—TODO"><a href="#经典设计之AQS与ConcurrentHashMap—TODO" class="headerlink" title="经典设计之AQS与ConcurrentHashMap—TODO"></a>经典设计之AQS与ConcurrentHashMap—TODO</h2><p>Wirte by 021.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbmoyywxmj30xp0j0gnc.jpg" alt="B+ Tree structure with buckets (Begginer question) - Database  Administrators Stack Exchange"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经典设计之AQS与ConcurrentHashMap—TODO&quot;&gt;&lt;a href=&quot;#经典设计之AQS与ConcurrentHashMap—TODO&quot; class=&quot;headerlink&quot; title=&quot;经典设计之AQS与ConcurrentHashMap—TOD</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.010101.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="设计模式" scheme="http://www.010101.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
